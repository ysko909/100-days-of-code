# 100 Days Of Code - 学習ログ

## 2020年11月分

### 31日目: 2020年11月1日（日）

**今日の進捗**: 

JavaScriptの[分割代入](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)について。

- 配列の要素を個別の変数に格納したいときに、**一度にすべての要素を個別の変数に格納する**書き方。

```JavaScript
let hoge = [1, 'ham', 2];

// 1つ1つ指定する方法
let val1 = hoge[0];
let val2 = hoge[1];
let val3 = hoge[2];

console.log(val1);
console.log(val2);
console.log(val3);

// 分割代入する方法
let [foo, bar, baz] = hoge;

[foo, bar, baz].forEach(j => {
console.log(j);
});
```

- 配列`hoge`の要素を取り出し個別の変数に格納する場合、1つ1つ配列から添え字を使って取り出し、変数に格納する方法がまず考えられる。まぁ、これでもいいのだが「もうちょっとどうにかならないかね」ってときに使えるのが分割代入。
- 配列の要素ごとに変数を指定してカッコで囲うことで、どの要素をどの変数に格納するかを指定する。この方法なら一度に指定できる。これが分割代入。

```console
1
ham
2
1
ham
2
```

- どちらも同じ出力になる。

```JavaScript
let hoge = [1, 2, 3, 4, 5, 6, 7, 8, 9];

let [foo, , bar, ...baz] = hoge;

[foo, bar, baz].forEach(j => {
  console.log(j);
});
```

- 要らない要素が存在するなら、格納先の変数を記述しないことで読み捨てられる。上記の例でいうと2つ目の要素を捨てている。
- 「これ以降の要素は全部1つの変数にぶち込みたい」という場合は、`...変数名`と記述する。すると、残っている要素全部をその変数に格納する。

```console
1
3
[
4 ,
5 ,
6 ,
7 ,
8 ,
9
] 
```

- 2つ目の要素は捨てられて、4つ目以降の要素は1つの変数（`baz`のこと）にまとめて格納されていることがわかる。

```javascript
let hoge = {
  'foo': 1,
  'bar': 2,
  'baz': 3
};

let {foo, bar, baz} = hoge;

[foo, bar, baz].forEach(j => {
  console.log(j);
});

let {foo: val1, bar: val2, } = hoge;

[val1, val2].forEach(j => {
  console.log(j);
});
```

- オブジェクトに対しても同様の操作が可能。ただし、格納先の変数名は**オブジェクトのプロパティと同じ名前の変数でないとダメ**という縛りがある。
- 格納先の変数名を変更したい場合は、コロンで区切って新しい名称を記述する。

```console
1
2
3
1
2
```

- オブジェクトでも分割代入できた。

**思ったこと**: 

- JSってさぁ、なんかいつまで経っても「今まで見たことないような書き方」が出てきて**飽きない**ねぇ（比喩

**リンク**

1. [分割代入](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)
1. [JavaScriptの代入において時々現れる、括弧で囲まれた変数名は何なのか](https://sbfl.net/blog/2019/08/26/javascript-bracketed-variables/)

### 32日目: 2020年11月2日（月）

**今日の進捗**: 

p5.jsを使ってサインカーブを描画するメモ。

- p5.jsと三角関数を使って、サインカーブを描画する方法。とりあえず、後学のため解釈した順番で記述する。

```javascript
let x = 0;
let y = 0;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(2);
}

function draw(){
  background(255);
  point(x, y);
  
}
```

- 最初の基本形。点を一つ座標`(x,y)`に打つ。初期状態では`(0, 0)`になる。ただ、これだけでは当たり前だが画面上に動きはない。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
}

function draw(){
  background(255);
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  theta++;
  point(x, y);
}
```

- 画面に動きを出すため、`(0,0)`固定だった点の座標を時間経過とともに変更する。具体的には、`point(x, y)`としてx座標およびy座標を時間経過とともに変更させればいい。
- 座標を変更するためには三角関数を利用して角度（ここでは`theta`）とラジアン（ここでは`r`）の2つを利用する。[弧度法](https://ja.wikipedia.org/wiki/%E3%83%A9%E3%82%B8%E3%82%A2%E3%83%B3)というやつで、「円弧の長さlから角度ってわかるじゃん、xx度とか別に使わなくてもいいじゃん」という方法。

> 180度 = PI * rad

- 「xx度」で角度を表現する方法は[度数法](https://ja.wikipedia.org/wiki/%E5%BA%A6_(%E8%A7%92%E5%BA%A6))と言う。この方法でももちろんいいのだが、度数法は円を360等分することにより表現するせいで、角度が「123.45度」なんて小数で表現しなきゃいけないケースも出てくる。そうなるとプログラミング上面倒。同じ小数でも、角度より弧の長さの方がまだ使いやすい。よって、後述の極座標を用いた位置指定の方法がプログラミングの上では楽なので、たいていの場合度数法より弧度法を利用するケースの方が多い気がする。
- 1ラジアンは、半径が1の単位円なら円弧の長さlがそのままラジアンになる。弧の長さlが1なら1ラジアン、lが2なら2ラジアン・・・という感じ。
- 度数とラジアンの対応は、半径1の単位円において円周の長さは2PIなので、それがそのまま360度のラジアンになる。となると、その半分である180度のラジアンはPIになる。
- そして、角度がわかれば原点からの距離rを指定することで(x, y)の座標がわからなくても位置を特定できる。この角度thetaと距離rで位置を特定する方法を**極座標**という。なお、馴染み深い(x, y)の形式による位置特定の方法を直交座標という。
- さらに、極座標と直交座標は相互に変換が可能。

> (x, y) = (r * cos theta, r * sin theta)

- 上記のように三角関数を利用することで極座標と直交座標の変換を交互に変換できる。

> (1, 1) = (√2, PI / 4)

- 座標(1, 1)において極座標では(√2, PI / 4)で表現できる。ちなみに上記の例だと「却って面倒になってるじゃんか！」と見えるかもしれないが、これは直交座標側を(1, 1)というえらくわかりやすい座標にしているため。
- このあたりのことをやっているコードが`y = centerY + r * sin(radians(theta));`の箇所。この1文でy座標を時間経過とともに変更できる。ちなみに`centerY`はCanvasの高さの半分。つまり、中心を示している。
- このコードで、「左端で上下に移動する点」を描画できる。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
}

function draw(){
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  theta++;
  x++;
  point(x, y);
}
```

- 上記のコードで、サインカーブを描画をできる。

  ![pic](2020-11-03-11-45-58.png)

- 基本的には前のコードと同一だが、`draw()`関数内で、`background()`を削除しx座標を1加算する処理を加えた。これにより、時間経過とともに、カーブを描画をできる。
- `theta`に加算する数を増やすとカーブの間隔が狭くなる。逆に減らすと間隔が広くなる。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;
let centerX;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
  centerX = width / 2;
  
}

function draw(){
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  x = centerX + r * cos(radians(theta));
  point(x, y);
  theta += 1;

}
```

- 今度は時間経過で円を描く。

  ![pic](2020-11-03-11-47-04.png)

- x座標は`r * cos(radians(theta))`で求められる。この値とX軸の中心である`centerX`を加算することで、時間経過とともに円が描画される。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;
let centerX;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
  centerX = width / 2;
  
}

function draw(){
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  x = centerX + r * cos(radians(theta));
  point(x, y);
  theta += 1;

  if (theta > 360){
    theta = 0;
    r += 10;
  }
}
```

- 円を描画し終わったときの処理を追加した。

  ![pic](2020-11-03-11-48-13.png)

- 1つの円を描画し終わると、`r`に任意の値を加算して、更に円を描画する。ここでは10を加算して、一度描画した円の外側に新しい円を描画する。

**思ったこと**: 

- 三角関数なんてまともにやったの何年ぶりですかね・・・。こういうのって後になって役に立つんだよなぁ。

**リンク**

1. [p5.js point](https://p5js.org/reference/#/p5/point)

### 33日目: 2020年11月3日（火）

**今日の進捗**: 

webアニメーションのメモ。

- [2020年中期のWebアニメーション実装の全容俯瞰](https://qiita.com/ryokkkke/items/42ae2a661d64036285d2)
- webにアニメーションを導入したい際に参照する。

----

[moment.js](https://momentjs.com/)が[メンテナンスモードに入っていた](https://mag.osdn.jp/20/09/18/113400)。新規機能の追加は行わず、バージョン3はなく（現在の最新版は2.29.1）、重要なセキュリティ問題には対処する・・・とのこと。

代替ライブラリはいろいろあるが、スター数が多めなのは下記の2つ。

- [day.js](https://github.com/iamkun/dayjs)
- [date-fns](https://github.com/date-fns/date-fns)

ぱっと見での判断だけど、day.jsの方が可読性が高そうな印象。

----

というわけで、[day.js](https://github.com/iamkun/dayjs)を試してみる。

```JavaScript
const hoge = '2020/4/1';

$ = (hoge) => {
  console.log(hoge);
}

$('--get today--');
$(dayjs().format());
$(dayjs()); // これはオブジェクト扱い

newDate = dayjs(hoge);
$(newDate); // これはオブジェクト扱い
$(newDate.format());

$('--get year--');
$(newDate.year());
$('--get month--');
$(newDate.month());
$('--get day--');
$(newDate.day());
$(newDate.date());
$('--another get date--');
$(dayjs().get('year'));
$(dayjs().get('month'));
$(dayjs().get('date'));
$(dayjs().get('hour'));
$(dayjs().get('minute'));
$(dayjs().get('second'));
$(dayjs().get('milisecond'));

$('--month comperison--');
date3 = new Date(2020, 8, 1);
date4 = new Date('01 Sep 2020');

$(date3.getTime() === date4.getTime());
```

- とりあえずざっくり公式のAPIを見ながら書いてみた。`dayjs()`で取得できるのは今日の日付なんだけど、**オブジェクト扱いになってしまう**ので`format()`を付けて表示すればいい。

```console
--get today--"
"2020-11-02T10:35:24+09:00"
Object {↔}
Object {↔}
"2020-04-01T00:00:00+09:00"
"--get year--"
2020
"--get month--"
3
"--get day--"
3
1
"--another get date--"
2020
10
2
10
35
24
```

- いいところは何もしなくても日本時間になっていること。注意点は相変わらず**月が0から始まること**。

----

JavaScriptの`keys()`について。

- `Object.keys()`じゃなくて`Array.prototype.keys()`の方。こっちは対象の配列が持つインデックスのキーを**イテレータで返す**。インデックスキーをそのまま返すわけではないので注意。

```JavaScript
let num = 10;

console.log(Array(num).keys());

for (const key of Array(num).keys()){
  console.log(key);
}

console.log(...Array(num).keys());
```

- 単純に`Array(num).keys()`とした場合、イテレータが返ってくる。それだけでは使えないが、for文のループを用いてインデックスキーの出力ができる。

```console
[object Array Iterator]
0
1
2
3
4
5
6
7
8
9
0 1 2 3 4 5 6 7 8 9
```

- 上記のように、単純に`Array.prototype.keys()`を実行するだけではイテレータが返ってくるだけだが、ループに入れたり`...`で要素を個別に取得することで内容を参照できる。

```JavaScript
let hoge = ['a', , 'c'];

$ = (fuga) => {
  console.log(fuga);
};

$(hoge);
$(Object.keys(hoge));
$([...hoge.keys()]);
```

- `Object.keys()`は、ある任意のオブジェクトが含むキーを出力するメソッドだったが、`Array.prototype.keys()`は対象の配列が持つインデックスキーをイテレータを出力する。この場合、元の配列が[疎な配列](https://qiita.com/t2kojima/items/0ddaba1f336bfcc1e8cd)である場合、挙動が異なる。

```console
["a", undefined, "c"]
["0", "2"]
[0, 1, 2]
```

- 存在しない要素を無視してインデックスキーを出力する`Object.keys()`に対し、要素の有無に関係なく配列の長さ分インデックスキーを返す`Array.prototype.keys()`。要素に対して何かしらの操作や処理を行う場合、`Object.keys()`を使うのが正解。

----

JavaScriptの「疎な配列」についてメモ。

- 「長さは3なのに要素の数は2」みたいな配列のこと。なんじゃそら。

```JavaScript
let hoge = [, , , ];

$ = (arg) => {
  console.log(arg);
}

$(hoge);
$(hoge.length);
```

- `let hoge = [, , , ];`という**要素を指定せずに配列の形式だけ指定する**ことが可能。Pythonでやるとエラーになる（大抵の言語仕様じゃエラーになるんじゃないか？）が、JSは可能。

```console
[undefined, undefined, undefined]
3
```

- 結果は`undefined`が3つ並ぶわりに、ちゃんと配列の長さを認識している。
- この「疎な配列」をどのように利用するかだが、狙って利用するようなケースがどれだけあるかと言われるとかなり悩ましい。
- ただ、何かしらの都合で配列中の要素が欠落して疎な配列になったときに、本来想定する挙動と異なる動作をすることが予測できる。その際に、知識があるかないかでエラー解消までの時間に差が出てくるのはよくある話。やっぱり知識は無駄にならない。

**思ったこと**: 

- [「震える」動作に特化したjsライブラリ](https://elrumordelaluz.github.io/csshake/)とかすげーニッチじゃん・・・って思ったけど、案外スター付いてて草。
- JSの月の扱い、ホントどうにかなりませんかね・・・いやもうね、コレホントにどうにかなりませんか。直感でわかりにくいのよ。
- 日本人は月を1月、2月、3月・・・と数字で表現するが、欧米人はJan、Feb、Mar・・・と**英単語で表現する**。つまり、JSの設計者たちは月を数字で扱わないので、ゼロからスタートでも全く問題ない、というのをどこかで見た。なるほどなー。
- [JavaScript Primer](https://jsprimer.net/)っていうサイトを見つけた。ECMAScript2015以降のJSで参考にできるオンライン上のテキストとしては、かなりいい出来なのではないか。

**リンク**

1. [2020年中期のWebアニメーション実装の全容俯瞰](https://qiita.com/ryokkkke/items/42ae2a661d64036285d2)
1. [Moment.jsがメンテナンスモードへーー新機能開発は行わず](https://mag.osdn.jp/20/09/18/113400)
1. [Day.jsで簡単に日付処理！](https://www.ultra-noob.com/blog/2020-05-11-Day.js%E3%81%A7%E7%B0%A1%E5%8D%98%E3%81%AB%E6%97%A5%E4%BB%98%E5%87%A6%E7%90%86%EF%BC%81/)
1. [Array.prototype.keys()](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/keys)
1. [疎な配列（Sparse Arrays）](https://qiita.com/t2kojima/items/0ddaba1f336bfcc1e8cd)

### 34日目: 2020年11月4日（水）

**今日の進捗**: 

p5.jsでの`vertex()`を使った描画について。

- `vertex()`は`startShape()`と`endShape()`の間において、指定された分の頂点を結んで点から多角形までを描画する。
- `vertex()`が記述された数が3つなら三角形だし、12個なら十二角形になる。ただし、座標を結んでいるだけなので正三角形にするにはそれなりの座標にしないといけないし、その計算はプログラミングするしかない。

```JavaScript
function setup(){
  createCanvas(800, 600);
  noFill();
  colorMode(HSB);
}

function draw(){
  background(0);
  stroke(255);
  beginShape();
  vertex(0, 0);
  vertex(100, 100);
  endShape();
}
```

- 上記は2点の座標を記述したもの。この場合、直線が描画される。

  ![pic](2020-11-03-11-51-23.png)

- x座標とy座標を明示的に指定しているところから、直交座標として指定していると言える。

```JavaScript
function setup(){
  createCanvas(800, 600);
  noFill();
  colorMode(HSB);
}

function draw(){
  background(0);
  strokeWeight(2);
  stroke(255);
  beginShape();
  
  let x, y;
  let splitX = 10;
  
  x = 100 * cos(radians(45));
  y = 100 * sin(radians(45));
  
  vertex(0, 0);
  vertex(x, y);
    
  endShape();
}
```

- 上記は弧度法を用いて座標を指定したもの。極座標として指定していると言える。

  ![pic](2020-11-03-11-52-01.png)

- 直線の長さこそ異なるものの、直線が左上から45度の方向に伸びているのは同じ。直交座標と比べて、極座標はスタートから見て度の方向にどの長さで直線が伸びているかが、コードを読むとすぐわかる。

```JavaScript
function setup(){
  createCanvas(800, 600);
  noFill();
  colorMode(HSB);
}

function draw(){
  background(0);
  strokeWeight(2);
  stroke(255);
  beginShape();
  
  let x, y;
  let splitX = 10;
  
  [...Array(splitX).keys()].forEach(i => {
    x = i / (splitX - 1) * width;
    y = (height / (i + 1));
    vertex(x, y);
  })
    
  endShape();
}
```

- 上記では10本の直線を連続的に描画することで、対数関数のグラフのような線を描画している。

  ![pic](2020-11-03-11-52-43.png)

```javascript
let theta = 0;

function setup(){
  createCanvas(800, 600);
  noFill();
  colorMode(HSB);
}

function draw(){
  background(0);
  strokeWeight(2);
  stroke(255);
  beginShape();
  
  let x, y;
  let splitX = 10;
  
  x = 100 * cos(radians(theta)) + width / 2;
  y = 100 * sin(radians(theta)) + height / 2;
  
  vertex(width / 2, height / 2);
  vertex(x, y);
    
  endShape();
  
  theta++;
}
```

- 画面中心を原点とし、時間経過とともに直線が回転する。

  ![pic](2020-11-03-13-11-08.png)

```javascript
let theta = 0;

function setup(){
  createCanvas(800, 600);
  noFill();
  colorMode(HSB);
}

function draw(){
  background(0);
  strokeWeight(2);
  stroke(255);
  beginShape();
  
  let x, y;
  let splitX = 10;

  [...Array(splitX).keys()].forEach(i => {
    x = (i / (splitX - 1)) * width;
    y = 100 * sin(radians(theta + i * 50)) + (height / 2);
    vertex(x, y);
  });
  
  endShape();
 
  theta++;
}
```

- サインカードのような複数の直線を描画する。

  ![pic](2020-11-03-13-12-00.png)

- `y = 100 * sin(radians(theta + i * 50)) + (height / 2);`の50の部分の数字を変えると、描画の滑らかさが変化する。数字が小さいと滑らかに、数字が大きいと角ばった描画になる。
- `splitX`の値を増やすとカーブの間隔が狭くなる。

```javascript
function setup(){
  createCanvas(200, 200);
}

function draw(){
  background(255);
  let date = Date.now() / 1000;

  for (let i = 0; i < width; i++){
    point(i, noise(date++) * height);
  }
}
```

- 蛇足。パーリンノイズを使ってY座標を適当に設定した点を描画する。

  ![pic](2020-11-03-13-12-43.png)

- なぜか奥方向に（X軸を中心として）回転しているように見える。そう見えるだけで、プログラム上では単純に点を描画しているだけ。なのだが、目の錯覚のせいだろうか。

```javascript
let seed = 0;

function setup(){
  frameRate(24);
  createCanvas(200, 200);
}

function draw(){
  background(255);

  let lineNum = 10;
  
  for (let j = 0; j < lineNum; j++){

    for (let i = 0; i < width; i++){
      point(i, noise(seed) * height);
      seed += 0.01;
    }
  } 
}
```

- もう一つ蛇足。ノイズ波形のほうな波を複数生成する。

  ![pic](2020-11-03-13-13-19.png)

- `lineNum`を増やすと、その分複数の波形を生成する。

```JavaScript
let seed = 0;

function setup(){
  frameRate(24);
  createCanvas(200, 200);
}

function draw(){
  background(255, 70);

  let lineNum = 10;
  
  for (let j = 0; j < lineNum; j++){

    for (let i = 0; i < width; i++){
      point(i, noise(seed) * height);
      seed += 0.01;
    }
  }
}
```

- 上記の派生版。

  ![pic](2020-11-03-13-13-53.png)

- `background()`でCanvasを初期化する際、透明度を設置することで過去に描画した波形をちょっとだけ残す。

**思ったこと**: 

- p5.js、おもしろいな・・・。

**リンク**

1. [noise](https://p5js.org/reference/#/p5/noise)
2. [7_1：フレーム p5.js JavaScript](https://himco.jp/2019/02/20/7_1%EF%BC%9A%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0/)

### ３５日目: 2020年11月5日（木）

**今日の進捗**: 

A-Frameを使ったアニメーションの設定方法。

- アニメーションを設定したいエンティティに対して`animation`プロパティを設定する。

```html
<html>

<head>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://jeromeetienne.github.io/AR.js/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
</head>

<body>
    <a-scene embedded arjs="debugUIEnabled:false;" renderer="gammaOutput: true;" vr-mode-ui="enabled: false">
        <a-assets>
            <a-asset-item id="persona_lain_waving" src="persona_lain_waving.glb"></a-asset-item>
        </a-assets>

        <a-entity scale="1 1 1" rotaion="0 0 0" position="0 0.4 -3" animation-mixer="clip:*"
            gltf-model="#persona_lain_waving" visible="true"
            animation="property: position; from: 0 0.5 -3; to: 0 0.8 -3; dir: alternate; dur: 1500; easing: easeInOutQuad; loop: true">
        </a-entity>

        <a-light type="ambient" color="#ffffff"></a-light>
        <a-light type="point" intensity="2" position="0 4 0"></a-light>
    </a-scene>
</body>

</html>
```

- 上記で設定している項目は下記の通り。
  - property：アニメーションする対象。今回は`position`なので、3Dモデルの位置が変化する。
  - from：アニメーション開始の`position`。エンティティの初期位置よりY時を下に設定するとモデルの下部分が欠けるため、Y軸の位置は0.4より上に設定している。
  - to：アニメーション終了の`position`。
  - dir：fromからtoの間をどのように移動するかを設定する。`normal`だとfromからtoへの一方通行、`alternate`だとfromとtoと交互に往復する。`reverse`はtoからfromへ一方通行。
  - dur：1回のアニメーションに要する時間。ミリ秒。
  - easing：アニメーションのイージング。[ここ](https://easings.net/ja)がすごい参考になる。
  - loop：アニメーションをループさせるか否か。

**思ったこと**: 

- glTF単体でモーション設定するのもいいけど、A-Frameのアニメーションもね！
- 実際問題、単純な上下運動とかのアニメーションはA-Frameで書いた方が話が早いし、JavaScriptで書き換えられたりするので使い勝手がいい。とはいえ、Mixamo使ってる段階で上下運動みたいな簡単なモーションを付ける理由はないのだが。

**リンク**

1. [Animation](https://aframe.io/docs/1.0.0/components/animation.html#easings)
1. [easing](https://easings.net/ja)

### 36日目: 2020年11月6日（金）

**今日の進捗**: 

p5.jsにおける画像の扱い方について。

- 画像をCanvasに表示する。

```JavaScript
function preload(){
  img = loadImage('https://upload.wikimedia.org/wikipedia/commons/c/c7/Beautiful_Land.jpg');
}

function setup(){
  createCanvas(800, 600);
}

function draw(){
  image(img, 0, 0);
}
```

- 画像は適当に[wikimedia commons](https://commons.wikimedia.org/)から拾ってきた。
- 画像は`preload()`関数内でロードする。この関数は`setup()`の直前に呼び出されて、記述された外部ファイルがロードされるまで`setup()`が実行されない。
- `preload()`関数内には、画像やJSON、フォントなど外部ファイルの読み込み以外には利用すべきでない。
- 画像の読み込みは`loadImage()`関数で行う。引数にはファイルのURLの他に、読み込みが成功あるいは失敗した際のコールバック関数を記述できる。
- 画像は`loadImage()`で読み込んだだけではCanvas内に表示されないので、`image()`関数を使ってCanvasに描画する必要がある。引数には読み込んだ画像を指定し、Canvas上に表示する座標を指定する。座標は`(0, 0)`で左上を指す。

```JavaScript
function preload(){
  img = loadImage('https://upload.wikimedia.org/wikipedia/commons/c/c7/Beautiful_Land.jpg');
}

function setup(){
  createCanvas(800, 600);
}

function draw(){
  background(255);
  image(img, 0, 0, mouseX, mouseY);
}
```

- `image()`関数の第4引数と第5引数は、表示する画像の幅と高さを指定する。この引数をマウスポインターの座標にすると、マウスポインターが動くとともに、表示される画像のサイズの変化する。

```javascript
const addPoint = 50;

function preload(){
  img_sky = loadImage('https://upload.wikimedia.org/wikipedia/commons/c/c7/Beautiful_Land.jpg');
  
  img_tree = loadImage('https://upload.wikimedia.org/wikipedia/commons/5/51/4_Trees_%2867356105%29.jpeg');
  
  img_night = loadImage('https://upload.wikimedia.org/wikipedia/commons/d/da/Amanecer_QJ_Ind..jpg');
}

function setup(){
  createCanvas(800, 600);
}

function draw(){
  background(255);
  
  image(img_sky, 0, 0);
  image(img_night, mouseX - addPoint, mouseY - addPoint, width - mouseX, height - mouseY);
  image(img_tree, 0, 0, mouseX + addPoint, mouseY + addPoint);
  
}
```

- 複数の画像を表示する場合、`preload()`関数内で表示したい画像をそれぞれ読み込む。表示される順番は、`draw()`関数内で`image()`関数を実行した順にCanvas上に描画される。
- マウスポインターを動かすと画像の表示サイズが変化するが、表示される順番は変化しない。

```javascript
const cellSize = 10;
const noiseValue = 100;
let seedNum = 0;

function preload(){
  img_night = loadImage('https://upload.wikimedia.org/wikipedia/commons/d/da/Amanecer_QJ_Ind..jpg');
}

function setup(){
  createCanvas(800, 600);
  noStroke();
  colorMode(HSB, 1, 100, 100, 100);
}

function draw(){

  
  background(255);
  
  image(img_night, 0, 0, width, height);
  
  [...Array(width / cellSize).keys()].forEach(x => {
    [...Array(height / cellSize).keys()].forEach(y => {
      fill(noise(x / noiseValue, y / noiseValue, seedNum), 100, 100, 50);
      rect(x * cellSize, y * cellSize, cellSize, cellSize);
      seedNum += 0.00001;
    });
  });
  
}
```

- 画像の上に、時間経過とともに変化するヒートマップを半透明にして表示している。
- ヒートマップはHSBのHue部分について、パーリンノイズを使って値を変化させている。単純にxとyを使ってパーリンノイズを使うと、変化量が極端すぎてただのノイズになってしまう。そこでxとyは任意の数字（ここでは定数`noiseValue`）で除算して、あるセル付近の変化量を緩やかにさせる。
- これだけだと初回実行でヒートマップの色が固定されてしまうので、パーリンノイズのzに相当する引数部分へ**時間経過とともに増加する数値**を渡してやって、ヒートマップの色がゆらゆらと変化するようにした。

```JavaScript
fill(noise(x / noiseValue * seedNum, y / noiseValue * seedNum * 2), 100, 100, 50);
```

- なお、zの引数を用いず上記のようにxとyに`noiseValue`を積算した場合、「絵を縮小」するような動きになる。これはこれで何かに使えそうな使えなさそうな・・・。

```JavaScript
const cellSize = 10;
const noiseValue = 100;
let seedNum = 0;

function preload(){
  img_night = loadImage('https://upload.wikimedia.org/wikipedia/commons/4/47/PNG_transparency_demonstration_1.png');
}

function setup(){
  createCanvas(800, 600);
  noStroke();
  colorMode(HSB, 1, 100, 100, 100);
}

function draw(){

  
  background(255);
  
  [...Array(width / cellSize).keys()].forEach(x => {
    [...Array(height / cellSize).keys()].forEach(y => {
      fill(noise(x / noiseValue, y / noiseValue, seedNum), 100, 100, 100);
      rect(x * cellSize, y * cellSize, cellSize, cellSize);
      seedNum += 0.00001;
    });
  });
  
  image(img_night, 0, 0, width, height);
  
}
```

- ヒートマップを表示し、その上に透過PNGを表示する。PNGの透過部分だけヒートマップが表示されて、ゆらゆらと変化する。

----

JavaScriptのテンプレートリテラルを使って、オブジェクトのプロパティを指定する方法。

```JavaScript
let hoge = {
  _x: 1,
  _y: 'foo',
  _z: 0.32
};

console.log(hoge['_x']);

['x', 'y', 'z'].forEach(j => {
  console.log(j);
});

['x', 'y', 'z'].forEach(j => {
  console.log(hoge[`_${j}`]);
})
```

- オブジェクトのプロパティを配列の要素などを用いて指定したい場合、ブラケット記法なら指定できる。

```console
1
x
y
z
1
foo
0.32
```
- プレースホルダに変数を指定することで、配列の要素を1つずつ参照する。上記の場合、配列の要素がプロパティ名になっているので、足りないアンダーバーだけ付与してやれば、プロパティ名を指定していることになり、プロパティに相当する値がコンソールに表示される。
- ちなみに、ドット記法だとエラーになるので注意が必要。

**思ったこと**: 

- ヒートマップでゆらゆらさせるのおもしろい・・・。ベースになる画像があれば、ヒートマップをオーバーレイすると楽しそう。

**リンク**

1. [p5.jsで「パーリンノイズ」のスゴさを思い知る](https://infosmith.biz/blog/it/p5js-noise#4)
1. [4_1：経時的変化 Creative Coding p5.js](https://himco.jp/2019/03/16/4_1%EF%BC%9A%E7%B5%8C%E6%99%82%E7%9A%84%E5%A4%89%E5%8C%96-creative-coding-javascript/)

### 37日目: 2020年11月7日（土）

**今日の進捗**: 

DockerでReactの環境を構築する。

- Reactの勉強用コンテナを準備する。

```dockerfile
FROM node:14.15-buster-slim

ENV APP_PATH=/home/workdir

RUN npm install -g create-react-app

ADD . $APP_PATH

WORKDIR $APP_PATH

# COPY ["package.json", "yarn.lock", ${PWD}]

COPY . $APP_PATH

EXPOSE 3000
```

- Node.jsのコンテナはDebianのbusterを採用した。多分メジャーどころはAlpineなんだろうけど、[こういう話](https://medium.com/swlh/alpine-slim-stretch-buster-jessie-bullseye-bookworm-what-are-the-differences-in-docker-62171ed4531d)もあるので、そこまでしてコンテナの容量を削らなくてもいいか、と思ってDebianを採用。
- 調べてみてわかったが、`yarn`はNode.jsのコンテナに**インストール済み**。なんでも[2017年ごろから同梱されている](https://odaryo.hatenablog.com/entry/2020/01/08/211618)らしい。
- 上記のDockerfileを任意のフォルダに保存しておいて、vscodeで「Reopen in container」する。
- ビルドが終わったコンテナにログインすると`create-react-app --version`が実行できるはず。
- ちなみに、vscodeでbashのターミナルを開くと、デフォルトのフォルダがホームではなく「/workspaces/<ローカルのフォルダ名>」になる。`WORKDIR`でコンテナ上のフォルダを指定しているはずなんだが・・・。正直、原因がわからないので放置している。ただし`docker exec -it <コンテナ名> /bin/bash`でコンテナのシェルを起動すると、ちゃんと`WORKDIR`で指定したフォルダにいる。なので、vscode側の問題だと思っている。

----

Dockerコンテナのシェルを起動するメモ。

- WindowsのコマンドプロンプトやMacのシェルなどから、Dockerコンテナのシェルを起動する手順について。

1. `docker ps`で実行中のコンテナを確認する。その中で、シェルを起動したいコンテナのコンテナ名を控えておく。
1. `docker exec -it <コンテナ名> /bin/bash`を実行する。プロンプトが変わったら、コンテナへログインしシェルが起動している。

**思ったこと**: 

- DockerでReact環境を作るっていう記事は、結構ネット上に転がっているものの、`docker-compose`使ったりしてたりして（将来的な拡張性はあるんだろうけど）とりあえずサクッと試したいっていう自分のニーズに合わなかったので、Dockerfileだけで作った。

**リンク**

1. [DockerHubのNodeイメージ一覧](https://hub.docker.com/_/node)
1. [DockerでReactの開発環境を作る](https://qiita.com/tanaka-tt/items/49628cd423e490120eeb)
1. [Reactの開発環境をDockerで構築してみた](https://blog.web.nifty.com/engineer/2714)

### 38日目: 2020年11月8日（日）

**今日の進捗**: 

Reactのアプリ開発について。

- `create-react-app`を使った、Reactのアプリ開発手順について。
- と言ってもそんなに難しいわけでなく、単純に`create-react-app`がインストールされているコンテナ上で`npx create-react-app <任意のアプリ名>`を実行すればいい。必要なパッケージのインストールや、環境構築は`create-react-app`側が勝手にやってくれるので、しばらく放置しておけばいい。そこそこ時間がかかる。

```console
Success! Created my-app at /workspaces/work_docker_react/my-app
Inside that directory, you can run several commands:

  yarn start
    Starts the development server.

  yarn build
    Bundles the app into static files for production.

  yarn test
    Starts the test runner.

  yarn eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-app
  yarn start

Happy hacking!
```

- 処理が終わると上記のようなメッセージが表示される。ここでは、素直に`yarn start`してみる。

```console
cd my-app
yarn start
```

- コマンドを発行するには、一度`create-react-app`で作成したフォルダに移動が必要。

```console
Compiled successfully!

You can now view my-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.2:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
```

- 上記のメッセージが表示されたら、ブラウザでアクセスしてみる。

  ![](./2020-11-09-14-54-00.png)
  
- 上記のようなページが表示されたら成功。

**思ったこと**: 

- [Vue.js](https://jp.vuejs.org/index.html)の`vue-cli`のように、環境構築するツールがあるとだいぶ助かる。

**リンク**

1. [新しい React アプリを作る](https://ja.reactjs.org/docs/create-a-new-react-app.html)

### 39日目: 2020年11月9日（月）

**今日の進捗**: 

vscode上でdocker-composeする際の注意点について。

- vscodeでdocker-compose.ymlを使ってコンテナをビルドする際、Remoteの設定のため`.devcontainer`フォルダ内に**新しいdocker-compose.ymlを勝手に作成する**。
- しかも独特の設定を施した上でビルドするので、自分が作ったdocker-compose.ymlの設定と異なる状態でコンテナが立ち上がる。特に`volumes`の設定。

```dockerfile
FROM node:14.15-buster-slim

RUN npm install -g create-react-app

ADD . /home/workdir

# COPY ["package.json", "yarn.lock", ${PWD}]

COPY . /home/workdir
```

- Node.js用のコンテナをビルドするためのDockerfile。

```docker-compose[
version: '3'

services:
  node:
    build:
      context: ./
      dockerfile: Dockerfile
    volumes:
    - ./:/home/workdir
    ports:
    - "3000:3000"
```

- 上記のDockerfileをビルドするためのdocker-compose.yml。`volumes`の設定として、ホストのカレントフォルダをコンテナの`/home/workdir`にマウントしている。

  ![](2020-11-09-16-47-00.png)

- 上記のように、ファイルを作成しただけでは「.devcontainer」フォルダに影響はない。

  ![](2020-11-09-16-50-00.png)

- この状態で**vscodeからビルドを行う**。「Reopen in container」を選択すると、Dockerfileを使うのかdocker-compose.ymlを使うのか聞いてくる。ここではdocker-compose.ymlを利用するよう指定する。

  ![](2020-11-09-16-57-00.png)
  
- ビルド処理を実行すると、「.devcontainer」フォルダに**新しいdocker-compose.ymlが作成される**。

```docker-compose
version: '3'
services:
  # Update this to the name of the service you want to work with in your docker-compose.yml file
  node_sample:
    # If you want add a non-root user to your Dockerfile, you can use the "remoteUser"
    # property in devcontainer.json to cause VS Code its sub-processes (terminals, tasks, 
    # debugging) to execute as the user. Uncomment the next line if you want the entire 
    # container to run as this user instead. Note that, on Linux, you may need to 
    # ensure the UID and GID of the container user you create matches your local user. 
    # See https://aka.ms/vscode-remote/containers/non-root for details.
    #
    # user: vscode

    # Uncomment if you want to override the service's Dockerfile to one in the .devcontainer 
    # folder. Note that the path of the Dockerfile and context is relative to the *primary* 
    # docker-compose.yml file (the first in the devcontainer.json "dockerComposeFile"
    # array). The sample below assumes your primary file is in the root of your project.
    #
    # build:
    #   context: .
    #   dockerfile: .devcontainer/Dockerfile
    
    volumes:
      # Update this to wherever you want VS Code to mount the folder of your project
      - .:/workspace:cached

      # Uncomment the next line to use Docker from inside the container. See https://aka.ms/vscode-remote/samples/docker-from-docker-compose for details.
      # - /var/run/docker.sock:/var/run/docker.sock 

    # Uncomment the next four lines if you will use a ptrace-based debugger like C++, Go, and Rust.
    # cap_add:
    #   - SYS_PTRACE
    # security_opt:
    #   - seccomp:unconfined

    # Overrides default command so things don't shut down after the process ends.
    command: /bin/sh -c "while sleep 1000; do :; done"
 
```

- ほとんどがコメントアウトされているが、`volumes`の設定が**本来のdocker-compose.ymlで設定されたものと異なったフォルダで設定されてしまっている**。

```console
// If you want to run as a non-root user in the container, see .devcontainer/docker-compose.yml.
{
	"name": "Existing Docker Compose (Extend)",

	// Update the 'dockerComposeFile' list if you have more compose files or use different names.
	// The .devcontainer/docker-compose.yml file contains any overrides you need/want to make.
	"dockerComposeFile": [
		"..\\docker-compose.yml",
		"docker-compose.yml"
	],

	// The 'service' property is the name of the service for the container that VS Code should
	// use. Update this value and .devcontainer/docker-compose.yml to the real service name.
	"service": "node_sample",

	// The optional 'workspaceFolder' property is the path VS Code should open by default when
	// connected. This is typically a file mount in .devcontainer/docker-compose.yml
	"workspaceFolder": "/workspace",

	// Set *default* container specific settings.json values on container create.
	"settings": {
		"terminal.integrated.shell.linux": null
	},

	// Add the IDs of extensions you want installed when the container is created.
	"extensions": []

	// Use 'forwardPorts' to make a list of ports inside the container available locally.
	// "forwardPorts": [],

	// Uncomment the next line if you want start specific services in your Docker Compose config.
	// "runServices": [],

	// Uncomment the next line if you want to keep your containers running after VS Code shuts down.
	// "shutdownAction": "none",

	// Uncomment the next line to run commands after the container is created - for example installing curl.
	// "postCreateCommand": "apt-get update && apt-get install -y curl",

	// Uncomment to connect as a non-root user if you've added one. See https://aka.ms/vscode-remote/containers/non-root.
	// "remoteUser": "vscode"
}

```

- こっちは`devcontainer.json`の中身。特筆すべきは`docker-composeFile`の部分。本来のdocker-compose.ymlの他に**新しいdocker-compose.ymlも読めと書いてある**。

  ![](2020-11-09-17-04-00.png)

  ![](2020-11-09-17-05-00.png)

- この設定のため、本来設定しているフォルダとは異なる`workspace`フォルダの変更が、ホスト側に反映されてしまう。
- なお、新しいdocker-compose.ymlはフォルダ内のファイルを削除しても、ビルド処理ごとに再作成されてしまうため意味がない。よって、`workspace`フォルダの変更内容を反映させないためには、この「.devcontainer」内の設定ファイルについて、一度手直しする必要がある。
- ちなみにこの設定に影響を受けているせいか、vscodeのコンソールからコンテナに接続した場合`workspace`がカレントフォルダになるが、コマンドプロンプトなどで`docker exec -it`した場合は`/home/workdir`がカレントフォルダになる。

```docker-compose
    
    volumes:
      # Update this to wherever you want VS Code to mount the folder of your project
      - .:/home/workdir:cached

```

- とりあえず対処法は、まず新しいdocker-compose.ymlの`volumes`の設定を、本来マウントしたい先のフォルダに書き換える。

```console
	// The optional 'workspaceFolder' property is the path VS Code should open by default when
	// connected. This is typically a file mount in .devcontainer/docker-compose.yml
	"workspaceFolder": "/home/workdir",
```

- devcontainer.jsonも`workspaceFolder`の設定をマウントしたいフォルダに変更する。
- 本来は一度ここでリビルドするのだが、キャッシュでも残っているのか「`/workspace`がないんだけど？」というエラーが発生した。よって、リビルドする前に残存するコンテナを一度破棄して（`docker system prune`でもしておく）からリビルドする。

![](2020-11-10-09-20-00.png)

- `/workspace`が存在しなくなっている。

![](2020-11-10-09-33-00.png)

- コンテナの`/home/workdir`で作成したフォルダとファイルが、ローカル側にも反映されている。もちろん、コンテナ側でフォルダを削除すればローカル側のファイルも消える。

**思ったこと**: 

- お節介な・・・。vscodeは「必要に応じて設定内容は変えてね！」って言ってるけど、そもそもdocker-compose.ymlに書いてあるんだからお前が勝手に設定するなよ、とは言いたくなる。

**リンク**

1. [VS Code / Remote - Containers で docker-compose を試す](https://westa.io/@alclimb/remote-containers_docker-compose_sample)

### 40日目: 2020年11月10日（火）

**今日の進捗**: 

`create-react-app`の続き。

- コマンドを実行すると、アプリ開発の環境構築を始める。

```console
│  .gitignore
│  package.json
│  README.md
│  tree.txt
│  yarn.lock
│  
├─node_modules
│              
├─public
│      favicon.ico
│      index.html
│      logo192.png
│      logo512.png
│      manifest.json
│      robots.txt
│      
└─src
        App.css
        App.js
        App.test.js
        index.css
        index.js
        logo.svg
        reportWebVitals.js
        setupTests.js
```

- 環境構築が終わると、上記のような構成になっているはず。「node_modules」の中にはnpmのパッケージが格納されている。
- `yarn start`で開発サーバーを起動しブラウザで`localhost:3000`にアクセスすると、Reactの初期画面が表示される。

```javascript
import logo from './logo.svg';
import './App.css';

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <p> // ここから
          ほげふがぴよ。
        </p> // ここまで追加
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;

```

- 上記のとおり、JavaScriptのコード中にHTMLソースを記述する[JSX](https://ja.reactjs.org/docs/introducing-jsx.html)で記述されている。
- なお、JSXという名前で上記とは**別の静的型付け言語が存在した**ので注意。なんでも[DeNAが開発してた](https://ja.wikipedia.org/wiki/JSX)とかなんとか。
- ソースコードを変更し保存した**瞬間にブラウザで表示していたページが自動的に更新される**。

![](2020-11-11-09-57-00.png)

- ちなみにソースコードに問題がある場合、保存したタイミングで同様にコンパイルとレンダリング処理が実行されるが、上記のようなエラー画面を表示する。

----

Reactのチュートリアルに準じて開発してみる。なお、今回はCodepenなどのプレイグラウンドを利用せず、ローカルに準備したNode.jsのDocker環境下で`create-react-app`した状態で開始する。

- [Reactのチュートリアル](https://ja.reactjs.org/tutorial/tutorial.html)をやってみる。
- なんかフロントエンドのチュートリアルってTodoリスト作るイメージがあったけど、Reactのチュートリアルはマルバツゲームだった。
- とりあえず`create-react-app`した直後の状態で、`yarn start`して開発サーバーを立ち上げる。`localhost:3000`にブラウザからアクセスして、参照できることを確認しておく。確認ができたら、サーバーは一度終了してしまってよい。
- その後、srcフォルダ内にあるファイルを**すべて削除**する。
- チュートリアルの手順に従って、[ここ](https://codepen.io/gaearon/pen/oWWQNa?editors=0100)からCSSとJSのソース内容をコピペして、それぞれ「index.css」「index.js」という名前で保存する。
- 再度`yarn start`してサーバーを起動、`localhost:3000`にブラウザでアクセスする。

![](2020-11-11-10-17-00.png)

- 上記のように表示されれば成功。

----

スターターコードの中身を確認する。

- インポートしているのはReactのライブラリ。これは毎度記述する。
- クラスコンポーネントは3つ
- `Square`
- `Board`
- `Game`

**思ったこと**: 

- ホットリロード楽しいなー、コードの変更がすぐに反映されると作ってる感がある。

**リンク**

1. [チュートリアル：React の導入](https://ja.reactjs.org/tutorial/tutorial.html)

### 41日目: 2020年11月11日（水）

**今日の進捗**: 

Reactのコンポーネントにおけるタイプについて。

- Reactのコンポーネントには2種類ある。「クラスベース」と「ファンクショナルベース」の2つ。それぞれ「クラスコンポーネント」とか「関数コンポーネント（ファンクショナルコンポーネント）」とか言ったりする。そして現状（2020年11月時点で観測できるかぎり）では**関数コンポーネントを使うのがベストプラクティス**である風潮。

```javascript
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

- 上記のように、ECMAScript2015のクラスで記述するのがクラスコンポーネント。

```javascript
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

- 上記のように、`function()`で記述するのが関数コンポーネント。
- どちらも`props`というオブジェクトを引数で受け取って、その中の`name`プロパティを含んだReact要素を返す。
- これだけであれば、ぱっと見でのわかりやすさ、読みやすさでは関数コンポーネントの方が優れているように見える。
- クラスコンポーネントは関数コンポーネントと異なり、state（状態管理）とライフサイクルメソッドを**コンポーネント内で利用できる**。じゃあ、この機能があるからクラスコンポーネントの方がいいのか？という話になるのだが、実際のところでいうと**むしろコンポーネント単位に状態なんか持たせるな**という流れがある。これはなぜかというと、コンポーネント単位にそれぞれ状態管理を行う（「ステートフル」と言ったりする）と、可読性や保守性が低くなるだけでなく、「今どんな状態か？」を把握しにくくなるというデメリットがある。よって、なるべつ状態管理はコンポーネント単位で持ちたくない（「ステートレス」と言ったりする）というニーズがあった。ただし、関数コンポーネントでは状態管理ができなかったため、仕方なくクラスコンポーネントを使っているという側面があった。
- ところが、状態管理がクラスを記述せずに実装できる[Hooks](https://ja.reactjs.org/docs/hooks-intro.html)がReactに追加されたことで、「わざわざ読みにくくて保守性が低いクラスより、関数コンポーネントとHooks使った方がよくね？」という方向に傾いた。以降、Reactでは状態管理をHooksで行うのが主流になっていく。

**思ったこと**: 

- Vue.jsでもそうだったけど、状態管理ってネックなのよねぇ・・・。

**リンク**

1. [state とライフサイクル](https://ja.reactjs.org/docs/state-and-lifecycle.html)
1. [すべてのReact.js初心者が知っておくべき9つのポイント](https://qiita.com/ossan-engineer/items/3622e57ceb70c7f12295)
1. [【React】クラスコンポーネント /関数コンポーネントの違いと使い分け。なぜ 関数コンポーネントが好まれるのか。](https://qiita.com/shane/items/b936550820de9a88ad60)

### 42日目: 2020年11月12日（木）

**今日の進捗**: 

-

**思ったこと**: 

-

**リンク**

1. [hoge]()


### x日目: 2020年11月y日（z）

**今日の進捗**: 

-

**思ったこと**: 

-

**リンク**

1. [hoge]()
