# 100 Days Of Code - 学習ログ

## 2020年11月分

### 31日目: 2020年11月1日（日）

**今日の進捗**: 

JavaScriptの[分割代入](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)について。

- 配列の要素を個別の変数に格納したいときに、**一度にすべての要素を個別の変数に格納する**書き方。

```JavaScript
let hoge = [1, 'ham', 2];

// 1つ1つ指定する方法
let val1 = hoge[0];
let val2 = hoge[1];
let val3 = hoge[2];

console.log(val1);
console.log(val2);
console.log(val3);

// 分割代入する方法
let [foo, bar, baz] = hoge;

[foo, bar, baz].forEach(j => {
console.log(j);
});
```

- 配列`hoge`の要素を取り出し個別の変数に格納する場合、1つ1つ配列から添え字を使って取り出し、変数に格納する方法がまず考えられる。まぁ、これでもいいのだが「もうちょっとどうにかならないかね」ってときに使えるのが分割代入。
- 配列の要素ごとに変数を指定してカッコで囲うことで、どの要素をどの変数に格納するかを指定する。この方法なら一度に指定できる。これが分割代入。

```console
1
ham
2
1
ham
2
```

- どちらも同じ出力になる。

```JavaScript
let hoge = [1, 2, 3, 4, 5, 6, 7, 8, 9];

let [foo, , bar, ...baz] = hoge;

[foo, bar, baz].forEach(j => {
  console.log(j);
});
```

- 要らない要素が存在するなら、格納先の変数を記述しないことで読み捨てられる。上記の例でいうと2つ目の要素を捨てている。
- 「これ以降の要素は全部1つの変数にぶち込みたい」という場合は、`...変数名`と記述する。すると、残っている要素全部をその変数に格納する。

```console
1
3
[
4 ,
5 ,
6 ,
7 ,
8 ,
9
] 
```

- 2つ目の要素は捨てられて、4つ目以降の要素は1つの変数（`baz`のこと）にまとめて格納されていることがわかる。

```javascript
let hoge = {
  'foo': 1,
  'bar': 2,
  'baz': 3
};

let {foo, bar, baz} = hoge;

[foo, bar, baz].forEach(j => {
  console.log(j);
});

let {foo: val1, bar: val2, } = hoge;

[val1, val2].forEach(j => {
  console.log(j);
});
```

- オブジェクトに対しても同様の操作が可能。ただし、格納先の変数名は**オブジェクトのプロパティと同じ名前の変数でないとダメ**という縛りがある。
- 格納先の変数名を変更したい場合は、コロンで区切って新しい名称を記述する。

```console
1
2
3
1
2
```

- オブジェクトでも分割代入できた。

**思ったこと**: 

- JSってさぁ、なんかいつまで経っても「今まで見たことないような書き方」が出てきて**飽きない**ねぇ（比喩

**リンク**

1. [分割代入](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)
1. [JavaScriptの代入において時々現れる、括弧で囲まれた変数名は何なのか](https://sbfl.net/blog/2019/08/26/javascript-bracketed-variables/)

### 32日目: 2020年11月2日（月）

**今日の進捗**: 

p5.jsを使ってサインカーブを描画するメモ。

- p5.jsと三角関数を使って、サインカーブを描画する方法。とりあえず、後学のため解釈した順番で記述する。

```javascript
let x = 0;
let y = 0;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(2);
}

function draw(){
  background(255);
  point(x, y);
  
}
```

- 最初の基本形。点を一つ座標`(x,y)`に打つ。初期状態では`(0, 0)`になる。ただ、これだけでは当たり前だが画面上に動きはない。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
}

function draw(){
  background(255);
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  theta++;
  point(x, y);
}
```

- 画面に動きを出すため、`(0,0)`固定だった点の座標を時間経過とともに変更する。具体的には、`point(x, y)`としてx座標およびy座標を時間経過とともに変更させればいい。
- 座標を変更するためには三角関数を利用して角度（ここでは`theta`）とラジアン（ここでは`r`）の2つを利用する。[弧度法](https://ja.wikipedia.org/wiki/%E3%83%A9%E3%82%B8%E3%82%A2%E3%83%B3)というやつで、「円弧の長さlから角度ってわかるじゃん、xx度とか別に使わなくてもいいじゃん」という方法。

> 180度 = PI * rad

- 「xx度」で角度を表現する方法は[度数法](https://ja.wikipedia.org/wiki/%E5%BA%A6_(%E8%A7%92%E5%BA%A6))と言う。この方法でももちろんいいのだが、度数法は円を360等分することにより表現するせいで、角度が「123.45度」なんて小数で表現しなきゃいけないケースも出てくる。そうなるとプログラミング上面倒。同じ小数でも、角度より弧の長さの方がまだ使いやすい。よって、後述の極座標を用いた位置指定の方法がプログラミングの上では楽なので、たいていの場合度数法より弧度法を利用するケースの方が多い気がする。
- 1ラジアンは、半径が1の単位円なら円弧の長さlがそのままラジアンになる。弧の長さlが1なら1ラジアン、lが2なら2ラジアン・・・という感じ。
- 度数とラジアンの対応は、半径1の単位円において円周の長さは2PIなので、それがそのまま360度のラジアンになる。となると、その半分である180度のラジアンはPIになる。
- そして、角度がわかれば原点からの距離rを指定することで(x, y)の座標がわからなくても位置を特定できる。この角度thetaと距離rで位置を特定する方法を**極座標**という。なお、馴染み深い(x, y)の形式による位置特定の方法を直交座標という。
- さらに、極座標と直交座標は相互に変換が可能。

> (x, y) = (r * cos theta, r * sin theta)

- 上記のように三角関数を利用することで極座標と直交座標の変換を交互に変換できる。

> (1, 1) = (√2, PI / 4)

- 座標(1, 1)において極座標では(√2, PI / 4)で表現できる。ちなみに上記の例だと「却って面倒になってるじゃんか！」と見えるかもしれないが、これは直交座標側を(1, 1)というえらくわかりやすい座標にしているため。
- このあたりのことをやっているコードが`y = centerY + r * sin(radians(theta));`の箇所。この1文でy座標を時間経過とともに変更できる。ちなみに`centerY`はCanvasの高さの半分。つまり、中心を示している。
- このコードで、「左端で上下に移動する点」を描画できる。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
}

function draw(){
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  theta++;
  x++;
  point(x, y);
}
```

- 上記のコードで、サインカーブを描画をできる。
- 基本的には前のコードと同一だが、`draw()`関数内で、`background()`を削除しx座標を1加算する処理を加えた。これにより、時間経過とともに、カーブを描画をできる。
- `theta`に加算する数を増やすとカーブの間隔が狭くなる。逆に減らすと間隔が広くなる。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;
let centerX;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
  centerX = width / 2;
  
}

function draw(){
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  x = centerX + r * cos(radians(theta));
  point(x, y);
  theta += 1;

}
```

- 今度は時間経過で円を描く。
- x座標は`r * cos(radians(theta))`で求められる。この値とX軸の中心である`centerX`を加算することで、時間経過とともに円が描画される。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;
let centerX;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
  centerX = width / 2;
  
}

function draw(){
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  x = centerX + r * cos(radians(theta));
  point(x, y);
  theta += 1;

  if (theta > 360){
    theta = 0;
    r += 10;
  }
}
```

- 円を描画し終わったときの処理を追加した。
- 1つの円を描画し終わると、`r`に任意の値を加算して、更に円を描画する。ここでは10を加算して、一度描画した円の外側に新しい円を描画する。

**思ったこと**: 

- 三角関数なんてまともにやったの何年ぶりですかね・・・。こういうのって後になって役に立つんだよなぁ。

**リンク**

1. [hoge]()

### 33日目: 2020年11月3日（火）

**今日の進捗**: 

webアニメーションのメモ。

- [2020年中期のWebアニメーション実装の全容俯瞰](https://qiita.com/ryokkkke/items/42ae2a661d64036285d2)
- webにアニメーションを導入したい際に参照する。

----

[moment.js](https://momentjs.com/)が[メンテナンスモードに入っていた](https://mag.osdn.jp/20/09/18/113400)。新規機能の追加は行わず、バージョン3はなく（現在の最新版は2.29.1）、重要なセキュリティ問題には対処する・・・とのこと。

代替ライブラリはいろいろあるが、スター数が多めなのは下記の2つ。

- [day.js](https://github.com/iamkun/dayjs)
- [date-fns](https://github.com/date-fns/date-fns)

ぱっと見での判断だけど、day.jsの方が可読性が高そうな印象。

----

というわけで、[day.js](https://github.com/iamkun/dayjs)を試してみる。

```JavaScript
const hoge = '2020/4/1';

$ = (hoge) => {
  console.log(hoge);
}

$('--get today--');
$(dayjs().format());
$(dayjs()); // これはオブジェクト扱い

newDate = dayjs(hoge);
$(newDate); // これはオブジェクト扱い
$(newDate.format());

$('--get year--');
$(newDate.year());
$('--get month--');
$(newDate.month());
$('--get day--');
$(newDate.day());
$(newDate.date());
$('--another get date--');
$(dayjs().get('year'));
$(dayjs().get('month'));
$(dayjs().get('date'));
$(dayjs().get('hour'));
$(dayjs().get('minute'));
$(dayjs().get('second'));
$(dayjs().get('milisecond'));

$('--month comperison--');
date3 = new Date(2020, 8, 1);
date4 = new Date('01 Sep 2020');

$(date3.getTime() === date4.getTime());
```

- とりあえずざっくり公式のAPIを見ながら書いてみた。`dayjs()`で取得できるのは今日の日付なんだけど、**オブジェクト扱いになってしまう**ので`format()`を付けて表示すればいい。

```console
--get today--"
"2020-11-02T10:35:24+09:00"
Object {↔}
Object {↔}
"2020-04-01T00:00:00+09:00"
"--get year--"
2020
"--get month--"
3
"--get day--"
3
1
"--another get date--"
2020
10
2
10
35
24
```

- いいところは何もしなくても日本時間になっていること。注意点は相変わらず**月が0から始まること**。

----

JavaScriptの`keys()`について。

- `Object.keys()`じゃなくて`Array.prototype.keys()`の方。こっちは対象の配列が持つインデックスのキーを**イテレータで返す**。インデックスキーをそのまま返すわけではないので注意。

```JavaScript
let num = 10;

console.log(Array(num).keys());

for (const key of Array(num).keys()){
  console.log(key);
}

console.log(...Array(num).keys());
```

- 単純に`Array(num).keys()`とした場合、イテレータが返ってくる。それだけでは使えないが、for文のループを用いてインデックスキーの出力ができる。

```console
[object Array Iterator]
0
1
2
3
4
5
6
7
8
9
0 1 2 3 4 5 6 7 8 9
```

- 上記のように、単純に`Array.prototype.keys()`を実行するだけではイテレータが返ってくるだけだが、ループに入れたり`...`で要素を個別に取得することで内容を参照できる。

```JavaScript
let hoge = ['a', , 'c'];

$ = (fuga) => {
  console.log(fuga);
};

$(hoge);
$(Object.keys(hoge));
$([...hoge.keys()]);
```

- `Object.keys()`は、ある任意のオブジェクトが含むキーを出力するメソッドだったが、`Array.prototype.keys()`は対象の配列が持つインデックスキーをイテレータを出力する。この場合、元の配列が[疎な配列](https://qiita.com/t2kojima/items/0ddaba1f336bfcc1e8cd)である場合、挙動が異なる。

```console
["a", undefined, "c"]
["0", "2"]
[0, 1, 2]
```

- 存在しない要素を無視してインデックスキーを出力する`Object.keys()`に対し、要素の有無に関係なく配列の長さ分インデックスキーを返す`Array.prototype.keys()`。要素に対して何かしらの操作や処理を行う場合、`Object.keys()`を使うのが正解。

----

JavaScriptの「疎な配列」についてメモ。

- 「長さは3なのに要素の数は2」みたいな配列のこと。なんじゃそら。

```JavaScript
let hoge = [, , , ];

$ = (arg) => {
  console.log(arg);
}

$(hoge);
$(hoge.length);
```

- `let hoge = [, , , ];`という**要素を指定せずに配列の形式だけ指定する**ことが可能。Pythonでやるとエラーになる（大抵の言語仕様じゃエラーになるんじゃないか？）が、JSは可能。

```console
[undefined, undefined, undefined]
3
```

- 結果は`undefined`が3つ並ぶわりに、ちゃんと配列の長さを認識している。
- この「疎な配列」をどのように利用するかだが、狙って利用するようなケースがどれだけあるかと言われるとかなり悩ましい。
- ただ、何かしらの都合で配列中の要素が欠落して疎な配列になったときに、本来想定する挙動と異なる動作をすることが予測できる。その際に、知識があるかないかでエラー解消までの時間に差が出てくるのはよくある話。やっぱり知識は無駄にならない。

**思ったこと**: 

- [「震える」動作に特化したjsライブラリ](https://elrumordelaluz.github.io/csshake/)とかすげーニッチじゃん・・・って思ったけど、案外スター付いてて草。
- JSの月の扱い、ホントどうにかなりませんかね・・・いやもうね、コレホントにどうにかなりませんか。直感でわかりにくいのよ。
- [JavaScript Primer](https://jsprimer.net/)っていうサイトを見つけた。ECMAScript2015以降のJSで参考にできるオンライン上のテキストとしては、かなりいい出来なのではないか。

**リンク**

1. [2020年中期のWebアニメーション実装の全容俯瞰](https://qiita.com/ryokkkke/items/42ae2a661d64036285d2)
1. [Moment.jsがメンテナンスモードへーー新機能開発は行わず](https://mag.osdn.jp/20/09/18/113400)
1. [Day.jsで簡単に日付処理！](https://www.ultra-noob.com/blog/2020-05-11-Day.js%E3%81%A7%E7%B0%A1%E5%8D%98%E3%81%AB%E6%97%A5%E4%BB%98%E5%87%A6%E7%90%86%EF%BC%81/)
1. [Array.prototype.keys()](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/keys)
1. [疎な配列（Sparse Arrays）](https://qiita.com/t2kojima/items/0ddaba1f336bfcc1e8cd)

### 34日目: 2020年11月4日（水）

**今日の進捗**: 

p5.jsでの`vertex()`を使った描画について。

- `vertex()`は`startShape()`と`endShape()`の間において、指定された分の頂点を結んで点から多角形までを描画する。
- `vertex()`が記述された数が3つなら三角形だし、12個なら十二角形になる。ただし、座標を結んでいるだけなので正三角形にするにはそれなりの座標にしないといけないし、その計算はプログラミングするしかない。

```JavaScript
function setup(){
  createCanvas(800, 600);
  noFill();
  colorMode(HSB);
}

function draw(){
  background(0);
  stroke(255);
  beginShape();
  vertex(0, 0);
  vertex(100, 100);
  endShape();
}
```

- 上記は2点の座標を記述したもの。この場合、直線が描画される。x座標とy座標を明示的に指定しているところから、直交座標として指定していると言える。

```JavaScript
function setup(){
  createCanvas(800, 600);
  noFill();
  colorMode(HSB);
}

function draw(){
  background(0);
  strokeWeight(2);
  stroke(255);
  beginShape();
  
  let x, y;
  let splitX = 10;
  
  x = 100 * cos(radians(45));
  y = 100 * sin(radians(45));
  
  vertex(0, 0);
  vertex(x, y);
    
  endShape();
}
```

- 上記は弧度法を用いて座標を指定したもの。極座標として指定していると言える。直線の長さこそ異なるものの、直線が左上から45度の方向に伸びているのは同じ。直交座標と比べて、極座標はスタートから見て度の方向にどの長さで直線が伸びているかが、コードを読むとすぐわかる。

```JavaScript
function setup(){
  createCanvas(800, 600);
  noFill();
  colorMode(HSB);
}

function draw(){
  background(0);
  strokeWeight(2);
  stroke(255);
  beginShape();
  
  let x, y;
  let splitX = 10;
  
  [...Array(splitX).keys()].forEach(i => {
    x = i / (splitX - 1) * width;
    y = (height / (i + 1));
    vertex(x, y);
  })
    
  endShape();
}
```

- 上記では10本の直線を連続的に描画することで、対数関数のグラフのような線を描画している。

```javascript
let theta = 0;

function setup(){
  createCanvas(800, 600);
  noFill();
  colorMode(HSB);
}

function draw(){
  background(0);
  strokeWeight(2);
  stroke(255);
  beginShape();
  
  let x, y;
  let splitX = 10;
  
  x = 100 * cos(radians(theta)) + width / 2;
  y = 100 * sin(radians(theta)) + height / 2;
  
  vertex(width / 2, height / 2);
  vertex(x, y);
    
  endShape();
  
  theta++;
}
```

- 画面中心を原点とし、時間経過とともに直線が回転する。

**思ったこと**: 

-

**リンク**

1. [hoge]()

### x日目: 2020年11月y日（z）

**今日の進捗**: 



**思ったこと**: 

-

**リンク**

1. [hoge]()
