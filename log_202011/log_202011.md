# 100 Days Of Code - 学習ログ

## 2020年11月分

### 31日目: 2020年11月1日（日）

**今日の進捗**: 

JavaScriptの[分割代入](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)について。

- 配列の要素を個別の変数に格納したいときに、**一度にすべての要素を個別の変数に格納する**書き方。

```JavaScript
let hoge = [1, 'ham', 2];

// 1つ1つ指定する方法
let val1 = hoge[0];
let val2 = hoge[1];
let val3 = hoge[2];

console.log(val1);
console.log(val2);
console.log(val3);

// 分割代入する方法
let [foo, bar, baz] = hoge;

[foo, bar, baz].forEach(j => {
console.log(j);
});
```

- 配列`hoge`の要素を取り出し個別の変数に格納する場合、1つ1つ配列から添え字を使って取り出し、変数に格納する方法がまず考えられる。まぁ、これでもいいのだが「もうちょっとどうにかならないかね」ってときに使えるのが分割代入。
- 配列の要素ごとに変数を指定してカッコで囲うことで、どの要素をどの変数に格納するかを指定する。この方法なら一度に指定できる。これが分割代入。

```console
1
ham
2
1
ham
2
```

- どちらも同じ出力になる。

```JavaScript
let hoge = [1, 2, 3, 4, 5, 6, 7, 8, 9];

let [foo, , bar, ...baz] = hoge;

[foo, bar, baz].forEach(j => {
  console.log(j);
});
```

- 要らない要素が存在するなら、格納先の変数を記述しないことで読み捨てられる。上記の例でいうと2つ目の要素を捨てている。
- 「これ以降の要素は全部1つの変数にぶち込みたい」という場合は、`...変数名`と記述する。すると、残っている要素全部をその変数に格納する。

```console
1
3
[
4 ,
5 ,
6 ,
7 ,
8 ,
9
] 
```

- 2つ目の要素は捨てられて、4つ目以降の要素は1つの変数（`baz`のこと）にまとめて格納されていることがわかる。

```javascript
let hoge = {
  'foo': 1,
  'bar': 2,
  'baz': 3
};

let {foo, bar, baz} = hoge;

[foo, bar, baz].forEach(j => {
  console.log(j);
});

let {foo: val1, bar: val2, } = hoge;

[val1, val2].forEach(j => {
  console.log(j);
});
```

- オブジェクトに対しても同様の操作が可能。ただし、格納先の変数名は**オブジェクトのプロパティと同じ名前の変数でないとダメ**という縛りがある。
- 格納先の変数名を変更したい場合は、コロンで区切って新しい名称を記述する。

```console
1
2
3
1
2
```

- オブジェクトでも分割代入できた。

**思ったこと**: 

- JSってさぁ、なんかいつまで経っても「今まで見たことないような書き方」が出てきて**飽きない**ねぇ（比喩

**リンク**

1. [分割代入](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)
1. [JavaScriptの代入において時々現れる、括弧で囲まれた変数名は何なのか](https://sbfl.net/blog/2019/08/26/javascript-bracketed-variables/)

### 32日目: 2020年11月2日（月）

**今日の進捗**: 

p5.jsを使ってサインカーブを描画するメモ。

- p5.jsと三角関数を使って、サインカーブを描画する方法。とりあえず、後学のため解釈した順番で記述する。

```javascript
let x = 0;
let y = 0;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(2);
}

function draw(){
  background(255);
  point(x, y);
  
}
```

- 最初の基本形。点を一つ座標`(x,y)`に打つ。初期状態では`(0, 0)`になる。ただ、これだけでは当たり前だが画面上に動きはない。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
}

function draw(){
  background(255);
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  theta++;
  point(x, y);
}
```

- 画面に動きを出すため、`(0,0)`固定だった点の座標を時間経過とともに変更する。具体的には、`point(x, y)`としてx座標およびy座標を時間経過とともに変更させればいい。
- 座標を変更するためには三角関数を利用して角度（ここでは`theta`）とラジアン（ここでは`r`）の2つを利用する。[弧度法](https://ja.wikipedia.org/wiki/%E3%83%A9%E3%82%B8%E3%82%A2%E3%83%B3)というやつで、「円弧の長さlから角度ってわかるじゃん、xx度とか別に使わなくてもいいじゃん」という方法。

> 180度 = PI * rad

- 「xx度」で角度を表現する方法は[度数法](https://ja.wikipedia.org/wiki/%E5%BA%A6_(%E8%A7%92%E5%BA%A6))と言う。この方法でももちろんいいのだが、度数法は円を360等分することにより表現するせいで、角度が「123.45度」なんて小数で表現しなきゃいけないケースも出てくる。そうなるとプログラミング上面倒。同じ小数でも、角度より弧の長さの方がまだ使いやすい。よって、後述の極座標を用いた位置指定の方法がプログラミングの上では楽なので、たいていの場合度数法より弧度法を利用するケースの方が多い気がする。
- 1ラジアンは、半径が1の単位円なら円弧の長さlがそのままラジアンになる。弧の長さlが1なら1ラジアン、lが2なら2ラジアン・・・という感じ。
- 度数とラジアンの対応は、半径1の単位円において円周の長さは2PIなので、それがそのまま360度のラジアンになる。となると、その半分である180度のラジアンはPIになる。
- そして、角度がわかれば原点からの距離rを指定することで(x, y)の座標がわからなくても位置を特定できる。この角度thetaと距離rで位置を特定する方法を**極座標**という。なお、馴染み深い(x, y)の形式による位置特定の方法を直交座標という。
- さらに、極座標と直交座標は相互に変換が可能。

> (x, y) = (r * cos theta, r * sin theta)

- 上記のように三角関数を利用することで極座標と直交座標の変換を交互に変換できる。

> (1, 1) = (√2, PI / 4)

- 座標(1, 1)において極座標では(√2, PI / 4)で表現できる。ちなみに上記の例だと「却って面倒になってるじゃんか！」と見えるかもしれないが、これは直交座標側を(1, 1)というえらくわかりやすい座標にしているため。
- このあたりのことをやっているコードが`y = centerY + r * sin(radians(theta));`の箇所。この1文でy座標を時間経過とともに変更できる。ちなみに`centerY`はCanvasの高さの半分。つまり、中心を示している。
- このコードで、「左端で上下に移動する点」を描画できる。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
}

function draw(){
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  theta++;
  x++;
  point(x, y);
}
```

- 上記のコードで、サインカーブを描画をできる。
- 基本的には前のコードと同一だが、`draw()`関数内で、`background()`を削除しx座標を1加算する処理を加えた。これにより、時間経過とともに、カーブを描画をできる。
- `theta`に加算する数を増やすとカーブの間隔が狭くなる。逆に減らすと間隔が広くなる。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;
let centerX;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
  centerX = width / 2;
  
}

function draw(){
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  x = centerX + r * cos(radians(theta));
  point(x, y);
  theta += 1;

}
```

- 今度は時間経過で円を描く。
- x座標は`r * cos(radians(theta))`で求められる。この値とX軸の中心である`centerX`を加算することで、時間経過とともに円が描画される。

```javascript
let x = 0;
let y = 0;
let theta = 0;
let r = 100;
let centerY;
let centerX;

function setup(){
  createCanvas(800, 600);
  noFill();
  strokeWeight(1);
  centerY = height / 2;
  centerX = width / 2;
  
}

function draw(){
  line(0, centerY, width, centerY);
  
  y = centerY + r * sin(radians(theta));
  x = centerX + r * cos(radians(theta));
  point(x, y);
  theta += 1;

  if (theta > 360){
    theta = 0;
    r += 10;
  }
}
```

- 円を描画し終わったときの処理を追加した。
- 1つの円を描画し終わると、`r`に任意の値を加算して、更に円を描画する。ここでは10を加算して、一度描画した円の外側に新しい円を描画する。

**思ったこと**: 

- 三角関数なんてまともにやったの何年ぶりですかね・・・。こういうのって後になって役に立つんだよなぁ。

**リンク**

1. [hoge]()

### x日目: 2020年11月y日（z）

**今日の進捗**: 



**思ったこと**: 

-

**リンク**

1. [hoge]()


**思ったこと**: 

- 

**リンク**

1. [hoge]()

### x日目: 2020年11月y日（z）

**今日の進捗**: 



**思ったこと**: 

-

**リンク**

1. [hoge]()
