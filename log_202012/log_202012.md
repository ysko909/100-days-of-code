# 100 Days Of Code - 学習ログ

## 2020年12月分

### 61日目: 2020年12月1日（火）

**今日の進捗**: 

JavaScriptのクラスについて。

- JavaScriptのクラスはES6での実装。JSのクラスは実際は[特別な関数](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes)で、JavaやPythonなどのクラスの概念とは多少異なる。
- クラスの定義には**クラス式**と**クラス宣言**の2パターンがある。ES6以降でいわゆるクラスを定義する際に用いられるのは、クラス宣言だと思われる。
- JSはクラス式での記述を名前なしで書ける。**関数と同様で名前なしのオブジェクトとしてクラスが作成できる**のが特色で、これも「特別な関数」に繋がる仕様。

```javascriptclass Hoge{
  constructor(a, b){
    this.a = a;
    this.b = b;
  }

  foo(arg){
    console.log('Hoge is ' + arg);
  }
}

class Fuga extends Hoge{
  constructor(a, b, c){
    super(a, b);
    this.c = c;
    this.d = c ** 2;
  }

  bar(arg){
    console.log('Fuga is ' + arg);
  }
}

class Piyo extends Hoge{
  constructor(a, b){
    super(a, b);
  }

  foo(arg){
    console.log('piyo is ' + arg)
  }
}

class Hogera extends Hoge{
  constructor(){
    super(9, 99);
    this.f = 999;
  }
  
  foofoo(){
    super.foo('foobarbaz');
  }
  
  barbar(arg){
    super.foo(arg);
  }
}

let hoge = new Hoge(1, 2);
console.log(hoge.a, hoge.b);
hoge.foo('foo');

let fuga = new Fuga(3, 4, 5);
console.log(fuga.a, fuga.b, fuga.c, fuga.d);
fuga.foo('foo');
fuga.bar('bar');

let piyo = new Piyo(6, 7);
console.log(piyo.a, piyo.b);
piyo.foo('foo');

let hogera = new Hogera();
console.log(hogera.a, hogera.b, hogera.f);
hogera.foofoo();
hogera.barbar('barbar');
```

- 上記のように`class 名前 {}`で記述するタイプがクラス宣言。
- `extend`を用いることでクラスの継承が可能。

```console
1 2
"Hoge is foo"
3 4 5 25
"Hoge is foo"
"Fuga is bar"
6 7
"piyo is foo"
9 99 999
"Hoge is foobarbaz"
"Hoge is barbar"
```

- 継承しつつメソッドを改変することで、メソッドのオーバーライドも可能。

```javascript
let Hoge = class{
  constructor(a, b){
    this.a = a;
    this.b = b;
  }

  foo(arg){
    console.log('hoge is ' + arg);
  }
}

let Fuga = class Hogehoge {
  constructor(a, b, c){
    this.aa = a;
    this.bb = b;
    this.cc = c;
  }

  foo(arg){
    console.log('fuga is ' + arg);
  }
}

let hoge = new Hoge(1, 2);
console.log(hoge.a, hoge.b);
hoge.foo('foo');

console.log(Hoge.name);

let fuga = new Fuga(3, 4, 5);
console.log(fuga.aa, fuga.bb, fuga.cc);
fuga.foo('foo');

console.log(Fuga.name);
```

- `=`を使って任意の変数に代入する形式で宣言するのがクラス式。
- 1つ目の宣言では匿名で、2つ目の宣言では名前付きでクラスを定義している（`class`の後が名前）。ここの名前は**インスタンス生成時には関係がない**。なぜなら、`new`する際は変数で宣言した方の名前を利用する（ここでは`Hoge`あるいは`Fuga`）ため、クラスの代入時に記述していた名前はこれと言った効力を持たない。じゃあ何のためにあるかというと、`name`プロパティで特定の名前を取得する必要がある場合に、名前を記述する。逆に言えば、その必要がないなら匿名クラスで宣言してしまえばいい、ということになる。

```console
12
hoge is foo
Hoge
345
fuga is foo
Hogehoge
```

- 匿名で代入した場合と、名前をつけてから代入した場合で、`name`プロパティを表示してみたときの挙動が異なっていることがわかる。

----

p5.jsでクリックされたときの処理を記述する方法。

- 「マウスがクリックされている間」と「マウスがクリックされた瞬間」で異なるコードを記述する必要がある。

```javascript
let color = 255;

function setup(){
  createCanvas(800, 600);
  fill(color);
}

function draw(){
  background(0);
  
  fill(color);
  
  if (mouseIsPressed){
    rect(mouseX, mouseY, 100, 100);
  }
}

function mousePressed(){
  color = random(200);
}
```

- システム変数である`mousePressed`と関数である`mousePressed()`は、マウスのクリックに反応する点では共通しているが、`mousePressed`は「クリックしている間」、`mousePressed()`は「クリックされた瞬間」で、それぞれ役割が異なる。
- 上記だとマウスがクリックされた瞬間にランダムで値を取得、描画処理の中でその取得された値を用いて長方形を塗りつぶす。クリックされた瞬間に値が変化するが、クリックされている間は長方形を描画するだけなので、塗りつぶす色が変化するようなことはない。

**思ったこと**: 

- p5.jsで任意のオブジェクトを複数定義する必要がある場合、このクラスを宣言しインスタンスを生成する。生成したインスタンスそれぞれについて、クラスのプロパティを更新するようなメソッドを実行してやれば、複数のオブジェクトを操作できる。

**リンク**

1. [クラス](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes)
1. [JavaScriptのclass](https://qiita.com/jooex/items/981824f9fb494b448a08#%E7%B6%99%E6%89%BF)
1. [p5.jsで楽しもうマウス&カーソルインタラクション](http://blog.livedoor.jp/reona396/archives/55826829.html)

### 62日目: 2020年12月2日（水）

**今日の進捗**: 

`create-react-app`は、いつの間にかnpmのグローバルインストールをサポートしなくなっていた。

- npmによりグローバルインストールして`create-react-app`を単体で実行するのではなく、`npx create-react-app app-name`とnpmのタスクランナーを使って`create-react-app`する方式に変わっている。

```console
You are running create-react-app 4.0.0, which is behind the latest release (4.0.1).
We no longer support global installation of Create React App.
```

- [ここ](https://stackoverflow.com/questions/64963796/create-react-app-is-not-working-since-version-4-0-1)と同様に、npmでグローバルインストールしている環境（dockerコンテナ内）において`npx create-react-app app-name`しようとしたところ上記のエラーが表示された。
- メッセージにはグローバルインストールされてる`create-react-app`は削除しろ、とご丁寧にもコマンド付きでメッセージが表示される。
- 上記を実行したのがdockerコンテナ内だったため、コマンドで`create-react-app`を削除するのではなく、Dockerfile内に記述していたnpmによるグローバルインストールするコマンド部分を削除した。
- ちなみに、じゃあReactのアプリを新規作成するにはどうすればいいかというと、単純にNode.js環境において任意のフォルダで`npx create-react-app app-name`を実行すればいい。Node.jsがあればnpmもnpxもあるだろうから、作成のためのプログラム（`create-react-app`のこと）は**実行時点の最新版を使ってアプリ作成をしようね**ということらしい。

----

[Jest](https://jestjs.io/ja/)の[Getting Started](https://jestjs.io/docs/ja/getting-started)をやってみる。

- まずはNode.js環境において`npx create-react-app work-jest`を実行して開発環境を構築する。この時点でJestも同梱されているので、個別にインストールする必要はない。

```console
yarn add --dev react-test-renderer
```

- 次に`react-test-renderer`をインストールする。`react-test-renderer`とはFacebook謹製のテストライブラリ。
- 他にはAirbnb製の[enzyme](https://github.com/airbnb/enzyme)あたりが有名らしいが、[React Hooksと相性が悪い](https://kumaaaaa.com/react-testing/)らしいので今回は利用しなかった。
- 他にenzymeと似たような使い方ができる[react-testing-library](https://github.com/testing-library/react-testing-library)というのもある。`create-react-app`した時点でインストールされ利用できるようになり、`create-react-app`直後の`src`フォルダを見ると`App.test.js`という名前でテスト用スクリプトが作成されている。
- [Reactのチュートリアル](https://ja.reactjs.org/tutorial/tutorial.html)と同様に、`src`フォルダ内のファイルは全て削除しておく。

```javascript
function sum(a, b) {
    return a + b;
}

module.exports = sum;
```

- `src`フォルダに`sum.js`という名前でJSファイルを作成する。内容は上記の通り。


```javascript
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});
```

- 同じフォルダに`sum.test.js`という名前でファイルを作る。内容は上記の通り。
- [Getting Started](https://jestjs.io/docs/ja/getting-started)では上記の2ファイルを作成したらpackage.jsonを変更しろと書いてあるが、`create-react-app`経由で開発環境を作成した場合は不要。
- コンソールで`yarn test`を実行する。

```console
PASS  src/sum.test.js (10.242 s)
  ✓ adds 1 + 2 to equal 3 (2 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        14.312 s
Ran all test suites.

Watch Usage
 › Press f to run only failed tests.
 › Press o to only run tests related to changed files.
 › Press q to quit watch mode.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press Enter to trigger a test run.
```

- しばらく放置していると、上記のような結果が表示される。「PASS」となっていることから、テストが正常に終了したことがわかる。ちなみにコンソールに戻るにはqを押す。
- 上記のように、コンポーネントを作成し、そのコンポーネント用のテストファイルを作成し、テストを実行しその結果を確認する。この一連の流れをJestで行える。今回はコンポーネントが返す結果がテストで予想される結果と一致しているか、`expect`と`toBe`を使って確認した。つまり、`expect`でコンポーネントを任意の値で実行し、その結果が`toBe`で指定した結果と一致していることを確認している。

```javascript
function sum(a, b) {
    return a - b; // +から-に変更
}

module.exports = sum;
```

- ここで`sum.js`を上記のように変更する。加算を減算に変更している。この状態で、先ほどと同様にテストを実行してみる。

```console
FAIL  src/sum.test.js (9.161 s)
  ✕ adds 1 + 2 to equal 3 (3 ms)

  ● adds 1 + 2 to equal 3

    expect(received).toBe(expected) // Object.is equality

    Expected: 3
    Received: -1

      2 | 
      3 | test('adds 1 + 2 to equal 3', () => {
    > 4 |     expect(sum(1, 2)).toBe(3);
        |                       ^
      5 | });

      at Object.<anonymous> (src/sum.test.js:4:23)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        14.087 s
Ran all test suites.

Watch Usage
 › Press f to run only failed tests.
 › Press o to only run tests related to changed files.
 › Press q to quit watch mode.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press Enter to trigger a test run.
```

- 実行したテストが、テストスクリプトのどの部分で失敗したかの結果が表示される。
- qを押すとテストプログラムが終了するが、ここで何も押さないまま`sum.js`を元の加算に修正し保存すると**再テストが自動的に実行される**。

```console
 PASS  src/sum.test.js
  ✓ adds 1 + 2 to equal 3 (2 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        8.05 s, estimated 10 s
Ran all test suites.

Watch Usage: Press w to show more.
```

- テスト結果が「PASS」に戻って、正常にテストが終了したことがわかる。

**思ったこと**: 

- 去年に変わっていたとか全然気付かなかった・・・。

**リンク**

1. [Quick Start](https://create-react-app.dev/docs/getting-started/#quick-start)
1. [Reactの初期テンプレが作成出来なかった時の対処メモ](https://qiita.com/10mi8o/items/ec12ccf25270626a948b)
1. [新しい React アプリを作る](https://ja.reactjs.org/docs/create-a-new-react-app.html)

### 63日目: 2020年12月3日（木）

**今日の進捗**: 

Jestのインテリセンスを有効にする方法について。

- vscodeのデフォルト設定だと、Jestのテスト用コードを書こうと思ってもインテリセンスが働かない。有効にするには`jsconfig.json`ファイルを用意する必要がある。

```json
{
    "typeAcquisition": {
        "include": [
            "jest"
        ]
    }
}
```

- 上記の内容を記述した`jsconfig.json`を、JSファイルがあるフォルダに格納する。
- たとえばサーバー側コードとクライアント側コードが別に存在する場合は、それぞれを別フォルダに格納し上記のjsonファイルを**それぞれのフォルダに格納する**。
- 一度ファイルを作成したら、vscodeを再起動しなくてもJestのインテリセンスが有効になる。

----

JavaScriptで数値判定を行う`Number.isInteger()`について。

- `Number.isInteger()`は整数に対してtrueを返す。小数などはfalseになるので注意。

```javascript
let $ =(arg)=>{
  console.log(arg);
}

let hoge = (arg)=>{
  if(Number.isInteger(arg)){
    $(arg + ' is number.');
  } else {
    $('Not number: ' + arg + ' type: ' + typeof(arg));
  }
}

hoge(0);
hoge(1);
hoge(0.1);
hoge(-0);
hoge(-1);
hoge(-0.1);
hoge('0');
hoge('1');
hoge('str');
hoge(0x1);
hoge(0b1);
hoge('0x1');
hoge(true);
hoge(false);
hoge(NaN);
hoge(undefined);

```

- 0x1は16進数、0b1は2進数でそれぞれ1を表す。

```console
0 is number.
1 is number.
Not number: 0.1 type: number
0 is number.
-1 is number.
Not number: -0.1 type: number
Not number: 0 type: string
Not number: 1 type: string
Not number: str type: string
1 is number.
1 is number.
Not number: 0x1 type: string
Not number: true type: boolean
Not number: false type: boolean
Not number: NaN type: number
Not number: undefined type: undefined
```

- `0`が整数とかならまぁ妥当だけど、`-0`なんかも整数扱い。負の数も同様に整数扱い。小数は整数じゃないのでfalse。
- `true`や`false`なんかは順当に整数じゃないのでfalse。

----

Jestでのユニットテストをチュートリアル以外のテーマでやってみる。今回は[FizzBuzzでテストするこれ](https://qiita.com/jintz/items/61af86a12b53b24ef121)がちょうどよかったので参考に。

- その前に補足。前回はテスト対象のJSファイルとテスト用のJSファイルを同一のフォルダに格納していたが、今回以降テスト用JSファイルは`__test__`という名前のフォルダに格納する。
- FizzBuzzの機能をJestを使ってテストする。連番を入力にした際、入力が3の倍数のときは「Fizz」、5の倍数のときは「Buzz」、3の倍数かつ5の倍数（つまり15の倍数）のときは「FizzBuzz」を表示する。それ以外の入力は入力された値をそのまま表示する。
- 正の整数以外が入力された場合はエラーにする（文字列はダメだし、負の数もダメ。小数もダメ。）。

- 第1段階として、メインの実行プログラムと入力値を判別して値を返すプログラムをそれぞれ作成する。

```javascript
const calFizzBuzz = require('./fizzbuzz');

const app = () => {
    [...Array(100).keys()].forEach(num => {
        console.log(calFizzBuzz(num));
    });
}
```

- メインは0から99までの数値でそれぞれFizzBuzzの判定を行う。

```javascript
function fizzbuzz(num) {

    let result = num;

    if (num > 0) {
        if (num % 15 === 0) {
            result = 'FizzBuzz';
        } else if (num % 3 === 0) {
            result = 'Fizz';
        } else if (num % 5 === 0) {
            result = 'Buzz';
        }
    }

    return result;

}

module.exports = fizzbuzz;
```

- FizzBuzzの判定は別だしのスクリプトにて行う。その際、`module.exports`を記述して、どの関数を他ファイルで参照可能にするか指定しておく。

```javascript
const fizzbuzz = require('../fizzbuzz');

test('unit test for fizzbuzz', () => {
    expect(fizzbuzz(6)).toBe('Fizz');
    expect(fizzbuzz(10)).toBe('Buzz');
    expect(fizzbuzz(30)).toBe('FizzBuzz');
    expect(fizzbuzz(1)).toBe(1);
    expect(fizzbuzz(1111)).toBe(1111);
});

test('unit error test for fizzbuzz', () => {
    expect(fizzbuzz('hoge')).toThrow(RangeError);
    expect(fizzbuzz(0)).toThrow(RangeError);
    expect(fizzbuzz(-1)).toThrow(RangeError);
}) 
```

- テスト用スクリプトの内容は上記の通り。正常ケースと異常ケースに分けており、異常ケースでは`toThrow()`を使って、関数が例外を投げるかテストしている。

```console
 FAIL  src/__test__/fizzbuzz.test.js (10.506 s)
  ✓ unit test for fizzbuzz (2 ms)
  ✕ unit error test for fizzbuzz (2 ms)

  ● unit error test for fizzbuzz

    expect(received).toThrow(expected)

    Matcher error: received value must be a function

    Received has type:  string
    Received has value: "hoge"

      10 | 
      11 | test('unit error test for fizzbuzz', () => {
    > 12 |     expect(fizzbuzz('hoge')).toThrow(RangeError);
         |                              ^
      13 |     expect(fizzbuzz(0)).toThrow(RangeError);
      14 |     expect(fizzbuzz(-1)).toThrow(RangeError);
      15 | })

      at Object.<anonymous> (src/__test__/fizzbuzz.test.js:12:30)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 passed, 2 total
Snapshots:   0 total
Time:        16.474 s
Ran all test suites.
```

- Failとなった。まぁそれはその通りで、テスト対象のコードで例外処理をしていないから。

```javascript
const fizzbuzz = num => {
    let result;

    if (isIntoRange(num)) {
        result = num;
    } else {
        throw new RangeError('invalid arg');
    }

    if (num % 15 === 0) {
        result = 'FizzBuzz';
    } else if (num % 3 === 0) {
        result = 'Fizz';
    } else if (num % 5 === 0) {
        result = 'Buzz';
    }

    return result;
}

const isIntoRange = num => {
    if ((Number.isInteger(num)) && (num > 0)) {
        return true;
    } else {
        return false;
    }
}

module.exports = fizzbuzz;
```

- じゃあ・・・というわけでFizzBuzzの内容を書き直し、範囲内かどうかを判定するコードを追加した。また、範囲外の場合はエラーをthrowするコードも同様に追加した。
- 保存すると`yarn test`を実行したままにしていれば、自動的にテストしてくれる。

```console
 FAIL  src/__test__/fizzbuzz.test.js (9.677 s)
  ✓ unit test for fizzbuzz (3 ms)
  ✕ unit error test for fizzbuzz

  ● unit error test for fizzbuzz

    RangeError: invalid arg

       5 |         result = num;
       6 |     } else {
    >  7 |         throw new RangeError("invalid arg");
         |               ^
       8 |     }
       9 | 
      10 |     if (num % 15 === 0) {

      at fizzbuzz (src/fizzbuzz.js:7:15)
      at Object.<anonymous> (src/__test__/fizzbuzz.test.js:12:12)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 passed, 2 total
Snapshots:   0 total
Time:        14.616 s
Ran all test suites.
```

- **エラーになったじゃねーか**。これはテストコードの書き方に問題がある。

```javascript
test('unit error test for fizzbuzz', () => {
    expect(fizzbuzz('hoge')).toThrow(RangeError);
    expect(fizzbuzz(0)).toThrow(RangeError);
    expect(fizzbuzz(-1)).toThrow(RangeError);
}) 
```

- 上記のように`expect(関数())`と書いてしまうと、**expectが実行される前に引数に指定されている関数が実行されてしまう**。
- 引数に`fizzbuzz('hoge')`を指定している場合、`expect()`という関数を実行する前に実行してしまう（`hoge(fuga(piyo()))`と記述されていれば`piyo()`＞`fuga()`＞`hoge()`の順に実行されるのと同等）。そのため、`expect().toThrow()`による実行結果評価の前に`fizzbuzz('hoge')`において例外が発生してしまい処理が異常終了するため、実行結果評価が行えず上記のようなエラーになる。
- じゃあどうすればいいかというと、**関数を渡す**ことで回避できる。

```javascript
test('unit error test for fizzbuzz', () => {
    expect(() => fizzbuzz('hoge')).toThrow(RangeError);
    expect(() => fizzbuzz(0)).toThrow(RangeError);
    expect(() => fizzbuzz(-1)).toThrow(RangeError);
}) 
```

- 上記のようにテスト用スクリプトに記述する。

```console
 PASS  src/__test__/fizzbuzz.test.js (9.612 s)
  ✓ unit test for fizzbuzz (3 ms)
  ✓ unit error test for fizzbuzz (22 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        14.609 s
Ran all test suites.
```

- エラーケースを含め、正常終了した。

```javascript
test('unit error test for fizzbuzz', () => {

    const hoge = () => fizzbuzz('hoge');

    expect(hoge()).toThrow(RangeError);
}) 
```

- ちなみに上記のように関数を任意の変数に格納しておく場合、`expect()`の引数に指定した変数に**カッコをつけてはいけない**。

```console
 FAIL  src/__test__/fizzbuzz.test.js (10.972 s)
  ✓ unit test for fizzbuzz (3 ms)
  ✕ unit error test for fizzbuzz (1 ms)

  ● unit error test for fizzbuzz

    RangeError: invalid arg

       5 |         result = num;
       6 |     } else {
    >  7 |         throw new RangeError("invalid arg");
         |               ^
       8 |     }
       9 | 
      10 |     if (num % 15 === 0) {

      at fizzbuzz (src/fizzbuzz.js:7:15)
      at hoge (src/__test__/fizzbuzz.test.js:13:24)
      at Object.<anonymous> (src/__test__/fizzbuzz.test.js:15:12)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 passed, 2 total
Snapshots:   0 total
Time:        16.755 s
Ran all test suites.
```

- このようにエラーになる。これも先ほどの現象と同様で、`expect()`における評価が行われる前に`hoge()`が実行されてしまい、その時点で例外エラーとして異常終了してしまうため。

```javascript
test('unit error test for fizzbuzz', () => {

    const hoge = () => fizzbuzz('hoge');

    expect(hoge).toThrow(RangeError);
}) 
```

- 回避策は**引数の変数にカッコを付けず値として渡す**こと。

```console
 PASS  src/__test__/fizzbuzz.test.js (9.51 s)
  ✓ unit test for fizzbuzz (3 ms)
  ✓ unit error test for fizzbuzz (21 ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        14.479 s
Ran all test suites.
```

- カッコを付けないと、上記のようにエラーケース含めて正常終了した。

**思ったこと**: 

- 本当にファイルを作っただけでインテリセンスが有効になった。スゲー。
- エラーケースのテストには関数を渡さないとダメなの、[オフィシャルだと事前に関数を準備してる](https://jestjs.io/docs/ja/expect#tothrowerror)のに気付かなかった。しかもちゃんと注意書きまでされていたのに、ググってやっとわかった。

> 注意： 関数の中のコードはラップしてください。そうしなければエラーが補足されず、アサーションは失敗します。

- つまり`expect()`は[高階関数](https://www.javadrive.jp/javascript/function/index16.html)なんだな。

**リンク**

1. [jsconfig.json](https://code.visualstudio.com/docs/languages/jsconfig)
1. [Intellisense for Jest not working in VS code](https://stackoverflow.com/questions/57874114/intellisense-for-jest-not-working-in-vs-code)
1. [toThrow](https://jestjs.io/docs/ja/expect#tothrowerror)
1. [Jestでの例外処理テストtoThrow](https://teratail.com/questions/259723)

### 64日目: 2020年12月4日（金）

**今日の進捗**: 

Jestのテストカバレッジについて。

- テスト実行時にオプションを付けることで、テストカバレッジをHTML形式で出力できる。

```console
$ yarn test --covarage
 PASS  src/__test__/fizzbuzz.test.js (10.093 s)
  ✓ unit test for fizzbuzz (3 ms)
  ✓ unit error test for fizzbuzz (23 ms)

-------------|---------|----------|---------|---------|-------------------
| File          | % Stmts   | % Branch   | % Funcs   | % Lines   | Uncovered Line #s   |
| ------------- | --------- | ---------- | --------- | --------- | ------------------- |
| All files     | 76.19     | 100        | 50        | 76.19     |
| fizzbuzz.js   | 100       | 100        | 100       | 100       |
| index.js      | 0         | 100        | 0         | 0         | 1-9                 |
| ------------- | --------- | ---------- | --------- | --------- | ------------------- |
Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        24.715 s
Ran all test suites.
```

- 上記のように`--coverage`を指定すると、出力結果に各ファイルごとのカバレッジが表示される。
- さらに、「coverage」という名前のフォルダが生成され、カバレッジがHTML形式で保存される。

![pic](2020-12-01-15-56-00.png)

- それぞれのJSファイルについて結果を確認できる。

![pic](2020-12-01-16-03-00.png)

![pic](2020-12-01-16-04-00.png)

- 赤くなっている部分が「ここテストしてねぇぞ」という意味。

----

Jestを使ってテストをする際に、値のテストをするための「マッチャー（Matcher）」が用意されている。

- 値をテストする際に**等価であるか否か**を判定する`toBe()`。

```javascript
test('unit test for fizzbuzz', () => {
    expect(fizzbuzz(6)).toBe('Fizz');
    expect(fizzbuzz(10)).toBe('Buzz');
    expect(fizzbuzz(30)).toBe('FizzBuzz');
    expect(fizzbuzz(1)).toBe(1);
    expect(fizzbuzz(1111)).toBe(1111);
});
```

- これらは`fizzbuzz()`という関数において、その戻り値が`toBe()`に設定した値と一致することをテストする。

```javascript
test('object assignment', () => {
  const data = {one: 1};
  data['two'] = 2;
  expect(data).toEqual({one: 1, two: 2});
});
```

- オブジェクトの要素について値のテストする場合は、`toEqual()`を利用する。
- `toEqual()`は、オブジェクトまたは配列のすべての要素について、再帰的にチェックする。

```javascript
test('adding positive numbers is not zero', () => {
  for (let a = 1; a < 10; a++) {
    for (let b = 1; b < 10; b++) {
      expect(a + b).not.toBe(0);
    }
  }
});
```

- `not`を付与することで、計算結果が`toBe()`で指定した値**ではない**テストを行うことも可能。

----

- 真偽値や`undefined`、`null`などについてテストする場合は、それぞれ別個にマッチャーが用意されている。

```javascript
test('null', () => {
  const n = null;
  expect(n).toBeNull();
  expect(n).toBeDefined();
  expect(n).not.toBeUndefined();
  expect(n).not.toBeTruthy();
  expect(n).toBeFalsy();
});

test('zero', () => {
  const z = 0;
  expect(z).not.toBeNull();
  expect(z).toBeDefined();
  expect(z).not.toBeUndefined();
  expect(z).not.toBeTruthy();
  expect(z).toBeFalsy();
});
```

- こいつらも`not`が使える。それぞれのマッチャーの解説は[ここ](https://jestjs.io/docs/ja/using-matchers)を見た方が早い。

----

- 値について一致ではなく大小を確認したい場合は`toBe()`だとできないので、別のマッチャーを利用する。

```javascript
test('two plus two', () => {
  const value = 2 + 2;
  expect(value).toBeGreaterThan(3);
  expect(value).toBeGreaterThanOrEqual(3.5);
  expect(value).toBeLessThan(5);
  expect(value).toBeLessThanOrEqual(4.5);

  // toBe and toEqual are equivalent for numbers
  expect(value).toBe(4);
  expect(value).toEqual(4);
});
```

- 名前を見ればわかるが一応。
    - toBeGreaterThan()：ある値より大きい
    - toBeGreaterThanOrEqual()：ある値以上
    - toBeLessThan()：ある値未満
    - toBeLessThanOrEqual()：ある値以下

```javascript
test('adding floating point numbers', () => {
  const value = 0.1 + 0.2;
  //expect(value).toBe(0.3);         このように書くと、丸め込み誤差が原因で期待通りに動作しない
  expect(value).toBeCloseTo(0.3); // これならば正しく動く
});
```

- 丸め誤差を意識しないといけない場合は、上記のように`toBeCloseTo()`を利用する。

----

文字列を等価ではなく**正規表現でチェックしたい**場合は`toMatch()`を利用する。

```javascript
test('there is no I in team', () => {
  expect('team').not.toMatch(/I/);
});

test('but there is a "stop" in Christoph', () => {
  expect('Christoph').toMatch(/stop/);
});
```

- `toMatch()`の引数に正規表現を記述することで、その正規表現を満たすか否かをテストする。

----

- 配列や反復可能なオブジェクトの要素に、特定の値が含まれているかをテストするには`toContain()`を利用する。

```javascript
const shoppingList = [
  'diapers',
  'kleenex',
  'trash bags',
  'paper towels',
  'beer',
];

test('the shopping list has beer on it', () => {
  expect(shoppingList).toContain('beer');
  expect(new Set(shoppingList)).toContain('beer');
});
```

----

投げられる例外を確認するには`toThrow()`を利用する。そして`toThrow()`を利用する場合、`expect()`に指定する関数はアロー関数などで**ラップする必要がある**。

```javascript
function compileAndroidCode() {
  throw new Error('you are using the wrong JDK');
}

test('compiling android goes as expected', () => {
  expect(() => compileAndroidCode()).toThrow();
  expect(() => compileAndroidCode()).toThrow(Error);

  // You can also use the exact error message or a regexp
  expect(() => compileAndroidCode()).toThrow('you are using the wrong JDK');
  expect(() => compileAndroidCode()).toThrow(/JDK/);
});
```

- `toThrow()`の引数は、文字列やエラーの種類など様々な値を設定可能。

----

非同期処理のJestによるテストについてメモ。

```javascript
const returnMessage = () => {
    let promise = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('hoge');
        }, 1000);
    });

    return promise;
};

module.exports = {
    returnMessage: returnMessage,
};
```

- 上記のような、resolveしたときに文字列`hoge`を返す関数についてテストを行う場合を考える。

```javascript
const fizzbuzz = require('../fizzbuzz');

test('test for asynchronous function', () => {
    return fizzbuzz.returnMessage().then(data => {
        expect(data).not.toBe('fuga');
        expect(data).toBe('hoge');
        expect(data).not.toMatch(/.*ug.*/);
        expect(data).toMatch(/.*og.*/);
    });
})
```

- `return`を**必ず記述した状態で**目的の関数を実行する。結果は`then()`のハンドラー関数によりPromiseが返されるので、その返ってきた値の内容をチェックする。
- 今回は`hoge`という文字列がresolveで返ってくる仕様なので、結果が`fuga`でない・`hoge`である、あるいは正規表現の条件を満たす・満たさないなどのテストを実行している。
- ここで`return`を記述しないと、テスト目的の関数が実行されresolveが返ってきてコールバック関数が実行される**前に**テストが終了してしまう。すると本来**FAILになるケースでもPASSしてしまう**ため、テストを実行する意味がなくなってしまう。

> もしこの return 文を省略した場合、あなたのテストは、fetchDataがresolveされpromiseが返ってくる前に実行され、then() 内のコールバックが実行される前に完了してしまいます。

**思ったこと**: 

- ちなみにカバレッジとは網羅率のこと。

**リンク**

1. [Jest CLI Options](https://jestjs.io/docs/ja/cli#--coverageboolean)
1. [jestでテストカバレッジを見る](https://qiita.com/monisoi/items/44931e36c5f7b1f4e683)
1. [Promise.prototype.then()](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)
1. [Testing Asynchronous Code](https://jestjs.io/docs/ja/asynchronous#promises)
1. [jest で非同期関数をテストするときの注意点](https://qiita.com/ef81sp/items/178ed17982b13535ad59)
1. [Get return value from setTimeout [duplicate]](https://stackoverflow.com/questions/24928846/get-return-value-from-settimeout)

### 65日目: 2020年12月5日（土）

**今日の進捗**: 

JavaScriptのオブジェクトリテラルを関数の引数に指定する方法について。

- オブジェクトリテラルを関数の引数に指定することができる。

```javascript
const $ = (arg) =>{
  console.log(arg);
}

const hoge = ({foo, bar}) =>{
  $('hoge: ' + foo);
  $('hoge: ' + bar);
};

hoge({foo:'eggs', bar:'ham'});
hoge({bar:'ham', foo:'eggs'});
```

- 上記のように`({foo, bar})`と引数にオブジェクトリテラル記法で指定することで、関数実行時に引数の順番を意識することなく値の設定が可能。

```console
hoge: eggs
hoge: ham
hoge: eggs
hoge: ham
```

- 記述方法は異なるが、実行結果は一致している。

----

オブジェクトリテラルとは、オブジェクトを定義する記述方法。オブジェクト初期化子とか言ったりするらしい。

- オブジェクトを記述する際に書いている、波かっこで囲う書き方のこと。

```javascript
let hoge = {
  'foo': 1,
  'bar': 2,
  'baz': 3,
};

let fuga = {};
```

- 上記のように、プロパティと値が設定してあってもいいし、空のオブジェクトであっても問題ない。

```javascript
let piyo = new Object(); // let piyo = {};と同等
```

- 上記のようにJavaScriptのObjectクラスを用いてnewする方法もあるが、波かっこで囲うほうが早いのでわざわざ書くことはあまりない。

----

JSの分割代入について。

- JSのオブジェクトについて分割代入をする場合、分割代入**される側にイコールが存在する書き方がある**。

```javascript
let {hoge=1, fuga=2} = {hoge: 3};

console.log(hoge);
console.log(fuga);
```

- もうパッと見で何やってるかさっぱりわからないが、とりあえずコンソールへの出力結果はどうなるか。

```console
3
2
```

- プロパティ名の一致する`hoge`のみ値が書き換わり、代入元（右辺のオブジェクト）に存在しなかった`fuga`はもともと設定されていた値が出力される。
- オブジェクトの分割代入において、オブジェクトから取り出した値が`undefined`であった場合の**規定値を左辺側で定義できる**。今回はそれぞれ1と2を規定値として記述したが、値の取り出し元である右辺のオブジェクトからは`hoge`プロパティの値のみが取り出せたため、`hoge`の値が右辺のものになり、`fuga`の値は規定値を採用した、ということ。

```javascript
const func = ({hoge=1, fuga=2} = {}) => {
  console.log(hoge);
  console.log(fuga);
};

func();
func({hoge:99});
func({hoge:100, fuga:200});
```

- この特性を利用して、関数の引数に上記の分割代入を適用する方法がある。

```console
1
2
99
2
100
200
```

オブジェクトによる引数の指定が1つもない場合、任意のプロパティのみ指定した場合、全てのプロパティを指定した場合でそれぞれ挙動が異なる。このように指定される可能性がある引数が可変である想定の場合、オブジェクトとして渡した方がよい場合がある。

```javascript
const func = ({hoge=1, fuga=2}) => { // これはダメ
  console.log(hoge);
  console.log(fuga);
};

func(); // ここでエラー
func({hoge:99});
func({hoge:100, fuga:200});
```

- なお、上記のように`={}`を削除してしまうと、関数実行時にエラーになってしまう。

```javascript
const func = ({hoge=1, fuga=2}) => {
  console.log(hoge);
  console.log(fuga);
};

func({hoge:99});
func({hoge:100, fuga:200});
```

- `func()`を削除して最低1つでも引数を指定すれば一応実行は可能。

```console
99
2
100
200
```

**思ったこと**: 

- 分割代入の規定値設定って、パッと見で解釈しにくいが引数のオブジェクトにどんなものが入ってくるかわからないケースなんかだと割と使えそうな感じがして悩ましい。
- `={}`を削除するとエラーになるけど、引数なしでの関数実行をやめれば（必ず何かしら引数を指定すれば）実行可能になるのも、まぁなんというかなんだかなぁという感じ。

**リンク**

1. [javascript 関数の引数にオブジェクトリテラルを使用する](https://mebee.info/2020/11/09/post-21564/)
1. [アロー関数(Arrow function)の書き方色々](https://ushumpei.hatenablog.com/entry/2016/09/06/235336)
1. [オブジェクト初期化子](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Object_initializer)
1. [オブジェクトリテラルの記述方法](https://www.javadrive.jp/javascript/object/index2.html#section1)
1. [分割代入](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

### 66日目: 2020年12月6日（日）

**今日の進捗**: 

Dockerで複数のコンテナを同時に立ち上げる際の注意について。

- docker-compose.ymlの`ports`で既存のコンテナと同じポートを指定している場合、「もうそのポート使用されてるぞ」とエラーになる。

```console
Bind for 0.0.0.0:3000 failed: port is already allocated
ERROR: Encountered errors while bringing up the project.
```

- 別のReact用コンテナのdocker-compose.ymlで同一のポートを指定し先にコンテナを起動していたため、すでのそのポートが利用されており新規に使えなかったため上記のエラーが表示された。
- 回避方法としては、別のポートを指定すればいい。たとえば`4000:4000`に変更して問題なければ変更してしまえばいい・・・のだが、Reactは`yarn start`を実行するとデフォルト設定ではポート3000を利用する。docker-compose.yml側でコンテナが利用するポートを3000から変更していた場合、`yarn start`する際に何も指定しないとデフォルトの3000ポートでアプリケーションを起動してしまう。コンテナが準備しているポートとコンテナ内で実行されているアプリケーションが利用するポートが異なるため、ブラウザなどからアクセスできなくなってしまう。よって、アプリケーションが利用するポートをdocker-compose.ymlに記述してあるポートと一致させる必要がある。

```console
PORT=4000 yarn start
```

-そのためには環境変数として`yarn start`時にポートを指定する方法がある。

```console
export PORT=4000
```

- あるいは、他のアプリケーションに影響がなければそのコンテナの環境変数に登録してしまってもいい。
- さらにプロジェクトのルートフォルダ（docker-compose.ymlがいるのと同じフォルダ）に`.env`ファイルを作成し、その中にポートを指定する方法もある。これについては[リンク](https://qiita.com/urouro_net/items/dd7166f9728d08bc933b)を参照。ちなみに、`.env`ファイルを作成した場合は、そのファイルを参照するようにdocker-compose.ymlを修正する必要がある。

```console
version: '3'

services:
  node:
    build:
      context: ./
      dockerfile: Dockerfile
    volumes:
    - ./:/home/workdir
    ports:
    - "4000:4000"
    env_file: .env # こんな感じ
```

- なお、`.env`ファイルはこういう名前のファイルを作成する。`任意の名前.env`というような拡張子ではなく、`.env`という名前の設定ファイルとして作成すること。

----

JavaScriptでの三項演算子について。

- JSで唯一、3つのオペランドを取るのが三項演算子。

```javascript
let hoge = true;

let fuga = hoge ? 'hoge':'fuga';

let piyo = hoge ? arg=>console.log('piyo: ' + arg): ()=>console.log('ng');

console.log(hoge);
console.log(fuga);
piyo('foo');

const ham = (arg) => arg ? 'egg': 'spam';

console.log(ham(1));
```

- `condition ? exprIfTrue : exprIfFalse`が構文で、要はif文をもっと簡略化した感じ。ただJSならではなのは戻り値に関数を仕込めることか。

```console
true
hoge
piyo: foo
egg
```

- 実行結果はこんな感じ。

```javascript
let hoge = false;

let fuga = hoge ? 'hoge':'fuga';

let piyo = hoge ? arg=>console.log('piyo: ' + arg): ()=>console.log('ng');

console.log(hoge);
console.log(fuga);
piyo('foo');

const ham = (arg) => arg ? 'egg': 'spam';

console.log(ham(0));
```

- ちなみに、`false`のパターンは上記の通り。

```console
false
fuga
ng
spam
```

- 実行結果はこんな感じ。

```javascript
const greeting = (name) => {
  person = name ? name : 'stranger';
  return 'Hi, ' + person + '.';
}

console.log(greeting('Chris'));
console.log(greeting());
```

- その他の使い方に、入力値がNullだった場合の条件分岐が考えられる。

```console
Hi, Chris.
Hi, stranger.
```

- 上記では、名前が入力されていればそのまま出力し、名前がなかった場合（Nullだった場合「）は任意の文字列を付与する。

```javascript
let hoge = (foo, bar, baz) => {
  return foo ? 'hoge' : bar ? 'fuga' : baz ? 'piyo' : 'nothing';
}

console.log(hoge());

[...Array(2).keys()].forEach(i => {
  [...Array(2).keys()].forEach(j => {
    [...Array(2).keys()].forEach(k => {
      console.log('i:' + i + ', j:' + j + ', k:' + k);
      console.log(hoge(i, j, k));
    })
  })
})
```

- `if ... else if ... else`のように、条件を連結することもできる。

```console
nothing
i:0, j:0, k:0
nothing
i:0, j:0, k:1
piyo
i:0, j:1, k:0
fuga
i:0, j:1, k:1
fuga
i:1, j:0, k:0
hoge
i:1, j:0, k:1
hoge
i:1, j:1, k:0
hoge
i:1, j:1, k:1
hoge
```

- 実行結果はこんな感じ。

----

p5.jsでガウスぼかしをかける。

```javascript
let img;
let blurVal = 0;

function preload(){
  img = loadImage('https://upload.wikimedia.org/wikipedia/commons/d/dc/Colorful_neon_street_signs_in_Kabukich%C5%8D%2C_Shinjuku%2C_Tokyo.jpg');
}

function setup(){
  createCanvas(800, 600);
  
}

function draw(){
  background(0);
  
  image(img, 0, 0, width, height);
  filter(BLUR, blurVal);
  
  blurVal += 1;
}
```

- `filter(BLUR, value);`で簡単にガウスぼかしを適用できる。値を大きくすればぼかし具合も大きくなる。

**思ったこと**: 

- 相変わらず見慣れたころに、また新しい記述方法を見かけるのでJSってホントに飽きないなー（棒

**リンク**

1. [create-react-app の npm start のポート番号を変える](https://qiita.com/urouro_net/items/dd7166f9728d08bc933b)
1. [Environment variables in Compose](https://docs.docker.com/compose/environment-variables/#the-env-file)
1. [条件 (三項) 演算子](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)
1. [【p5.js】画像にガウスぼかしをかける](https://note.com/ttttttttttt/n/n0d93f04db8b7)

### 67日目: 2020年12月7日（月）

**今日の進捗**: 

[pandas](https://pandas.pydata.org/)で欠損値を含む行や列を削除する方法。

- pandasの`dropna()`を使って、欠損値を含む行や列を削除する。

```python
>>> import pandas as pd
>>> import io
>>> s = '''a,b,c
... 1,2,3
... foo,bar,
... ,,
... ham,,spam
... hoge,fuga,piyo
... ,5,6
... ,,
... '''
>>> df = pd.read_csv(io.StringIO(s))
>>> df
      a     b     c
0     1     2     3
1   foo   bar   NaN
2   NaN   NaN   NaN
3   ham   NaN  spam
4  hoge  fuga  piyo
5   NaN     5     6
6   NaN   NaN   NaN
```

- データフレームの内容はこんな感じ。

```python
>>> df.dropna()
      a     b     c
0     1     2     3
4  hoge  fuga  piyo
```

- 欠損値が1つ以上含まれている行を削除するときは、何も引数に指定しない。正確には`how='any'`という指定がデフォルトの引数に指定されている。

```python
>>> df['d'] = 99
>>> df
      a     b     c   d
0     1     2     3  99
1   foo   bar   NaN  99
2   NaN   NaN   NaN  99
3   ham   NaN  spam  99
4  hoge  fuga  piyo  99
5   NaN     5     6  99
6   NaN   NaN   NaN  99
>>> df.dropna(axis=1)
    d
0  99
1  99
2  99
3  99
4  99
5  99
6  99
```

- 欠損値が1つ以上含まれている列を削除するときは、`axis=1`とする。

```python
>>> df = df.drop('d', axis=1)
>>> df
      a     b     c
0     1     2     3
1   foo   bar   NaN
2   NaN   NaN   NaN
3   ham   NaN  spam
4  hoge  fuga  piyo
5   NaN     5     6
6   NaN   NaN   NaN
>>> df.dropna(how='all')
      a     b     c
0     1     2     3
1   foo   bar   NaN
3   ham   NaN  spam
4  hoge  fuga  piyo
5   NaN     5     6
```

- 全ての項目列が欠損値である行を削除する場合は、引数に`how='all'`と指定する。

```python
>>> df['d'] = pd.Series()
<stdin>:1: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
>>> df
      a     b     c   d
0     1     2     3 NaN
1   foo   bar   NaN NaN
2   NaN   NaN   NaN NaN
3   ham   NaN  spam NaN
4  hoge  fuga  piyo NaN
5   NaN     5     6 NaN
6   NaN   NaN   NaN NaN
>>> df.dropna(how='all', axis=1)
      a     b     c
0     1     2     3
1   foo   bar   NaN
2   NaN   NaN   NaN
3   ham   NaN  spam
4  hoge  fuga  piyo
5   NaN     5     6
6   NaN   NaN   NaN
```

- 全ての行が欠損値である列を削除する場合は、引数に`how='all', axis=1`を指定する。

```python
>>> df = df.drop('d', axis=1)
>>> df
      a     b     c
0     1     2     3
1   foo   bar   NaN
2   NaN   NaN   NaN
3   ham   NaN  spam
4  hoge  fuga  piyo
5   NaN     5     6
6   NaN   NaN   NaN
>>> df['d'] = pd.Series()
<stdin>:1: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
>>> df
      a     b     c   d
0     1     2     3 NaN
1   foo   bar   NaN NaN
2   NaN   NaN   NaN NaN
3   ham   NaN  spam NaN
4  hoge  fuga  piyo NaN
5   NaN     5     6 NaN
6   NaN   NaN   NaN NaN
>>> import numpy as np
>>> df['e'] = [10, 11, np.nan, 13, 14, 15, 16]
>>> df
      a     b     c   d     e
0     1     2     3 NaN  10.0
1   foo   bar   NaN NaN  11.0
2   NaN   NaN   NaN NaN   NaN
3   ham   NaN  spam NaN  13.0
4  hoge  fuga  piyo NaN  14.0
5   NaN     5     6 NaN  15.0
6   NaN   NaN   NaN NaN  16.0
>>> df.dropna(how='all').dropna(how='all', axis=1)
      a     b     c     e
0     1     2     3  10.0
1   foo   bar   NaN  11.0
3   ham   NaN  spam  13.0
4  hoge  fuga  piyo  14.0
5   NaN     5     6  15.0
6   NaN   NaN   NaN  16.0
```

- 欠損値しかない行と列を1度に削除したい場合、チェーンさせればいい。

**思ったこと**: 

- しばらくやってないと忘れる・・・。特に`axis=1`の記述忘れて「そんな名前の列はねぇよ」と怒られる・・・。

**リンク**

1. [pandasで欠損値NaNを除外（削除）・置換（穴埋め）・抽出](https://note.nkmk.me/python-pandas-nan-dropna-fillna/)


### 68日目: 2020年12月8日（火）

**今日の進捗**: 

データフレームに欠損値`NaN`を追加する方法について。

- 使いそうなシチュエーションがあまり思い浮かばないが、必要になったときに困るのでメモ。
- 欠損値`NaN`は、CSVを読み込んだデータフレームに含まれたりもするが、自分で追加もできる。ここでは「`NaN`しかない列」「`NaN`を含む列」それぞれの追加方法をメモしておく。

```python
>>> import pandas as pd
>>> import numpy as np
>>> import io
>>> s = '''a,b,c
... 1,2,3
... ,4,
... 5,,6
... ,,
... '''
>>> df = pd.read_csv(io.StringIO(s))
>>> df
     a    b    c
0  1.0  2.0  3.0
1  NaN  4.0  NaN
2  5.0  NaN  6.0
3  NaN  NaN  NaN
```

- このデータフレームに列を追加してみる。

```python
>>> df['d'] = np.nan
>>> df
     a    b    c   d
0  1.0  2.0  3.0 NaN
1  NaN  4.0  NaN NaN
2  5.0  NaN  6.0 NaN
3  NaN  NaN  NaN NaN
```

- numpyを利用してスカラー値で追加する方法。指定された列に含まれるデータは全て`NaN`になる。

```python
>>> df['e'] = pd.Series()
<stdin>:1: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
>>> df
     a    b    c   d   e
0  1.0  2.0  3.0 NaN NaN
1  NaN  4.0  NaN NaN NaN
2  5.0  NaN  6.0 NaN NaN
3  NaN  NaN  NaN NaN NaN
```

- pandasのSeriesを利用する方法。空っぽのSeriesを渡してやることで、全データが`NaN`の列を追加する。

```python
>>> df['f'] = [7, 8, 9, np.nan]
>>> df
     a    b    c   d   e    f
0  1.0  2.0  3.0 NaN NaN  7.0
1  NaN  4.0  NaN NaN NaN  8.0
2  5.0  NaN  6.0 NaN NaN  9.0
3  NaN  NaN  NaN NaN NaN  NaN
>>> 
```

- 配列を使って、任意の行だけ`NaN`にする方法。ここではnumpyを利用して明示的に`NaN`を格納している。

```python
>>> df.loc['4'] = np.nan
>>> df
     a    b    c   d   e    f
0  1.0  2.0  3.0 NaN NaN  7.0
1  NaN  4.0  NaN NaN NaN  8.0
2  5.0  NaN  6.0 NaN NaN  9.0
3  NaN  NaN  NaN NaN NaN  NaN
4  NaN  NaN  NaN NaN NaN  NaN
>>> df.loc['5'] = pd.Series()
<stdin>:1: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
>>> df
     a    b    c   d   e    f
0  1.0  2.0  3.0 NaN NaN  7.0
1  NaN  4.0  NaN NaN NaN  8.0
2  5.0  NaN  6.0 NaN NaN  9.0
3  NaN  NaN  NaN NaN NaN  NaN
4  NaN  NaN  NaN NaN NaN  NaN
5  NaN  NaN  NaN NaN NaN  NaN
>>> df.loc['6'] = ['foo', np.nan, 'bar', np.nan, 'baz', np.nan]
>>> df
     a    b    c   d    e    f
0    1  2.0    3 NaN  NaN  7.0
1  NaN  4.0  NaN NaN  NaN  8.0
2    5  NaN    6 NaN  NaN  9.0
3  NaN  NaN  NaN NaN  NaN  NaN
4  NaN  NaN  NaN NaN  NaN  NaN
5  NaN  NaN  NaN NaN  NaN  NaN
6  foo  NaN  bar NaN  baz  NaN
>>> 
```

- 列だけではなく、行に対しても同様の方法で追加できる。

**思ったこと**: 

- 正直、いつこんな方法使うんだろうって感じだけど、知らないのと知ってるけど使わないのは違うからね。

**リンク**

1. [Pandas DataFrame で空の列を作成する方法](https://www.delftstack.com/ja/howto/python-pandas/how-to-create-an-empty-column-in-pandas-dataframe/)
1. [pandas.DataFrameに列や行を追加（assign, appendなど）](https://note.nkmk.me/python-pandas-assign-append/)

### 69日目: 2020年12月9日（水）

**今日の進捗**: 

pandasのデータフレームにおいて、正規表現でデータ抽出を行う方法について。

- 正規表現でデータ抽出を行う場合、`str.match()`を利用する。

```python
>>> import pandas as pd
>>> import io
>>> s = '''a,b,c
... hoge,fuga,piyo
... foo,bar,baz
... ham,eggs,spam
... '''
>>> df = pd.read_csv(io.StringIO(s))
>>> df
      a     b     c
0  hoge  fuga  piyo
1   foo   bar   baz
2   ham  eggs  spam
>>> df['a'].str.match('.o.*')
0     True
1     True
2    False
Name: a, dtype: bool
>>> df[df['a'].str.match('.o.*')]
      a     b     c
0  hoge  fuga  piyo
1   foo   bar   baz
>>> df['a'].str.match('(?!.o.*)')
0    False
1    False
2     True
Name: a, dtype: bool
>>> df[df['a'].str.match('(?!.o.*)')]
     a     b     c
2  ham  eggs  spam
>>> df['b'].str.match('.*g')
0     True
1    False
2     True
Name: b, dtype: bool
>>> df['b'].str.match('(?!.*g)')
0    False
1     True
2    False
Name: b, dtype: bool
>>> 
```

- `df.str.match()`だけ実行した場合は、その条件に合致しているかの真偽値のみが返ってくる。
- 返ってきた真偽値をもとに、ブールインデックスで行の抽出が可能になる。

```python
>>> df.query("a.str.match('.o.*')")
      a     b     c
0  hoge  fuga  piyo
1   foo   bar   baz
>>> df.query("a.str.match('(?!.o.*)')")
     a     b     c
2  ham  eggs  spam
```

- ブールインデックスだとちょっと可読性に欠ける場合、`query()`を用いた方法で行の抽出が可能。書き方は`df.query("列名.str.match(正規表現)")`とする。`query()`の引数は必ず文字列で渡す。

----

Pythonで正規表現を用いる際の「～ではない」を表現する。

- 「hogeという文字列を**含まない**」というような、notを正規表現で用いる際には**否定的先読み**を使う。
- 否定的先読みとは、`(?!条件)`のように「?!」を丸カッコで囲って表現する方法。なお、「?!」という並びで書かないといけない。

```python
>>> df['a'].str.match('.o.*')
0     True
1     True
2    False
Name: a, dtype: bool
>>> df['a'].str.match('(?!.o.*)')
0    False
1    False
2     True
```

- 結果の真偽値が逆転している（notが付与されたのと同じ）のがわかる。

**思ったこと**: 

- ブールインデックスの書き方より`query()`の方が読みやすいので、そっちに慣れたい。

**リンク**

1. [pandas.Series.str.match](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.match.html)
1. [pandas.DataFrame.query](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.query.html)
1. [pandas.DataFrameの行を条件で抽出するquery](https://note.nkmk.me/python-pandas-query/)
1. [re --- 正規表現操作](https://docs.python.org/ja/3/library/re.html)
1. [正規表現で文字列を含まない、否定の記述](https://uxmilk.jp/50674)

### x日目: 2020年12月y日（z）

**今日の進捗**: 

-

**思ったこと**: 

-

**リンク**

1. [hoge]()

