# 100 Days Of Code - 学習ログ

## 2020年10月分

### 1日目: 2020年10月1日（木）

**今日の進捗**: 

JavaScriptでのアップロード機能の実装について。

- JavaScriptでローカルの画像をアップロードし、canvas上に表示するプログラムを作成。HTMLとJavaScriptなので、PlayCode上にて仮実装。
- [参考元URL](https://www.tam-tam.co.jp/tipsnote/javascript/post13538.html)では、画像ファイルであれば受け付けていたが、ここではPNGのみを対象とした。`type.match()`の対象を、`image/png`とするとPNGに限定できる。
- もともとの仕様では画像がアップロードされた場合のみcanvasの更新を行っていたため、対象外のファイルがアップロードされた場合は、過去にアップロードされたデータや子要素が画面に残り続ける。それを解消するため、PNG以外がアップロードされた場合は一度canvasを削除する仕様とした。また、同様にダウンロード用URLが存在する場合は子要素から削除する。

**思ったこと**: 

- PlayCodeは特定のボタンを押すと、ソースのフォーマットを行ってくれる。その際、アロー関数に引数がある場合は**かっこを外す**（引数がない場合はかっこを省略できないので、そのまま残る）。「挙動は一緒なんだから、文字は少ない方がいいでしょ」という判断なのかもしれないが、個人的にはまだアロー関数に慣れてないので、あんまり省略されると混乱する。
- アロー関数ではかっこだけでなく、1行で記述する場合は波かっこまで省略可能なので、ぱっと見の可読性に難があって割と混乱しがち。
- どっちがいいかはともかくとして、「どっちでも読める」程度には慣れたい。

**リンク** 

1. [File APIとCanvasでローカルの画像をアップロード→加工→ダウンロードする](https://www.tam-tam.co.jp/tipsnote/javascript/post13538.html)
1. [ソースのgist](https://gist.github.com/ysko909/0f14a71c5604ded658e3a4f8fb837e6d)

### 2日目: 2020年10月2日（金）

**今日の進捗**: 

Pythonでのnumpy利用時のエラー調査。

- Pythonで`numpy.poly1d()`を使った回帰線の描画がコケた。具体的には、エラーにならず描画されないという感じ。
- 原因は`numpy.poly1d()`で渡したデータ群に欠損値があったこと。欠損値が存在している場合、エラーなどのリアクションをせず、ただ描画しないらしい。
- ちなみに何が欠損していたかというと、標準偏差を格納していた列の値の数データが欠損。理由は、標準偏差を算出する元のデータが1件しか存在しなかったため、「標準偏差を算出できないよ」と欠損していた。
- `dropna(subset=['col_name', 'col_name2'])`で欠損値を削除したデータを、`numpy.poly1d()`に渡して事なきを得た。

**思ったこと**: 

- エラーメッセージなんかのリアクションがないのに、望んだ結果が出力されないってのが一番困る。今回は、`numpy.poly1d()`の結果が`[nan, nan, nan, nan]`になってるのを`print`デバッグして見つけた。今回は手っ取り早く`print`したけど、vscodeのデバッグ機能を使ったデバッグもやっておこう。
- 入力のデータから欠損値を`drop`するのはもちろんありだが、「入力値が有限数か？（無限やNaNではないか）」を確認する方法もある。

```python
>>> import math
>>> hoge = [0, math.inf, 1.1, -0.35323432, -math.inf, float('nan')]
>>> list(map(lambda x: math.isfinite(x), hoge))
[True, False, True, True, False, False]
```

- `math.isfinite()`を利用すると、引数が有理数か否かを判断できる。このとき、`map()`でラムダ式を書き、イテレータの要素すべてに対し処理を行うと、要素が有理数か否かをブール値で返すので、これに基づき処理対象を決める方法もある。

```python
idx = np.isfinite(x) & np.isfinite(y)
ab = np.polyfit(x[idx], y[idx], 1)
```

- 考えてみたら当たり前だが、**標準偏差は算出元のデータが1つしかないなら算出できない**。複数のデータのうち、ばらつきがどれだけあるかを見る数値なのだから、当たり前だなー。

**リンク**

1. [matplotlibで描画した散布図に線形回帰直線を追加する方法](https://ja.stackoverflow.com/questions/38755/matplotlib%E3%81%A7%E6%8F%8F%E7%94%BB%E3%81%97%E3%81%9F%E6%95%A3%E5%B8%83%E5%9B%B3%E3%81%AB%E7%B7%9A%E5%BD%A2%E5%9B%9E%E5%B8%B0%E7%9B%B4%E7%B7%9A%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95)
2. [numpy.polyfit doesn't handle NaN values](https://stackoverflow.com/questions/28647172/numpy-polyfit-doesnt-handle-nan-values)

### 3日目: 2020年10月4日（日）

**今日の進捗**: 

JavaScriptで、p5.jsを使ったボタンの生成方法について。

- p5.jsによるボタンの生成。`createButton()`を使うと、動的にボタンを生成できる。

```javascript
let button;

function setup() {
    createCanvas(400, 300);
    button = createButton('hoge');
    background(50);
}

function draw() {

}
```

- 上記のコードでは、実行するとCanvas外にボタンが1つ生成される。なお、これだけだと押してもボタンに挙動が設定されていないため、動作はしない。

```javascript
let button;

const drawRect = () => {
  fill(random(255));
  rect(random() * width, random() * height, random(width), random(height));
}

function setup(){
  createCanvas(400, 300);
  
  button = createButton('draw rectangle');
  button.mousePressed(drawRect);
}

function draw(){
  
}

```

- ボタンに挙動を設定するには、生成したボタンにアクションすべきイベントと挙動を指定する必要がある。上記のコードだと、`button.mousePressed(drawRect);`がその部分に当たる。

```javascript
let buttonDraw, buttonDel;

const drawRect = () => {
  fill(random(255));
  rect(random() * width, random() * height, random(width), random(height));
}

const clearCanvas = () => {
  background(255);
}

function setup(){
  createCanvas(400, 300);
  background(255);
  
  buttonDraw = createButton('draw rectangle');
  buttonDraw.mousePressed(drawRect);
  
  buttonDel = createButton('delete');
  buttonDel.mouseOver(clearCanvas);
}

function draw(){
  
}

```

- ボタンは複数生成が可能で、もちろんそれぞれについてアクションすべきイベントや機能を個別に設定できる。

**思ったこと**: 

- HTMLに書かなくてもJS側で動的に生成できるのは、編集する資産を一本化できるので便利。
- ボタン以外にもスライダーなんかも同じように生成できるので、基本的にJS側でオブジェクトを生成するように記述して、HTMLと往復しなくてもいいようなコーディングスタイルにしよう。

**リンク**

1. [12_1：コントロール要素 Creative Coding p5.js](https://himco.jp/2019/03/25/12_1%EF%BC%9A%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB%E8%A6%81%E7%B4%A0-creative-coding-javascrip/)

### 4日目: 2020年10月5日（月）

**今日の進捗**: 

Pythonのソートについてまとめ。

- Pythonでリストをソートする書き方を、DataFrameのソートと混同するのでメモ。

```python
>>> hoge = ['foo', 'bar', 'baz']
>>> sorted(hoge)
['bar', 'baz', 'foo']
>>> hoge
['foo', 'bar', 'baz']
>>> hoge.sort()
>>> hoge
['bar', 'baz', 'foo']
```

- Pythonでリストをソートする場合、`sorted()`と`sort()`の2通りがある。違いは新しいリストを返す（`sorted()`）か、もとのリストを変える（`sort()`）かという点。どちらがいいかは、ケースバイケースだと思う。とりあえず`sorted()`を覚えておけばタプルや文字列にも使える（ただし、リストを返すので変換が必要）から、潰しがきくこっちだろうか。

```python
>>> fuga = 'hogefugapiyo'
>>> sorted(fuga)
['a', 'e', 'f', 'g', 'g', 'h', 'i', 'o', 'o', 'p', 'u', 'y']
>>> ''.join(sorted(fuga))
'aefgghioopuy'
>>> piyo = ('foo', 'bar', 'baz')
>>> sorted(piyo)
['bar', 'baz', 'foo']
>>> tuple(sorted(piyo))
('bar', 'baz', 'foo')
>>> sorted(piyo, reverse=True)
['foo', 'baz', 'bar']
>>> tuple(sorted(piyo, reverse=True))
('foo', 'baz', 'bar')
```

- 文字列に対し`sorted()`を実行すると、リストで結果が返ってくるので`join()`を使って連結する。この際、空文字`''`を使って連結すれば単純な文字列に変換できるし、カンマやハイフンなどで連結することも可能。
- タプルに対し`sorted()`を実行すると、こちらもリストで結果が返ってくるので、`tuple()`を使ってタプルに変換する。
- なお、`sorted()`の引数に`reverse=True`を指定すると降順になる。

ちなみに、DataFrameやSeriesをソートするのは`sort_values()`。`sort_index()`は行や列のインデックスでソートする。

**思ったこと**: 

- こういうメソッドなり関数って、使ってないとどうしてもよく使う方に引っ張られるので気を付けたい。まぁ、この程度のミスなら実行時に「そんなメソッドないよ」ってエラーにしてくれるから、下手に実行されちゃって誤った処理をやっちゃうっていう危険性がないだけいいか。
- `sorted()`は関数なので引数にリストを指定するし、`sort()`は対象のリストに対するメソッドなので`リスト.sort()`の形で記述するから、ここでも差別化はできるかな。関数だから戻り値そのものは元のリストに関係ないし、メソッドだからソート対象のリストを直接変更するよ、と考えればわかりやすいかも。
- 調べりゃ出てくるんだけど、頭の中に入ってるのが一番早いよねぇ、そりゃ。

**リンク**

1. [Pythonでリストをソートするsortとsortedの違い](https://note.nkmk.me/python-list-sort-sorted/)
1. [pandas.DataFrame, Seriesをソートするsort_values, sort_index](https://note.nkmk.me/python-pandas-sort-values-sort-index/)

### 5日目: 2020年10月6日（火）

**今日の進捗**: 

Pythonのミュータブルとイミュータブルについてまとめ。

- Pythonのミュータブルとイミュータブルの違いについて。
  - ミュータブルとは変更が可能なデータ型のことを指す。リスト、タプルなんかが代表例。
  - イミュータブルとは変更が不可能なデータ型のことを指す。int、float、strなどが代表例。
- イミュータブルとは変更不可という意味だが、**変数に対する代入操作で変更不可という意味ではない**ので注意が必要。

```python
>>> a = 1
>>> a = 2
>>> a += 3
>>> a
5
>>> type(a)
<class 'int'>
```

- 上記のように、変数`a`はintなのでイミュータブルであるが、変数に対する操作で格納する値は変更されている。じゃあ何がイミュータブルなんだというと、**同一のidを指し示したままの変更は不可**という意味である。

```python
>>> a = 1
>>> id(a)
139825682166016
>>> a = 2
>>> id(a)
139825682166048
>>> a += 3
>>> a
5
>>> id(a)
139825682166144
>>> type(a)
<class 'int'>
```

- `id()`関数は[オブジェクトの識別子](https://docs.python.org/ja/3/library/functions.html#id)を返す。
- 上記の通り、見た目は変数`a`のみ登場しているのに、その識別子はそれぞれ異なっている。これは、変数`a`がその都度異なるオブジェクトを、その都度参照しているだけであることを示している。

```python
>>> a = 1
>>> b = 2
>>> c = 3
>>> hoge = [a, b, c]
>>> for h in hoge:
...   print(h + 1)
... 
2
3
4
>>> for h in hoge:
...   h = h + 2
...   print(h)
... 
3
4
5
>>> hoge
[1, 2, 3]
>>> a
1
```

- 上記は、イミュータブルなオブジェクトをミュータブルなリストの要素にした。要素に対し加算した場合、出力される結果そのものは加算された結果だが、肝心の要素側に変化はない。
- この加算された結果も新しいオブジェクトとして生成されており、変数`h`はそれらのオブジェクトを順に参照しているだけに過ぎない。よって、`for`のロープが終わったあとで`h`を参照すると、5のオブジェクトを指し示している。
- これらのことから、`for`で利用される変数`h`は新しい変数として作成され、リストの要素を順に参照する。それらの値に何かしらの処理を行った場合、それぞれが新しいオブジェクトとして生成され、そのオブジェクトを変数`h`が参照するような仕組み。
- よって、上記のようなfor文によるリストの各要素への処理を実行した場合、リストの要素そのものが変更されるわけではない。また、各要素を参照した変数（ここで言うと`h`）はループを抜けたあとだと、最後の要素に対する処理を実行した後の値（ここでは3 + 2の処理結果である5）を保持している。

```python
>>> a = 1
>>> b = 2
>>> c = 3
>>> hoge = [a, b, c]
>>> id(hoge)
4432487280
>>> for h in hoge:
...   print('{}: {}'.format(h, id(h)))
... 
1: 4430876432
2: 4430876464
3: 4430876496
>>> for h in hoge:
...   h = h + 2
...   print('{}: {}'.format(h, id(h)))
... 
3: 4430876496
4: 4430876528
5: 4430876560
>>> hoge
[1, 2, 3]
>>> for h in hoge:
...   print('{}: {}'.format(h, id(h)))
... 
1: 4430876432
2: 4430876464
3: 4430876496
>>> d = 4
>>> hoge.append(d)
>>> hoge
[1, 2, 3, 4]
>>> id(hoge)
4432487280
>>> for h in hoge:
...   print('{}: {}'.format(h, id(h)))
... 
1: 4430876432
2: 4430876464
3: 4430876496
4: 4430876528
```

- `id()`関数を使って、リストと要素の識別子を参照してみた。
- 要素に対し加算した場合、加算結果はリスト内の要素とは別のオブジェクトを参照していることが、識別子が異なることからわかる。
- もともとのリストが参照する先は変更されていないため、リストの要素は加算処理の前後で変わらない。
- よって、「リストが持つ要素に変更は加えたくないが、何かしらの処理を要素に対して行いたい」という場合は、上記のコードで実現できる。

```python
>>> fuga = [1, 2, 3]
>>> id(fuga)
4548215664
>>> for f in fuga:
...   print('{}: {}'.format(f, id(f)))
...   f += 2
...   print('{}: {}'.format(f, id(f)))
... 
1: 4546588432
3: 4546588496
2: 4546588464
4: 4546588528
3: 4546588496
5: 4546588560
>>> id(fuga)
4548215664
>>> 
```

- ちなみに、リストの要素に変数ではなく直接int型の値を格納しても、挙動は一緒。
- [このページ](http://pythontutor.com/visualize.html)でPythonを書くと、そのオブジェクトをグラフィカルに表示してくれる。見た目でわかりやすいので、オブジェクト絡みで挙動を見てみたいときは使ってみるといいかもしれない。

**思ったこと**: 

- 理屈は理屈で、やっぱり自分で動作確認のためのコードを書くのが一番の早道だと思う。
- まさに「例示は理解の試金石」ってやつか。

**リンク**

1. [オブジェクト、値、および型](https://docs.python.org/ja/3/reference/datamodel.html)
1. [pythontutor](http://pythontutor.com/visualize.html)

### 6日目: 2020年10月7日（水）

**今日の進捗**: 

Pythonで時系列データのテストデータを作成する方法についてまとめ。

- pandasとnumpyを使って時系列データのテストデータを作る方法。
- `date_range()`を使って月次や日次のデータを作る。そのデータをインデックスにして、DataFrameを生成するとテスト用の時系列データが生成できる。

```python
>>> import pandas as pd
>>> dates = pd.date_range('2020/1/1', '2020/3/31', freq='D')
>>> len(dates)
91
>>> import numpy as np
>>> df = pd.DataFrame(np.arange(len(dates) * 3).reshape(len(dates), 3), columns=['hoge', 'fuga', 'piyo'], index=dates)
>>> df.head()
            hoge  fuga  piyo
2020-01-01     0     1     2
2020-01-02     3     4     5
2020-01-03     6     7     8
2020-01-04     9    10    11
2020-01-05    12    13    14
>>> 
```

- インデックスには、生成した日付の連続値を設定する。項目列側には、`np.arange(len(dates) * 3)`で生成した`91 * 3`個のデータを、各列にそれぞれハマるように`reshape()`して格納する。列名は適当に設定。これだけで、日次のデータ群が生成できる。

```python
>>> pd.date_range('2020/1/1', '2020/1/2', freq='H')
DatetimeIndex(['2020-01-01 00:00:00', '2020-01-01 01:00:00',
               '2020-01-01 02:00:00', '2020-01-01 03:00:00',
               '2020-01-01 04:00:00', '2020-01-01 05:00:00',
               ...
               '2020-01-01 20:00:00', '2020-01-01 21:00:00',
               '2020-01-01 22:00:00', '2020-01-01 23:00:00',
               '2020-01-02 00:00:00'],
              dtype='datetime64[ns]', freq='H')
>>> pd.date_range('2020/1/1 00:00:00', '2020/1/1 01:00:00', freq='min')
DatetimeIndex(['2020-01-01 00:00:00', '2020-01-01 00:01:00',
               '2020-01-01 00:02:00', '2020-01-01 00:03:00',
               '2020-01-01 00:04:00', '2020-01-01 00:05:00',
               '2020-01-01 00:06:00', '2020-01-01 00:07:00',
                ...
               '2020-01-01 00:54:00', '2020-01-01 00:55:00',
               '2020-01-01 00:56:00', '2020-01-01 00:57:00',
               '2020-01-01 00:58:00', '2020-01-01 00:59:00',
               '2020-01-01 01:00:00'],
              dtype='datetime64[ns]', freq='T')
>>> pd.date_range('2020/1/1', '2020/3/31', freq='M')
DatetimeIndex(['2020-01-31', '2020-02-29', '2020-03-31'], dtype='datetime64[ns]', freq='M')
```

- `freq`に指定可能な値はいろいろあるが、注意が必要なのは`M`でこれは**月次**を表す。分ではないので注意。分ごとのデータを生成した場合は、`min`か`T`を指定する。

- ちなみに、上記で使っている`reshape()`は、配列の形状を変更するのに利用する。

```python
>>> np.arange(12)
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
>>> np.arange(12).reshape(4, 3)
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])
>>> np.arange(12).reshape(2, 6)
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11]])
>>> np.arange(12).reshape(1, 12)
array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]])
>>> np.arange(12).reshape(12, 1)
array([[ 0],
       [ 1],
       [ 2],
       [ 3],
       [ 4],
       [ 5],
       [ 6],
       [ 7],
       [ 8],
       [ 9],
       [10],
       [11]])
```

- もともとの形状（ここでは1次元の12要素）から変更できるなら、どんな形状にでも変更できる。

```python
>>> np.range(12).reshape(3, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/local/lib/python3.8/site-packages/numpy/__init__.py", line 214, in __getattr__
    raise AttributeError("module {!r} has no attribute "
AttributeError: module 'numpy' has no attribute 'range'
```

- 上記のように、もともとの形状と変更先の形状で要素数が異なる（もともとの要素数は12だが、`reshape()`で指定しているのは`3, 3`の9で一致しない）場合はエラーになる。

**思ったこと**: 

- テストデータが必要なときってちょこちょこあるので、こういうコードはgistなどに上げておいてすぐ利用できるようにしておきたい。
- 分の指定が`M`だとMonth（月）と重複しちゃうってのはわかる、だから`min`があるんだなって理解はとりあえずできるしわかりやすい。それはそうと、`T`って何だろうね。minuteの語尾かな・・・。

**リンク**

1. [pandasの時系列データにおける頻度（引数freq）の指定方法](https://note.nkmk.me/python-pandas-time-series-freq/)
1. [pandas.DataFrameの構造とその作成方法](https://note.nkmk.me/python-pandas-dataframe-values-columns-index/)
1. [pandas で日時の連続値を生成し、インデックスに使う](http://ailaby.com/date_range/)

### 7日目: 2020年10月8日（木）

**今日の進捗**: 

Pythonでランダムな文字列を生成する方法について。

- Pythonでランダムな文字列を生成するプログラム。

```python
import random, string

def get_random_string(length=8, uppercase=True, lowercase=True, digits=True):
    seed_string = ''

    if uppercase:
        seed_string += string.ascii_uppercase
    if lowercase:
        seed_string += string.ascii_lowercase
    if digits:
        seed_string += string.digits
    
    if len(seed_string) > 0:
        result = ''.join([random.choice(seed_string) for i in range(length)])
    else:
        result = ''

    return result
```

- 内容は簡単で、引数で指定された内容で文字列を一度生成して、その文字列から指定された回数分1文字ランダムで抽出する。

```python
>>> import string
>>> string.ascii_lowercase
'abcdefghijklmnopqrstuvwxyz'
>>> string.ascii_uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.digits
'0123456789'
```

- `string`で始まる部分は、**文字列定数**と呼ばれている定数で、それぞれ大文字や小文字が格納されている。これらの定数を連結して抽出元の文字列を生成している。

```python
>>> get_random_string()
'2TsENwLT'
>>> get_random_string(length=100, uppercase=True, lowercase=False, digits=True)
'0LMQ5Z28CHRQUGYMLHVVQX4VJZFZZXR4OBO13AZNCN6RQ4CTLHGVOS26UH6BKSF5EQ1ZJC6MQDQO53R92JEXSQNLWVMWCUELXQ66'
```

- 実行するときは、引数を一切指定しなければ大文字小文字と数字で8文字分生成する。
- 大文字や小文字、数字の出力を抑制したい場合は`False`を指定すればいい。文字列長はデフォルトでは8文字。
- すべての文字を出力対象にしない場合は、文字列長の長さにかかわらず空文字を返す。

----

昨日の時系列データについて補足。というか機能の追加。

- 時系列データのテストデータ作成時に、各列に格納するデータは適当な値をnumpyで生成していた。が、あれだときっちり比例の関係になってしてしまうため、折れ線グラフなどに利用するには少し味気ない。
- そこで、生成したデータにランダムな値による乗算処理を行って、値に変化をつけることにする。

```python
>>> import pandas as pd
>>> import numpy as np
>>> dates = pd.date_range('2020/1/1', '2020/3/31', freq='D')
>>> COL_NUM = 3
>>> input_datas = np.arange(len(dates) * COL_NUM)
>>> import random
>>> input_datas = list(map(lambda x: x * round(random.random(), 2), input_datas))
>>> df = pd.DataFrame(np.array(input_datas).reshape(len(dates), COL_NUM), index=dates, columns=['foo', 'bar', 'baz'])
>>> df.head()
             foo    bar    baz
2020-01-01  0.00   0.87   0.38
2020-01-02  1.08   2.68   1.75
2020-01-03  0.96   3.15   4.24
2020-01-04  2.88   9.80   7.92
2020-01-05  2.52  12.74  12.46
>>> 
```

- `map()`関数で指定したリストの要素xに対し、`x * round(random.random(), 2)`という乗算処理を行う。この処理はすべての要素それぞれで`random.random()`が実行されるため、要素それぞれに乗算される値は全て異なる。

```python
>>> np.array([1, 1, 1]) * round(random.random(), 2)
array([0.16, 0.16, 0.16])
```

- なお、numpy.ndarray形式の配列に乗算処理をする場合は、すべての要素に**同一の値**で乗算される。毎回異なる値を乗算したい場合、この計算方法は使えない。逆に同じ値で計算したい場合は、見た目にもわかりやすいこの方法がおすすめ。

```python
>>> list(map(lambda x: x * round(random.random(), 2), [1, 1, 1]))
[0.53, 0.1, 0.05]
>>> list(map(lambda x: x * round(random.random(), 2), np.array([1, 1, 1])))
[0.3, 0.17, 0.27]
>>> map(lambda x: x * round(random.random(), 2), [1, 1, 1])
<map object at 0x7f2a2c4152b0>
```

- 異なる値で計算したい場合は、前述のように`map()`関数を使うことになる。この場合はnumpy.ndarrayであるかリストであるかは関係なく、同じ挙動をする。
- なお、`map()`関数の戻り値はリストなどではなく[mapオブジェクト](https://note.nkmk.me/python-map-list-iterator/)というもの。イテレータなのでfor文などで利用できるが、リストと異なりそれ単体で内容を確認できるものではない。よって、上記の例では`list()`を使ってリストに変換している。

```python
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

- ちなみに、リストに対し直接乗算処理を行うと**要素数が増える**。要素に対し計算処理が実行されるわけではないので、注意が必要。

**思ったこと**: 

- 「こういうツールとか関数欲しいなー」と思ったときに、パッと作れるくらいには慣れよう。
- 文字列定数があるおかげで、わざわざ自分で抽出元の文字列を書かなくていいのは楽。
- `random.random()`は、テストデータなんだけど「それっぽい値」にするのに便利。ただし、利用するなら`import random`が必要になるので忘れないように。

**リンク**

1. [pythonでランダム文字列の生成](https://hacknote.jp/archives/52068/)
1. [string --- 一般的な文字列操作](https://docs.python.org/ja/3/library/string.html)
1. [NumPy配列ndarrayとPython標準のリストを相互に変換](https://note.nkmk.me/python-numpy-list/)
1. [Python3のmapはリストではなくイテレータを返す](https://note.nkmk.me/python-map-list-iterator/)


### 8日目: 2020年10月9日（金）

**今日の進捗**: 

リスト内包表記の記述方法についてまとめ。

```python
[変数に行う処理 for 変数 in リストなどのイテレータ]
```

- リスト内包表記は、何かしらの処理を実行しつつ新しいリストを生成した場合に用いる。

```python
>>> [i * 3 for i in range(1, 5)]
[3, 6, 9, 12]
>>> hoge = []
>>> for i in range(1, 5):
...   hoge.append(i * 3)
... 
>>> hoge
[3, 6, 9, 12]
```

- 例として、3の倍数でリストを作成する方法を考えると上記のように記述できる。ループのもとになるイテレータは既存のものでもいいし、`range()`で生成したものでもいい。
- `append()`を利用して要素を追加する方法より、記述量が少なくて可読性がよい。表記方法も、角かっこで囲ってあって「リストが出力される」と直感的に理解しやすい。ループ部分もまんまfor文なので、こちらも理解しやすい。

```python
>>> hoge = 'foobarbaz'
>>> hoge.count('o')
2
>>> [hoge.count(s) for s in ['o', 'ba', 'oo']]
[2, 2, 1]
```

- 次の例は、ある文字列において含まれているであろう文字をリストにして、それぞれがいくつ含まれているか個数をリストで返すコード。
- `string.count()`は引数に指定された文字や文字列が、元の文字列の中で何回出現するかをカウントするメソッド。

```python
[変数に行う処理 for 変数 in イテレータ if 条件式]
```

- 処理を行う要素について任意の条件を付与したい場合は、上記のようなifがついかリスト内包表記を用いる。

```python
>>> [i ** 2 for i in range(10) if i % 2 == 0]
[0, 4, 16, 36, 64]
```

- 例として、偶数のみ2乗するリスト内包表記を書いてみた。要素のうち、2の余剰がゼロになる（偶数）という条件が成立する要素のみ対象とする、という条件を`if`部分に記述することで、処理対象の要素を限定できる。

**思ったこと**: 

- リスト内包表記はチューリング完全らしいので、やる気になればワンライナーでいろいろ（LISP実装まで）できるらしいが、いくらなんでも可読性がアレ過ぎるので用法用量を守って正しくお使いください案件。

**リンク**

1. [Pythonリスト内包表記の使い方](https://note.nkmk.me/python-list-comprehension/)
1. [リスト内包表記の活用と悪用](https://qiita.com/KTakahiro1729/items/c9cb757473de50652374)

### 9日目: 2020年10月10日（土）

**今日の進捗**: 

Pythonでpandas.DataFrameに対し統計量を取得する`describe()`を実行するときの注意点について。

- ゼロを含んだDataFrameで`describe()`を実行したい場合、**ケースによっては**一度ゼロを除外する方がいい。
- ゼロが意味を持つデータならいいが、意味を持たない（欠損値と変わらない）ようなデータの場合、ゼロを含んだ状態で統計量を出すと、本来の意味とは異なる統計量が出てきてしまう。特に最小値が必ずゼロになってしまうため、標準偏差もゼロを含んだ場合と含まない場合で差が出てくる。

```python
df.describe()
df[df > 0.0].describe()
```

- `df`がゼロを含むデータであった場合、1行目と2行目の結果は異なる。
- `df[df > 0.0]`の場合、ゼロはデータとして抽出されないためNaNになる。`describe()`は**NaNを無視する**ため、2行目は1行目のゼロを含んだ結果と異なる結果を出力する。

----

Pythonでラムダ式に複数の引数を設定する方法について。

- 単純に引数設定の際に複数の設定を記述すればいい。
- `def`による関数宣言を同様に、引数の初期設定が可能。

```python
>>> hoge = lambda a, b=2: a * b
>>> hoge(1)
2
>>> hoge(1, 3)
3
>>> hoge()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: <lambda>() missing 1 required positional argument: 'a'
>>> hoge(b=100, a=4)
400
>>> 
```

- 上記の場合、引数bに2が初期設定されているため、引数aだけ指定してやれば実行可能。引数が指定されなければエラーになるのも、`def`による関数宣言と同じ。

----

p5.jsの勉強。

なお、p5.jsの環境はCodepenでp5.jsのライブラリを参照する設定すればいい。

- p5.jsの基本中の基本。

```javascript
const W = 800;
const H = 600;

function setup(){
  createCanvas(W, H);
  
  background(255);
}

function draw(){
  ellipse(60, 60, width / 10, height / 10);
}
```

- p5.jsは`setup()`が1度だけ実行され、次に`draw()`が繰り返し実行されるという状態の遷移で動作する。
- `setup()`はその名前の通り、初期設定などで用いる。そして`setup()`内で宣言された変数は、他の関数からはアクセスできないとある。まぁ、少なくとも`let`とか使ってればJSの仕様上大丈夫だろう。
- `draw()`は自動的に繰り返し実行される。初期設定以外の実際の描画処理はこの関数の中に記述することになる。
- 上記の場合、`setup()`でCanvasが生成される。Canvasのサイズは`const`で宣言した。その後、Canvasを指定した背景色で塗りつぶす。0が真っ黒で255が真っ白。要は色指定でよくある、RGBの値で指定すればいい。
- `background()`は背景に利用する色を設定する。デフォルトは**透明**。
ｰ 実際の描画処理は`draw()`で実行される。ここでは`ellipse()`を実行して円を描画している。
- `ellipse(x座標, y座標, 横幅, 高さ)`で描画する円を設定する。
- `draw()`関数の中で`width`と記述すると、Canvasの横のサイズを取得できる。同様に`height`と記述すると、Canvasの高さを取得できる。ここでは取得した縦横の10分の1のサイズの楕円を描画した。
- 上記のコードで一応簡単だがp5.jsの挙動がわかると思う。ただし、現状のコードでは**ちょっとした問題がある**。

```javascript
const W = 800;
const H = 600;
let position = 0;

function setup(){
  createCanvas(W, H);
  
  background(255);
}

function draw(){
  
  ellipse(60 + position, 60 + position, width / 10, height / 10);
  
  position += 2;
}
```

- 今度のコードは、楕円を描画する位置を少しずつズラしている。
- 実行してみるとわかるが、**1度描画された楕円がその後もCanvas上に残り続ける**。これが目的の描画なら問題ないが、「楕円が斜めに**移動する**」挙動を実現したい場合は、過去に描画されたシェイプは残らない方が望ましい。その仕様を満たすには、**Canvasの内容をクリア**する必要がある。

```javascript
const W = 800;
const H = 600;
let position = 0;

function setup(){
  createCanvas(W, H);
}

function draw(){
  background(255);
  
  ellipse(60 + position, 60 + position, width / 10, height / 10);
  
  position += 2;
}
```

- 背景色を設定する`background()`関数を、`setup()`関数から`draw()`関数の冒頭に移動した。これにより、`draw()`関数が実行されると、まず最初に**Canvasの内容が設定された色でリセットされる**。その後、楕円が描画される。この挙動により、楕円が斜めに移動しているように見える。
- `background()`関数は多くの場合、`draw()`関数の冒頭でCanvasの内容をリセットするのに用いられる。`setup()`関数内で利用される場合は、背景色の設定が1度でいいか、アニメーションの開始フレームの背景色を設定する場合に利用される。
- デフォルトのカラー空間は、各値が0から255の範囲のRGB。HSLでも指定が可能らしい。
- 第2引数はアルファ値で、省略可能。アルファの範囲はデフォルトで0から255。

----

マウスに追随するシェイプをp5.jsで実装する。

```javascript
const W = 800;
const H = 600;

function setup(){
  createCanvas(W, H);
}

function draw(){
  ellipse(mouseX, mouseY, width / 10, height / 10);  
}
```

- マウスカーソルを適当に動かすと、カーソルに合わせて楕円が描画される。ゴリゴリ動かすとどんどん楕円が描画される。
- `mouseX`と`mouseY`でマウスカーソルのX座標とY座標を取得できる。PCのマウス入力でなくスマートフォンなどのタッチ入力である場合は、**直近にタッチされた位置のX座標およびY座標を保持**する。

```javascript
  console.log('mouseX: ' + mouseX);
  console.log('mouseY: ' + mouseY);
```

- 上記のコードを記述することで、`mouseX`と`mouseY`の座標を出力できる。見るとわかるが、Canvasの左上を`(0, 0)`とした値で出力される。
- `draw()`関数内に`background()`がないので、シェイプが残り続けるのはさっきと同様。

```javascript
const W = 800;
const H = 600;

function setup(){
  createCanvas(W, H);
}

function draw(){
  if (mouseIsPressed) {
    fill(0);
  }
  else{
    fill(255);
  }
  
  ellipse(mouseX, mouseY, width / 10, height / 10);
  
}
```

- マウスがクリックされているか否かを判断するのは、`mouseIsPressed`を参照する。Trueであればクリック状態にある。
- `fill()`関数はシェイプの塗りつぶす色を設定する。1度設定すると、以降に描画されるすべてのシェイプに影響する。色の設定はデフォルトのカラー空間だと、0から255の範囲のRGB。引数1つで設定する場合はグレースケールになる。
- グレースケール指定の第2引数、カラー設定の第4引数はアルファ値で省略可能。アルファの範囲も、他と同様デフォルトで0から255。

**思ったこと**: 

- 統計量算出において、ゼロに意味がある場合とない場合で出力結果が意味するところが変わってくる。算出前にデータ内容を確認して「ゼロを含むことに意味があるか、またはないか」を考慮することが必要。
− p5.js面白いなー。とりあえずマウスに追随してシェイプを描画するのくらいはやってみたい・・・と思ってやってみたけど、これだけのコード量でこれができるのは楽で面白い。

**リンク**

1. [pandasのdescribeで各列の要約統計量（平均、標準偏差など）を取得](https://note.nkmk.me/python-pandas-describe/)
1. [Pythonのlambda（ラムダ式、無名関数）の使い方](https://note.nkmk.me/python-lambda-usage/)
1. [p5.js Get Started](https://p5js.org/get-started/)
1. [p5.js スピード入門](https://himco.jp/category/p5-js-%e3%82%b9%e3%83%94%e3%83%bc%e3%83%89-%e5%85%a5%e9%96%80/)

### 10日目: 2020年10月11日（日）

**今日の進捗**: 

Pythonでラムダ式を書く際の注意点について。

- ラムダ式を記述する際、任意の名前を付けるのはPEP8的にご法度なので、PEP8に準拠したLintではエラーになる。

```python
>>> tetens = lambda x: 6.11 * (10 ** (7.5 * x / (x + 237.3)))
>>> tetens(20)
23.389356843099335
```

- ここではラムダ式に`tetens`という名前をつけ、実行する際も`tetens(引数)`という記述方法で実行している。PEP8からすると、この書き方をするくらいなら「`def`で関数宣言しろよ」ということらしい。まぁ気持ちはわかる。

----

p5.jsでのシェイプ描画処理について。

- 線の描画は`line()`関数を利用する。

```javascript
W = 800;
H = 600;

function setup(){
  createCanvas(W, H);
}

function draw(){
  background(255);
  
  line(20, 20, 100, 100);
  line(110, 110, 200, 200);
  
}
```

- `line()`関数は引数に「始点のX座標、始点のY座標、終点のX座標、終点のY座標」を指定する。
- `strokeWeight()`で任意の数字を指定することで、描画する線の太さを指定できる。デフォルトの太さは1。

```javascript
  line(20, 20, 100, 100);
  strokeWeight(10);
  line(110, 110, 200, 200);
```

- 線の太さ設定は`strokeWeight()`で数字を指定すればいいが、上記のような書き方をすると最初の`line()`関数で描画した線も含めて**すべてのシェイプが太さ10に設定されてしまう**。

```javascript
  strokeWeight(1);
  line(20, 20, 100, 100);
  strokeWeight(10);
  line(110, 110, 200, 200);
```

- 各シェイプで異なる太さを設定したい場合は、**シェイプ描画の直前で太さを明記しておく**（たとえデフォルトの1であっても）ことが重要。

----

- 四角の描画は`quad()`関数を利用する。ここで言う「四角」とは正方形や長方形とは異なり、角の部分は直角じゃなくても構わない。なお、これ以降は`setup()`関数や`draw()`関数の一部を省略する（線の描画のときと同じコードなので）。

```javascript
  fill(255, 0, 0);
  strokeWeight(2);
  quad(200, 20, 300, 30, 310, 100, 210, 110);
```

- `quad()`関数は「x1, y1, x2, y2, x3, y3, x4, y4」でそれぞれ座標を指定する。
- 指定された極座標で四角を描画するため、指定の座標によってはひねったような形の四角（三角を2つ並べたような形）を描画することも可能。

----

- 三角の描画は`triangle()`関数を利用する。

```javascript
//draw triangle
  fill(0, 255, 0);
  triangle(380, 20, 440, 100, 320, 100);
```

- `triangle()`関数は「x1, y1, x2, y2, x3, y3」で座標を指定する。

----

- 長方形の描画は`rect()`関数を利用する。

```javascript
  fill(0, 0, 255);
  rect(460, 20, 100, 100);
  
  fill(20, 200, 100);
  rect(610, 20, 100, 100, 15);
```

- `rect()`関数は他のシェイプを描画する関数と異なっていて、引数が「左上のx座標、左上のy座標、幅、高さ」になっている。角の座標を個別に指定しなくていいので、単純に正方形または長方形を描画するなら`rect()`関数を利用したほうが楽。
- 第5引数以降は、角に丸みをつけるのに利用する。左上、右上、右下、左下の順でそれぞれの角の丸みを指定できる。途中で省略した場合は、直前で指定された値を引き継ぐ。上記の例だと、左上の丸みを15に指定しているので、他の角も同様に15で指定したことになる。

**思ったこと**: 

- Lintではエラーになるものの、インタプリタ形式で記述する際は簡単な関数ならむしろ`def`を書きたくないので、名前のついたラムダ式は割と便利な印象がある。まぁ動作の確認するのにちょっとだけ利用するってならいいかもしれないけど、ちゃんと書かなきゃいけないような場合はやめようね、という話。
- まぁ大抵の場合はLintに従っておけばいいよね、という気がしている。
- p5.jsに限らず、実際にシェイプを描画する場合は三角や四角よりは曲線だったりノイズだったりと、より複雑なシェイプを描画しがちだしその方が見た目がいいのだけど、やっぱり基本は抑えておくべきだよね、ってことでしっかり覚えよう。

**リンク**

1. [Pythonのlambda（ラムダ式、無名関数）の使い方](https://note.nkmk.me/python-lambda-usage/)

### x日目: 2020年10月y日（z）

**今日の進捗**: 

-

**思ったこと**: 

-

**リンク**

1. [hoge]()
