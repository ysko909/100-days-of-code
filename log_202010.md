# 100 Days Of Code - 学習ログ

## 2020年10月分

### 1日目: 2020年10月1日（木）

**今日の進捗**: 

JavaScriptでのアップロード機能の実装について。

- JavaScriptでローカルの画像をアップロードし、canvas上に表示するプログラムを作成。HTMLとJavaScriptなので、PlayCode上にて仮実装。
- [参考元URL](https://www.tam-tam.co.jp/tipsnote/javascript/post13538.html)では、画像ファイルであれば受け付けていたが、ここではPNGのみを対象とした。`type.match()`の対象を、`image/png`とするとPNGに限定できる。
- もともとの仕様では画像がアップロードされた場合のみcanvasの更新を行っていたため、対象外のファイルがアップロードされた場合は、過去にアップロードされたデータや子要素が画面に残り続ける。それを解消するため、PNG以外がアップロードされた場合は一度canvasを削除する仕様とした。また、同様にダウンロード用URLが存在する場合は子要素から削除する。

**思ったこと**: 

- PlayCodeは特定のボタンを押すと、ソースのフォーマットを行ってくれる。その際、アロー関数に引数がある場合は**かっこを外す**（引数がない場合はかっこを省略できないので、そのまま残る）。「挙動は一緒なんだから、文字は少ない方がいいでしょ」という判断なのかもしれないが、個人的にはまだアロー関数に慣れてないので、あんまり省略されると混乱する。
- アロー関数ではかっこだけでなく、1行で記述する場合は波かっこまで省略可能なので、ぱっと見の可読性に難があって割と混乱しがち。
- どっちがいいかはともかくとして、「どっちでも読める」程度には慣れたい。

**リンク** 

1. [File APIとCanvasでローカルの画像をアップロード→加工→ダウンロードする](https://www.tam-tam.co.jp/tipsnote/javascript/post13538.html)
1. [ソースのgist](https://gist.github.com/ysko909/0f14a71c5604ded658e3a4f8fb837e6d)

### 2日目: 2020年10月2日（金）

**今日の進捗**: 

Pythonでのnumpy利用時のエラー調査。

- Pythonで`numpy.poly1d()`を使った回帰線の描画がコケた。具体的には、エラーにならず描画されないという感じ。
- 原因は`numpy.poly1d()`で渡したデータ群に欠損値があったこと。欠損値が存在している場合、エラーなどのリアクションをせず、ただ描画しないらしい。
- ちなみに何が欠損していたかというと、標準偏差を格納していた列の値の数データが欠損。理由は、標準偏差を算出する元のデータが1件しか存在しなかったため、「標準偏差を算出できないよ」と欠損していた。
- `dropna(subset=['col_name', 'col_name2'])`で欠損値を削除したデータを、`numpy.poly1d()`に渡して事なきを得た。

**思ったこと**: 

- エラーメッセージなんかのリアクションがないのに、望んだ結果が出力されないってのが一番困る。今回は、`numpy.poly1d()`の結果が`[nan, nan, nan, nan]`になってるのを`print`デバッグして見つけた。今回は手っ取り早く`print`したけど、vscodeのデバッグ機能を使ったデバッグもやっておこう。
- 入力のデータから欠損値を`drop`するのはもちろんありだが、「入力値が有限数か？（無限やNaNではないか）」を確認する方法もある。

```python
>>> import math
>>> hoge = [0, math.inf, 1.1, -0.35323432, -math.inf, float('nan')]
>>> list(map(lambda x: math.isfinite(x), hoge))
[True, False, True, True, False, False]
```

- `math.isfinite()`を利用すると、引数が有理数か否かを判断できる。このとき、`map()`でラムダ式を書き、イテレータの要素すべてに対し処理を行うと、要素が有理数か否かをブール値で返すので、これに基づき処理対象を決める方法もある。

```python
idx = np.isfinite(x) & np.isfinite(y)
ab = np.polyfit(x[idx], y[idx], 1)
```

- 考えてみたら当たり前だが、**標準偏差は算出元のデータが1つしかないなら算出できない**。複数のデータのうち、ばらつきがどれだけあるかを見る数値なのだから、当たり前だなー。

**リンク**

1. [matplotlibで描画した散布図に線形回帰直線を追加する方法](https://ja.stackoverflow.com/questions/38755/matplotlib%E3%81%A7%E6%8F%8F%E7%94%BB%E3%81%97%E3%81%9F%E6%95%A3%E5%B8%83%E5%9B%B3%E3%81%AB%E7%B7%9A%E5%BD%A2%E5%9B%9E%E5%B8%B0%E7%9B%B4%E7%B7%9A%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95)
2. [numpy.polyfit doesn't handle NaN values](https://stackoverflow.com/questions/28647172/numpy-polyfit-doesnt-handle-nan-values)

### 3日目: 2020年10月4日（日）

**今日の進捗**: 

JavaScriptで、p5.jsを使ったボタンの生成方法について。

- p5.jsによるボタンの生成。`createButton()`を使うと、動的にボタンを生成できる。

```javascript
let button;

function setup() {
    createCanvas(400, 300);
    button = createButton('hoge');
    background(50);
}

function draw() {

}
```

- 上記のコードでは、実行するとCanvas外にボタンが1つ生成される。なお、これだけだと押してもボタンに挙動が設定されていないため、動作はしない。

```javascript
let button;

const drawRect = () => {
  fill(random(255));
  rect(random() * width, random() * height, random(width), random(height));
}

function setup(){
  createCanvas(400, 300);
  
  button = createButton('draw rectangle');
  button.mousePressed(drawRect);
}

function draw(){
  
}

```

- ボタンに挙動を設定するには、生成したボタンにアクションすべきイベントと挙動を指定する必要がある。上記のコードだと、`button.mousePressed(drawRect);`がその部分に当たる。

```javascript
let buttonDraw, buttonDel;

const drawRect = () => {
  fill(random(255));
  rect(random() * width, random() * height, random(width), random(height));
}

const clearCanvas = () => {
  background(255);
}

function setup(){
  createCanvas(400, 300);
  background(255);
  
  buttonDraw = createButton('draw rectangle');
  buttonDraw.mousePressed(drawRect);
  
  buttonDel = createButton('delete');
  buttonDel.mouseOver(clearCanvas);
}

function draw(){
  
}

```

- ボタンは複数生成が可能で、もちろんそれぞれについてアクションすべきイベントや機能を個別に設定できる。

**思ったこと**: 

- HTMLに書かなくてもJS側で動的に生成できるのは、編集する資産を一本化できるので便利。
- ボタン以外にもスライダーなんかも同じように生成できるので、基本的にJS側でオブジェクトを生成するように記述して、HTMLと往復しなくてもいいようなコーディングスタイルにしよう。

**リンク**

1. [12_1：コントロール要素 Creative Coding p5.js](https://himco.jp/2019/03/25/12_1%EF%BC%9A%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB%E8%A6%81%E7%B4%A0-creative-coding-javascrip/)

### 4日目: 2020年10月5日（月）

**今日の進捗**: 

Pythonのソートについてまとめ。

- Pythonでリストをソートする書き方を、DataFrameのソートと混同するのでメモ。

```python
>>> hoge = ['foo', 'bar', 'baz']
>>> sorted(hoge)
['bar', 'baz', 'foo']
>>> hoge
['foo', 'bar', 'baz']
>>> hoge.sort()
>>> hoge
['bar', 'baz', 'foo']
```

- Pythonでリストをソートする場合、`sorted()`と`sort()`の2通りがある。違いは新しいリストを返す（`sorted()`）か、もとのリストを変える（`sort()`）かという点。どちらがいいかは、ケースバイケースだと思う。とりあえず`sorted()`を覚えておけばタプルや文字列にも使える（ただし、リストを返すので変換が必要）から、潰しがきくこっちだろうか。

```python
>>> fuga = 'hogefugapiyo'
>>> sorted(fuga)
['a', 'e', 'f', 'g', 'g', 'h', 'i', 'o', 'o', 'p', 'u', 'y']
>>> ''.join(sorted(fuga))
'aefgghioopuy'
>>> piyo = ('foo', 'bar', 'baz')
>>> sorted(piyo)
['bar', 'baz', 'foo']
>>> tuple(sorted(piyo))
('bar', 'baz', 'foo')
>>> sorted(piyo, reverse=True)
['foo', 'baz', 'bar']
>>> tuple(sorted(piyo, reverse=True))
('foo', 'baz', 'bar')
```

- 文字列に対し`sorted()`を実行すると、リストで結果が返ってくるので`join()`を使って連結する。この際、空文字`''`を使って連結すれば単純な文字列に変換できるし、カンマやハイフンなどで連結することも可能。
- タプルに対し`sorted()`を実行すると、こちらもリストで結果が返ってくるので、`tuple()`を使ってタプルに変換する。
- なお、`sorted()`の引数に`reverse=True`を指定すると降順になる。

ちなみに、DataFrameやSeriesをソートするのは`sort_values()`。`sort_index()`は行や列のインデックスでソートする。

**思ったこと**: 

- こういうメソッドなり関数って、使ってないとどうしてもよく使う方に引っ張られるので気を付けたい。まぁ、この程度のミスなら実行時に「そんなメソッドないよ」ってエラーにしてくれるから、下手に実行されちゃって誤った処理をやっちゃうっていう危険性がないだけいいか。
- `sorted()`は関数なので引数にリストを指定するし、`sort()`は対象のリストに対するメソッドなので`リスト.sort()`の形で記述するから、ここでも差別化はできるかな。関数だから戻り値そのものは元のリストに関係ないし、メソッドだからソート対象のリストを直接変更するよ、と考えればわかりやすいかも。
- 調べりゃ出てくるんだけど、頭の中に入ってるのが一番早いよねぇ、そりゃ。

**リンク**

1. [Pythonでリストをソートするsortとsortedの違い](https://note.nkmk.me/python-list-sort-sorted/)
1. [pandas.DataFrame, Seriesをソートするsort_values, sort_index](https://note.nkmk.me/python-pandas-sort-values-sort-index/)

### 5日目: 2020年10月6日（火）

**今日の進捗**: 

Pythonのミュータブルとイミュータブルについてまとめ。

- Pythonのミュータブルとイミュータブルの違いについて。
  - ミュータブルとは変更が可能なデータ型のことを指す。リスト、タプルなんかが代表例。
  - イミュータブルとは変更が不可能なデータ型のことを指す。int、float、strなどが代表例。
- イミュータブルとは変更不可という意味だが、**変数に対する代入操作で変更不可という意味ではない**ので注意が必要。

```python
>>> a = 1
>>> a = 2
>>> a += 3
>>> a
5
>>> type(a)
<class 'int'>
```

- 上記のように、変数`a`はintなのでイミュータブルであるが、変数に対する操作で格納する値は変更されている。じゃあ何がイミュータブルなんだというと、**同一のidを指し示したままの変更は不可**という意味である。

```python
>>> a = 1
>>> id(a)
139825682166016
>>> a = 2
>>> id(a)
139825682166048
>>> a += 3
>>> a
5
>>> id(a)
139825682166144
>>> type(a)
<class 'int'>
```

- `id()`関数は[オブジェクトの識別子](https://docs.python.org/ja/3/library/functions.html#id)を返す。
- 上記の通り、見た目は変数`a`のみ登場しているのに、その識別子はそれぞれ異なっている。これは、変数`a`がその都度異なるオブジェクトを、その都度参照しているだけであることを示している。

```python
>>> a = 1
>>> b = 2
>>> c = 3
>>> hoge = [a, b, c]
>>> for h in hoge:
...   print(h + 1)
... 
2
3
4
>>> for h in hoge:
...   h = h + 2
...   print(h)
... 
3
4
5
>>> hoge
[1, 2, 3]
>>> a
1
```

- 上記は、イミュータブルなオブジェクトをミュータブルなリストの要素にした。要素に対し加算した場合、出力される結果そのものは加算された結果だが、肝心の要素側に変化はない。
- この加算された結果も新しいオブジェクトとして生成されており、変数`h`はそれらのオブジェクトを順に参照しているだけに過ぎない。よって、`for`のロープが終わったあとで`h`を参照すると、5のオブジェクトを指し示している。
- これらのことから、`for`で利用される変数`h`は新しい変数として作成され、リストの要素を順に参照する。それらの値に何かしらの処理を行った場合、それぞれが新しいオブジェクトとして生成され、そのオブジェクトを変数`h`が参照するような仕組み。
- よって、上記のようなfor文によるリストの各要素への処理を実行した場合、リストの要素そのものが変更されるわけではない。また、各要素を参照した変数（ここで言うと`h`）はループを抜けたあとだと、最後の要素に対する処理を実行した後の値（ここでは3 + 2の処理結果である5）を保持している。

```python
>>> a = 1
>>> b = 2
>>> c = 3
>>> hoge = [a, b, c]
>>> id(hoge)
4432487280
>>> for h in hoge:
...   print('{}: {}'.format(h, id(h)))
... 
1: 4430876432
2: 4430876464
3: 4430876496
>>> for h in hoge:
...   h = h + 2
...   print('{}: {}'.format(h, id(h)))
... 
3: 4430876496
4: 4430876528
5: 4430876560
>>> hoge
[1, 2, 3]
>>> for h in hoge:
...   print('{}: {}'.format(h, id(h)))
... 
1: 4430876432
2: 4430876464
3: 4430876496
>>> d = 4
>>> hoge.append(d)
>>> hoge
[1, 2, 3, 4]
>>> id(hoge)
4432487280
>>> for h in hoge:
...   print('{}: {}'.format(h, id(h)))
... 
1: 4430876432
2: 4430876464
3: 4430876496
4: 4430876528
```

- `id()`関数を使って、リストと要素の識別子を参照してみた。
- 要素に対し加算した場合、加算結果はリスト内の要素とは別のオブジェクトを参照していることが、識別子が異なることからわかる。
- もともとのリストが参照する先は変更されていないため、リストの要素は加算処理の前後で変わらない。
- よって、「リストが持つ要素に変更は加えたくないが、何かしらの処理を要素に対して行いたい」という場合は、上記のコードで実現できる。

```python
>>> fuga = [1, 2, 3]
>>> id(fuga)
4548215664
>>> for f in fuga:
...   print('{}: {}'.format(f, id(f)))
...   f += 2
...   print('{}: {}'.format(f, id(f)))
... 
1: 4546588432
3: 4546588496
2: 4546588464
4: 4546588528
3: 4546588496
5: 4546588560
>>> id(fuga)
4548215664
>>> 
```

- ちなみに、リストの要素に変数ではなく直接int型の値を格納しても、挙動は一緒。
- [このページ](http://pythontutor.com/visualize.html)でPythonを書くと、そのオブジェクトをグラフィカルに表示してくれる。見た目でわかりやすいので、オブジェクト絡みで挙動を見てみたいときは使ってみるといいかもしれない。

**思ったこと**: 

- 理屈は理屈で、やっぱり自分で動作確認のためのコードを書くのが一番の早道だと思う。
- まさに「例示は理解の試金石」ってやつか。

**リンク**

1. [オブジェクト、値、および型](https://docs.python.org/ja/3/reference/datamodel.html)
1. [pythontutor](http://pythontutor.com/visualize.html)

### 6日目: 2020年10月7日（水）

**今日の進捗**: 

Pythonで時系列データのテストデータを作成する方法についてまとめ。

- pandasとnumpyを使って時系列データのテストデータを作る方法。
- `date_range()`を使って月次や日次のデータを作る。そのデータをインデックスにして、DataFrameを生成するとテスト用の時系列データが生成できる。

```python
>>> import pandas as pd
>>> dates = pd.date_range('2020/1/1', '2020/3/31', freq='D')
>>> len(dates)
91
>>> import numpy as np
>>> df = pd.DataFrame(np.arange(len(dates) * 3).reshape(len(dates), 3), columns=['hoge', 'fuga', 'piyo'], index=dates)
>>> df.head()
            hoge  fuga  piyo
2020-01-01     0     1     2
2020-01-02     3     4     5
2020-01-03     6     7     8
2020-01-04     9    10    11
2020-01-05    12    13    14
>>> 
```

- インデックスには、生成した日付の連続値を設定する。項目列側には、`np.arange(len(dates) * 3)`で生成した`91 * 3`個のデータを、各列にそれぞれハマるように`reshape()`して格納する。列名は適当に設定。これだけで、日次のデータ群が生成できる。

```python
>>> pd.date_range('2020/1/1', '2020/1/2', freq='H')
DatetimeIndex(['2020-01-01 00:00:00', '2020-01-01 01:00:00',
               '2020-01-01 02:00:00', '2020-01-01 03:00:00',
               '2020-01-01 04:00:00', '2020-01-01 05:00:00',
               ...
               '2020-01-01 20:00:00', '2020-01-01 21:00:00',
               '2020-01-01 22:00:00', '2020-01-01 23:00:00',
               '2020-01-02 00:00:00'],
              dtype='datetime64[ns]', freq='H')
>>> pd.date_range('2020/1/1 00:00:00', '2020/1/1 01:00:00', freq='min')
DatetimeIndex(['2020-01-01 00:00:00', '2020-01-01 00:01:00',
               '2020-01-01 00:02:00', '2020-01-01 00:03:00',
               '2020-01-01 00:04:00', '2020-01-01 00:05:00',
               '2020-01-01 00:06:00', '2020-01-01 00:07:00',
                ...
               '2020-01-01 00:54:00', '2020-01-01 00:55:00',
               '2020-01-01 00:56:00', '2020-01-01 00:57:00',
               '2020-01-01 00:58:00', '2020-01-01 00:59:00',
               '2020-01-01 01:00:00'],
              dtype='datetime64[ns]', freq='T')
>>> pd.date_range('2020/1/1', '2020/3/31', freq='M')
DatetimeIndex(['2020-01-31', '2020-02-29', '2020-03-31'], dtype='datetime64[ns]', freq='M')
```

- `freq`に指定可能な値はいろいろあるが、注意が必要なのは`M`でこれは**月次**を表す。分ではないので注意。分ごとのデータを生成した場合は、`min`か`T`を指定する。

- ちなみに、上記で使っている`reshape()`は、配列の形状を変更するのに利用する。

```python
>>> np.arange(12)
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
>>> np.arange(12).reshape(4, 3)
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])
>>> np.arange(12).reshape(2, 6)
array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11]])
>>> np.arange(12).reshape(1, 12)
array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]])
>>> np.arange(12).reshape(12, 1)
array([[ 0],
       [ 1],
       [ 2],
       [ 3],
       [ 4],
       [ 5],
       [ 6],
       [ 7],
       [ 8],
       [ 9],
       [10],
       [11]])
```

- もともとの形状（ここでは1次元の12要素）から変更できるなら、どんな形状にでも変更できる。

```python
>>> np.range(12).reshape(3, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/local/lib/python3.8/site-packages/numpy/__init__.py", line 214, in __getattr__
    raise AttributeError("module {!r} has no attribute "
AttributeError: module 'numpy' has no attribute 'range'
```

- 上記のように、もともとの形状と変更先の形状で要素数が異なる（もともとの要素数は12だが、`reshape()`で指定しているのは`3, 3`の9で一致しない）場合はエラーになる。

**思ったこと**: 

- テストデータが必要なときってちょこちょこあるので、こういうコードはgistなどに上げておいてすぐ利用できるようにしておきたい。
- 分の指定が`M`だとMonth（月）と重複しちゃうってのはわかる、だから`min`があるんだなって理解はとりあえずできるしわかりやすい。それはそうと、`T`って何だろうね。minuteの語尾かな・・・。

**リンク**

1. [pandasの時系列データにおける頻度（引数freq）の指定方法](https://note.nkmk.me/python-pandas-time-series-freq/)
1. [pandas.DataFrameの構造とその作成方法](https://note.nkmk.me/python-pandas-dataframe-values-columns-index/)
1. [pandas で日時の連続値を生成し、インデックスに使う](http://ailaby.com/date_range/)

### 7日目: 2020年10月8日（木）

**今日の進捗**: 

Pythonでランダムな文字列を生成する方法について。

- Pythonでランダムな文字列を生成するプログラム。

```python
import random, string

def get_random_string(length=8, uppercase=True, lowercase=True, digits=True):
    seed_string = ''

    if uppercase:
        seed_string += string.ascii_uppercase
    if lowercase:
        seed_string += string.ascii_lowercase
    if digits:
        seed_string += string.digits
    
    if len(seed_string) > 0:
        result = ''.join([random.choice(seed_string) for i in range(length)])
    else:
        result = ''

    return result
```

- 内容は簡単で、引数で指定された内容で文字列を一度生成して、その文字列から指定された回数分1文字ランダムで抽出する。

```python
>>> import string
>>> string.ascii_lowercase
'abcdefghijklmnopqrstuvwxyz'
>>> string.ascii_uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.digits
'0123456789'
```

- `string`で始まる部分は、**文字列定数**と呼ばれている定数で、それぞれ大文字や小文字が格納されている。これらの定数を連結して抽出元の文字列を生成している。

```python
>>> get_random_string()
'2TsENwLT'
>>> get_random_string(length=100, uppercase=True, lowercase=False, digits=True)
'0LMQ5Z28CHRQUGYMLHVVQX4VJZFZZXR4OBO13AZNCN6RQ4CTLHGVOS26UH6BKSF5EQ1ZJC6MQDQO53R92JEXSQNLWVMWCUELXQ66'
```

- 実行するときは、引数を一切指定しなければ大文字小文字と数字で8文字分生成する。
- 大文字や小文字、数字の出力を抑制したい場合は`False`を指定すればいい。文字列長はデフォルトでは8文字。
- すべての文字を出力対象にしない場合は、文字列長の長さにかかわらず空文字を返す。

----

昨日の時系列データについて補足。というか機能の追加。

- 時系列データのテストデータ作成時に、各列に格納するデータは適当な値をnumpyで生成していた。が、あれだときっちり比例の関係になってしてしまうため、折れ線グラフなどに利用するには少し味気ない。
- そこで、生成したデータにランダムな値による乗算処理を行って、値に変化をつけることにする。

```python
>>> import pandas as pd
>>> import numpy as np
>>> dates = pd.date_range('2020/1/1', '2020/3/31', freq='D')
>>> COL_NUM = 3
>>> input_data = np.arange(len(dates) * COL_NUM)
>>> import random
>>> input_data = list(map(lambda x: x * round(random.random(), 2), input_data))
>>> df = pd.DataFrame(np.array(input_data).reshape(len(dates), COL_NUM), index=dates, columns=['foo', 'bar', 'baz'])
>>> df.head()
             foo    bar    baz
2020-01-01  0.00   0.87   0.38
2020-01-02  1.08   2.68   1.75
2020-01-03  0.96   3.15   4.24
2020-01-04  2.88   9.80   7.92
2020-01-05  2.52  12.74  12.46
>>> 
```

- `map()`関数で指定したリストの要素xに対し、`x * round(random.random(), 2)`という乗算処理を行う。この処理はすべての要素それぞれで`random.random()`が実行されるため、要素それぞれに乗算される値は全て異なる。

```python
>>> np.array([1, 1, 1]) * round(random.random(), 2)
array([0.16, 0.16, 0.16])
```

- なお、numpy.ndarray形式の配列に乗算処理をする場合は、すべての要素に**同一の値**で乗算される。毎回異なる値を乗算したい場合、この計算方法は使えない。逆に同じ値で計算したい場合は、見た目にもわかりやすいこの方法がおすすめ。

```python
>>> list(map(lambda x: x * round(random.random(), 2), [1, 1, 1]))
[0.53, 0.1, 0.05]
>>> list(map(lambda x: x * round(random.random(), 2), np.array([1, 1, 1])))
[0.3, 0.17, 0.27]
>>> map(lambda x: x * round(random.random(), 2), [1, 1, 1])
<map object at 0x7f2a2c4152b0>
```

- 異なる値で計算したい場合は、前述のように`map()`関数を使うことになる。この場合はnumpy.ndarrayであるかリストであるかは関係なく、同じ挙動をする。
- なお、`map()`関数の戻り値はリストなどではなく[mapオブジェクト](https://note.nkmk.me/python-map-list-iterator/)というもの。イテレータなのでfor文などで利用できるが、リストと異なりそれ単体で内容を確認できるものではない。よって、上記の例では`list()`を使ってリストに変換している。

```python
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

- ちなみに、リストに対し直接乗算処理を行うと**要素数が増える**。要素に対し計算処理が実行されるわけではないので、注意が必要。

**思ったこと**: 

- 「こういうツールとか関数欲しいなー」と思ったときに、パッと作れるくらいには慣れよう。
- 文字列定数があるおかげで、わざわざ自分で抽出元の文字列を書かなくていいのは楽。
- `random.random()`は、テストデータなんだけど「それっぽい値」にするのに便利。ただし、利用するなら`import random`が必要になるので忘れないように。

**リンク**

1. [pythonでランダム文字列の生成](https://hacknote.jp/archives/52068/)
1. [string --- 一般的な文字列操作](https://docs.python.org/ja/3/library/string.html)
1. [NumPy配列ndarrayとPython標準のリストを相互に変換](https://note.nkmk.me/python-numpy-list/)
1. [Python3のmapはリストではなくイテレータを返す](https://note.nkmk.me/python-map-list-iterator/)


### 8日目: 2020年10月9日（金）

**今日の進捗**: 

リスト内包表記の記述方法についてまとめ。

```python
[変数に行う処理 for 変数 in リストなどのイテレータ]
```

- リスト内包表記は、何かしらの処理を実行しつつ新しいリストを生成した場合に用いる。

```python
>>> [i * 3 for i in range(1, 5)]
[3, 6, 9, 12]
>>> hoge = []
>>> for i in range(1, 5):
...   hoge.append(i * 3)
... 
>>> hoge
[3, 6, 9, 12]
```

- 例として、3の倍数でリストを作成する方法を考えると上記のように記述できる。ループのもとになるイテレータは既存のものでもいいし、`range()`で生成したものでもいい。
- `append()`を利用して要素を追加する方法より、記述量が少なくて可読性がよい。表記方法も、角かっこで囲ってあって「リストが出力される」と直感的に理解しやすい。ループ部分もまんまfor文なので、こちらも理解しやすい。

```python
>>> hoge = 'foobarbaz'
>>> hoge.count('o')
2
>>> [hoge.count(s) for s in ['o', 'ba', 'oo']]
[2, 2, 1]
```

- 次の例は、ある文字列において含まれているであろう文字をリストにして、それぞれがいくつ含まれているか個数をリストで返すコード。
- `string.count()`は引数に指定された文字や文字列が、元の文字列の中で何回出現するかをカウントするメソッド。

```python
[変数に行う処理 for 変数 in イテレータ if 条件式]
```

- 処理を行う要素について任意の条件を付与したい場合は、上記のようなifがついかリスト内包表記を用いる。

```python
>>> [i ** 2 for i in range(10) if i % 2 == 0]
[0, 4, 16, 36, 64]
```

- 例として、偶数のみ2乗するリスト内包表記を書いてみた。要素のうち、2の余剰がゼロになる（偶数）という条件が成立する要素のみ対象とする、という条件を`if`部分に記述することで、処理対象の要素を限定できる。

**思ったこと**: 

- リスト内包表記はチューリング完全らしいので、やる気になればワンライナーでいろいろ（LISP実装まで）できるらしいが、いくらなんでも可読性がアレ過ぎるので用法用量を守って正しくお使いください案件。

**リンク**

1. [Pythonリスト内包表記の使い方](https://note.nkmk.me/python-list-comprehension/)
1. [リスト内包表記の活用と悪用](https://qiita.com/KTakahiro1729/items/c9cb757473de50652374)

### 9日目: 2020年10月10日（土）

**今日の進捗**: 

Pythonでpandas.DataFrameに対し統計量を取得する`describe()`を実行するときの注意点について。

- ゼロを含んだDataFrameで`describe()`を実行したい場合、**ケースによっては**一度ゼロを除外する方がいい。
- ゼロが意味を持つデータならいいが、意味を持たない（欠損値と変わらない）ようなデータの場合、ゼロを含んだ状態で統計量を出すと、本来の意味とは異なる統計量が出てきてしまう。特に最小値が必ずゼロになってしまうため、標準偏差もゼロを含んだ場合と含まない場合で差が出てくる。

```python
df.describe()
df[df > 0.0].describe()
```

- `df`がゼロを含むデータであった場合、1行目と2行目の結果は異なる。
- `df[df > 0.0]`の場合、ゼロはデータとして抽出されないためNaNになる。`describe()`は**NaNを無視する**ため、2行目は1行目のゼロを含んだ結果と異なる結果を出力する。

----

Pythonでラムダ式に複数の引数を設定する方法について。

- 単純に引数設定の際に複数の設定を記述すればいい。
- `def`による関数宣言を同様に、引数の初期設定が可能。

```python
>>> hoge = lambda a, b=2: a * b
>>> hoge(1)
2
>>> hoge(1, 3)
3
>>> hoge()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: <lambda>() missing 1 required positional argument: 'a'
>>> hoge(b=100, a=4)
400
>>> 
```

- 上記の場合、引数bに2が初期設定されているため、引数aだけ指定してやれば実行可能。引数が指定されなければエラーになるのも、`def`による関数宣言と同じ。

----

p5.jsの勉強。

なお、p5.jsの環境はCodepenでp5.jsのライブラリを参照する設定すればいい。

- p5.jsの基本中の基本。

```javascript
const W = 800;
const H = 600;

function setup(){
  createCanvas(W, H);
  
  background(255);
}

function draw(){
  ellipse(60, 60, width / 10, height / 10);
}
```

- p5.jsは`setup()`が1度だけ実行され、次に`draw()`が繰り返し実行されるという状態の遷移で動作する。
- `setup()`はその名前の通り、初期設定などで用いる。そして`setup()`内で宣言された変数は、他の関数からはアクセスできないとある。まぁ、少なくとも`let`とか使ってればJSの仕様上大丈夫だろう。
- `draw()`は自動的に繰り返し実行される。初期設定以外の実際の描画処理はこの関数の中に記述することになる。
- 上記の場合、`setup()`でCanvasが生成される。Canvasのサイズは`const`で宣言した。その後、Canvasを指定した背景色で塗りつぶす。0が真っ黒で255が真っ白。要は色指定でよくある、RGBの値で指定すればいい。
- `background()`は背景に利用する色を設定する。デフォルトは**透明**。
- 実際の描画処理は`draw()`で実行される。ここでは`ellipse()`を実行して円を描画している。
- `ellipse(x座標, y座標, 横幅, 高さ)`で描画する円を設定する。
- `draw()`関数の中で`width`と記述すると、Canvasの横のサイズを取得できる。同様に`height`と記述すると、Canvasの高さを取得できる。ここでは取得した縦横の10分の1のサイズの楕円を描画した。
- 上記のコードで一応簡単だがp5.jsの挙動がわかると思う。ただし、現状のコードでは**ちょっとした問題がある**。

```javascript
const W = 800;
const H = 600;
let position = 0;

function setup(){
  createCanvas(W, H);
  
  background(255);
}

function draw(){
  
  ellipse(60 + position, 60 + position, width / 10, height / 10);
  
  position += 2;
}
```

- 今度のコードは、楕円を描画する位置を少しずつズラしている。
- 実行してみるとわかるが、**1度描画された楕円がその後もCanvas上に残り続ける**。これが目的の描画なら問題ないが、「楕円が斜めに**移動する**」挙動を実現したい場合は、過去に描画されたシェイプは残らない方が望ましい。その仕様を満たすには、**Canvasの内容をクリア**する必要がある。

```javascript
const W = 800;
const H = 600;
let position = 0;

function setup(){
  createCanvas(W, H);
}

function draw(){
  background(255);
  
  ellipse(60 + position, 60 + position, width / 10, height / 10);
  
  position += 2;
}
```

- 背景色を設定する`background()`関数を、`setup()`関数から`draw()`関数の冒頭に移動した。これにより、`draw()`関数が実行されると、まず最初に**Canvasの内容が設定された色でリセットされる**。その後、楕円が描画される。この挙動により、楕円が斜めに移動しているように見える。
- `background()`関数は多くの場合、`draw()`関数の冒頭でCanvasの内容をリセットするのに用いられる。`setup()`関数内で利用される場合は、背景色の設定が1度でいいか、アニメーションの開始フレームの背景色を設定する場合に利用される。
- デフォルトのカラー空間は、各値が0から255の範囲のRGB。HSLでも指定が可能らしい。
- 第2引数はアルファ値で、省略可能。アルファの範囲はデフォルトで0から255。

----

マウスに追随するシェイプをp5.jsで実装する。

```javascript
const W = 800;
const H = 600;

function setup(){
  createCanvas(W, H);
}

function draw(){
  ellipse(mouseX, mouseY, width / 10, height / 10);  
}
```

- マウスカーソルを適当に動かすと、カーソルに合わせて楕円が描画される。ゴリゴリ動かすとどんどん楕円が描画される。
- `mouseX`と`mouseY`でマウスカーソルのX座標とY座標を取得できる。PCのマウス入力でなくスマートフォンなどのタッチ入力である場合は、**直近にタッチされた位置のX座標およびY座標を保持**する。

```javascript
  console.log('mouseX: ' + mouseX);
  console.log('mouseY: ' + mouseY);
```

- 上記のコードを記述することで、`mouseX`と`mouseY`の座標を出力できる。見るとわかるが、Canvasの左上を`(0, 0)`とした値で出力される。
- `draw()`関数内に`background()`がないので、シェイプが残り続けるのはさっきと同様。

```javascript
const W = 800;
const H = 600;

function setup(){
  createCanvas(W, H);
}

function draw(){
  if (mouseIsPressed) {
    fill(0);
  }
  else{
    fill(255);
  }
  
  ellipse(mouseX, mouseY, width / 10, height / 10);
  
}
```

- マウスがクリックされているか否かを判断するのは、`mouseIsPressed`を参照する。Trueであればクリック状態にある。
- `fill()`関数はシェイプの塗りつぶす色を設定する。1度設定すると、以降に描画されるすべてのシェイプに影響する。色の設定はデフォルトのカラー空間だと、0から255の範囲のRGB。引数1つで設定する場合はグレースケールになる。
- グレースケール指定の第2引数、カラー設定の第4引数はアルファ値で省略可能。アルファの範囲も、他と同様デフォルトで0から255。

**思ったこと**: 

- 統計量算出において、ゼロに意味がある場合とない場合で出力結果が意味するところが変わってくる。算出前にデータ内容を確認して「ゼロを含むことに意味があるか、またはないか」を考慮することが必要。
- p5.js面白いなー。とりあえずマウスに追随してシェイプを描画するのくらいはやってみたい・・・と思ってやってみたけど、これだけのコード量でこれができるのは楽で面白い。

**リンク**

1. [pandasのdescribeで各列の要約統計量（平均、標準偏差など）を取得](https://note.nkmk.me/python-pandas-describe/)
1. [Pythonのlambda（ラムダ式、無名関数）の使い方](https://note.nkmk.me/python-lambda-usage/)
1. [p5.js Get Started](https://p5js.org/get-started/)
1. [p5.js スピード入門](https://himco.jp/category/p5-js-%e3%82%b9%e3%83%94%e3%83%bc%e3%83%89-%e5%85%a5%e9%96%80/)

### 10日目: 2020年10月11日（日）

**今日の進捗**: 

Pythonでラムダ式を書く際の注意点について。

- ラムダ式を記述する際、任意の名前を付けるのはPEP8的にご法度なので、PEP8に準拠したLintではエラーになる。

```python
>>> tetens = lambda x: 6.11 * (10 ** (7.5 * x / (x + 237.3)))
>>> tetens(20)
23.389356843099335
```

- ここではラムダ式に`tetens`という名前をつけ、実行する際も`tetens(引数)`という記述方法で実行している。PEP8からすると、この書き方をするくらいなら「`def`で関数宣言しろよ」ということらしい。まぁ気持ちはわかる。

----

p5.jsでのシェイプ描画処理について。

- 線の描画は`line()`関数を利用する。

```javascript
W = 800;
H = 600;

function setup(){
  createCanvas(W, H);
}

function draw(){
  background(255);
  
  line(20, 20, 100, 100);
  line(110, 110, 200, 200);
  
}
```

- `line()`関数は引数に「始点のX座標、始点のY座標、終点のX座標、終点のY座標」を指定する。
- `strokeWeight()`で任意の数字を指定することで、描画する線の太さを指定できる。デフォルトの太さは1。

```javascript
  line(20, 20, 100, 100);
  strokeWeight(10);
  line(110, 110, 200, 200);
```

- 線の太さ設定は`strokeWeight()`で数字を指定すればいいが、上記のような書き方をすると最初の`line()`関数で描画した線も含めて**すべてのシェイプが太さ10に設定されてしまう**。

```javascript
  strokeWeight(1);
  line(20, 20, 100, 100);
  strokeWeight(10);
  line(110, 110, 200, 200);
```

- 各シェイプで異なる太さを設定したい場合は、**シェイプ描画の直前で太さを明記しておく**（たとえデフォルトの1であっても）ことが重要。

----

- 四角の描画は`quad()`関数を利用する。ここで言う「四角」とは正方形や長方形とは異なり、角の部分は直角じゃなくても構わない。なお、これ以降は`setup()`関数や`draw()`関数の一部を省略する（線の描画のときと同じコードなので）。

```javascript
  fill(255, 0, 0);
  strokeWeight(2);
  quad(200, 20, 300, 30, 310, 100, 210, 110);
```

- `quad()`関数は「x1, y1, x2, y2, x3, y3, x4, y4」でそれぞれ座標を指定する。
- 指定された極座標で四角を描画するため、指定の座標によってはひねったような形の四角（三角を2つ並べたような形）を描画することも可能。

----

- 三角の描画は`triangle()`関数を利用する。

```javascript
//draw triangle
  fill(0, 255, 0);
  triangle(380, 20, 440, 100, 320, 100);
```

- `triangle()`関数は「x1, y1, x2, y2, x3, y3」で座標を指定する。

----

- 長方形の描画は`rect()`関数を利用する。

```javascript
  fill(0, 0, 255);
  rect(460, 20, 100, 100);
  
  fill(20, 200, 100);
  rect(610, 20, 100, 100, 15);
```

- `rect()`関数は他のシェイプを描画する関数と異なっていて、引数が「左上のx座標、左上のy座標、幅、高さ」になっている。角の座標を個別に指定しなくていいので、単純に正方形または長方形を描画するなら`rect()`関数を利用したほうが楽。
- 第5引数以降は、角に丸みをつけるのに利用する。左上、右上、右下、左下の順でそれぞれの角の丸みを指定できる。途中で省略した場合は、直前で指定された値を引き継ぐ。上記の例だと、左上の丸みを15に指定しているので、他の角も同様に15で指定したことになる。

**思ったこと**: 

- Lintではエラーになるものの、インタプリタ形式で記述する際は簡単な関数ならむしろ`def`を書きたくないので、名前のついたラムダ式は割と便利な印象がある。まぁ動作の確認するのにちょっとだけ利用するってならいいかもしれないけど、ちゃんと書かなきゃいけないような場合はやめようね、という話。
- まぁ大抵の場合はLintに従っておけばいいよね、という気がしている。
- p5.jsに限らず、実際にシェイプを描画する場合は三角や四角よりは曲線だったりノイズだったりと、より複雑なシェイプを描画しがちだしその方が見た目がいいのだけど、やっぱり基本は抑えておくべきだよね、ってことでしっかり覚えよう。
- ただし、任意の座標で四角を描画する`quad()`関数は、「単純になんでもいいからシェイプを描画したい」場合には不適。それぞれの角を毎回指定しないといけない（まぁ何かしらの計算結果を渡せばいいかもしれないが）ので、「とりあえず」のニーズに対応するなら「左上と幅・高さの指定だけでいい」`rect()`関数の方が楽、ということになる。

**リンク**

1. [Pythonのlambda（ラムダ式、無名関数）の使い方](https://note.nkmk.me/python-lambda-usage/)
1. [2_3：p5.js 線、四角形、三角形、長方形を描く](https://himco.jp/2019/02/08/2_3%ef%bc%9ap5-js-%e7%b7%9a%e3%80%81%e5%9b%9b%e8%a7%92%e5%bd%a2%e3%80%81%e4%b8%89%e8%a7%92%e5%bd%a2%e3%80%81%e9%95%b7%e6%96%b9%e5%bd%a2%e3%82%92%e6%8f%8f%e3%81%8f/)

### 11日目: 2020年10月12日（月）

**今日の進捗**: 

pandasのDataFrameで、既存列の値を利用して新しい列を新規追加する方法について。

- DataFrameの既存列に格納されている値を使用して、何らかの計算を行って結果を新しい列に格納したい。その場合は、`DataFrame.apply()`を使ってラムダ式を`axis=1`のオプションとともに実行することで実現できる。

```python
>>> import pandas as pd
>>> import numpy as np
>>> import random
>>> input_data = np.arange(30)
>>> input_data = map(lambda x: x * round(random.random(), 1), input_data)
>>> input_data = list(input_data)
>>> len(input_data)
30
>>> df = pd.DataFrame(np.array(input_data).reshape(10, 3), columns=['foo', 'bar', 'baz'])
>>> df.head()
   foo  bar  baz
0  0.0  0.9  1.6
1  2.1  3.6  2.0
2  5.4  0.0  0.8
3  2.7  9.0  6.6
4  1.2  3.9  9.8
>>> df['hoge'] = df.apply(lambda x: x['foo'] + x['bar'] + x['baz'], axis=1)
>>> df.head()
   foo  bar  baz  hoge
0  0.0  0.9  1.6   2.5
1  2.1  3.6  2.0   7.7
2  5.4  0.0  0.8   6.2
3  2.7  9.0  6.6  18.3
4  1.2  3.9  9.8  14.9
```

- テストデータは、numpyとrandomを使って任意の値を用意する。
- `df.apply(lambda x: x['foo'] + x['bar'] + x['baz'], axis=1)`とすることで、既存列（`axis=1`のオプションで、処理対象が行であると指定している。指定しないか、`axis=0`の場合は列が対象になる）の値を使って、ラムダ式に記述した処理を**全行に対し**行う、という意味になる。
- つまり、ラムダ式の引数xには**各行が1つずつ入力**され、各行の項目列である**fooとbarとbazの値を加算しろ**、という処理になる。
- この結果はSeries形式で返ってくるので、任意の名前を付けて新規列として既存のDataFrameに追加が可能。

```python
>>> df.apply(lambda x: max(x))
foo     27.0
bar     17.6
baz     20.8
hoge    47.7
dtype: float64
```

- ちなみに`axis=1`を指定しない場合は、処理の対象が列になる。つまり、ラムダ式の引数xに**各列が1つずつ入力**される。ここの挙動が上記と異なるところ。
- 上記では`max()`を使って、各列における最大値を取得している。処理対象を列であるため、各列における最大値が出力されている。

----

matplotlibで描画したグラフに、補助線を追加する方法について。

- matplotlibで描画したグラフに、説明のためなどで補助線を描画したい場合は、水平線なら`hlines()`、垂直線なら`vlines()`を利用する。

```python
sns.lineplot(x=df.index, y=sensor_df['saturation'])
plt.hlines(y=3, xmin=df.index[0], xmax=df.index[-1], linestyles='--', colors='red')
plt.hlines(y=6, xmin=df.index[0], xmax=df.index[-1], linestyles='--', colors='red')
plt.show()
```

- もちろん、複数の線を出力することも可能。単純に描画したい数だけ、コードを書いてやればいい。

----

matplotlibで描画したグラフのX軸とY軸の幅を調査する方法について。

- matplotlibでグラフを描画した際、グラフのX軸とY軸がそれぞれどのくらいのレンジ（幅）で描画されているかを調べたい場合は、`xlim()`と`ylim()`を実行する。

```python
sns.lineplot(x=df.index, y=df['hoge'])
print(plt.xlim())
print(plt.ylim())
plt.show()
```

```console
(18107.05, 18479.95)
(1.0695084678691622, 12.550942168141958)
```

- グラフを描画する際、特に指定しなければmatplotlibが自動で、指定されたデータの最大値および最小値が十分に収まるような、適当な幅をX軸とY軸に設定しグラフを出力する。
- この際、X軸とY軸の出力幅を変えたければ`xlim(x軸の最小値, x軸の最大値)`や`ylim(y軸の最小値, y軸の最大値)`といった指定を行う。
- ところが、日付などを出力の軸にしていえる場合、その最大値や最小値の具体的な数値がわからない場合がある。データ上の最大値や最小値を参照してもよいが、例えば「出力したグラフに補助線を引きたい」という場合、補助線を引きたい座標の**具体的な数値**を指定しなければならない。日付はあくまでも**見た目のラベルであって座標ではない**ので、日付指定による補助線の座標指定はできない。
- その場合、描画されているグラフのX軸とY軸の最大値と最小値の具体的な数値を取得し、その数字に則って座標を決めることで補助線の座標を指定できる。

```python
import matplotlib.patches as patches

sns.lineplot(x=df.index, y=df['hoge'])
e = patches.Rectangle(xy=(18105, 3) , width=18470, height=3, ec='#523245', fill=True, alpha=0.3, color='r')
ax = plt.axes()
ax.add_patch(e)
plt.show()
```

- 上記では、取得した座標に則って四角を`Rectangle()`関数で描画し、グラフに出力している。

**思ったこと**: 

- 特徴量エンジニアリングなどで、既存列の値を用いて何かしらの処理を行い新規列を作成するのはよくやる手法なので覚えておきたい。
- `axis`の指定はいつもどっちがどっちだっけ、となりがち。大抵の場合デフォルトは`axis=0`で、**各列に対し処理を行う**。特徴量エンジニアリングは行ごとに一定の処理を行うので、`axis=1`を指定して**各行に対し処理を行う**。
- ちなみに長方形以外のシェイプも描画することも可能。グラフ上のある領域について塗りつぶしたい場合や一部分を強調したい場合などは、利用するといいかもしれない。

- 上記とは関係ないが、jupyter notebookをHTML化するとグラフがSVG化される。これをPNGか適当な画像ファイルにして、ダウンロードできないものか。

**リンク**

1. [pandas.DataFrame.apply](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html)
1. [Pandasで複数の列を値をもとに、新しい列を任意の関数で定義する方法](https://blog.shikoan.com/pandas-newcolumn-lambda/)
1. [Matplotlib で水平線と垂直線をプロットする方法](https://www.delftstack.com/ja/howto/matplotlib/how-to-plot-horizontal-and-vertical-line-in-matplotlib/)
1. [Matplotlibで円や長方形などの図形を描画](https://note.nkmk.me/python-matplotlib-patches-circle-rectangle/)

### 12日目: 2020年10月13日（火）

**今日の進捗**: 

![party_parrot](https://github.com/jmhobbs/cultofthepartyparrot.com/blob/master/parrots/parrot.gif)

- Party Parrotって言うのか、[お前](https://cultofthepartyparrot.com/)。そしてGitHubにリポジトリまであるのか、[お前](https://github.com/jmhobbs/cultofthepartyparrot.com)。

----

pandasl.DataFrameで差分を取る方法について。

- DataFrameのデータにおいて、データ間の差分を取得したい場合は`diff()`を使う。

```python
>>> quit()
root@25d8182164be:/workspaces/env_2020# python
Python 3.8.5 (default, Aug  4 2020, 16:24:08) 
[GCC 8.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import pandas as pd
>>> import io
>>> s = '''a,b,c
... 1,2,3
... 1,3,5
... 3,6,9
... 9,8,7
... 10,0,1
... '''
>>> df = pd.read_csv(io.StringIO(s))
>>> df
    a  b  c
0   1  2  3
1   1  3  5
2   3  6  9
3   9  8  7
4  10  0  1
>>> df.diff()
     a    b    c
0  NaN  NaN  NaN
1  0.0  1.0  2.0
2  2.0  3.0  4.0
3  6.0  2.0 -2.0
4  1.0 -8.0 -6.0
```

- 引数なしでは、行ごとに「1行前のデータと比較して、差分を各項目列ごとに取得」する。結果の1行目は全項目がNaNになっているが、これは「0行目との比較はできない」ため。

```python
>>> df.diff(2)
     a    b    c
0  NaN  NaN  NaN
1  NaN  NaN  NaN
2  2.0  4.0  6.0
3  8.0  5.0  2.0
4  7.0 -6.0 -8.0
>>> df.diff(3)
     a    b    c
0  NaN  NaN  NaN
1  NaN  NaN  NaN
2  NaN  NaN  NaN
3  8.0  6.0  4.0
4  9.0 -3.0 -4.0
>>> df.diff(-2)
     a    b    c
0 -2.0 -4.0 -6.0
1 -8.0 -5.0 -2.0
2 -7.0  6.0  8.0
3  NaN  NaN  NaN
4  NaN  NaN  NaN
>>> df.diff(-1)
     a    b    c
0  0.0 -1.0 -2.0
1 -2.0 -3.0 -4.0
2 -6.0 -2.0  2.0
3 -1.0  8.0  6.0
4  NaN  NaN  NaN
```

- 引数`periods`を指定すると、何行前のデータと差分を取るか指定できる。`2`であれば、2行前のデータを差分を取る。デフォルトでは1行前と差分を取る。

```python
>>> df.diff(axis=1)
    a     b    c
0 NaN   1.0  1.0
1 NaN   2.0  2.0
2 NaN   3.0  3.0
3 NaN  -1.0 -1.0
4 NaN -10.0  1.0
>>> df.diff(axis=0)
     a    b    c
0  NaN  NaN  NaN
1  0.0  1.0  2.0
2  2.0  3.0  4.0
3  6.0  2.0 -2.0
4  1.0 -8.0 -6.0
```
- 引数`axis`を指定すると、差分を取る方向を指定できる。デフォルトは0で、行方向に差分を取る。`axis=1`とすると、列方向に差分を取る。

- 変化率を取得したい場合は`pct_change()`を使う。

```python
>>> df.pct_change()
          a         b         c
0       NaN       NaN       NaN
1  0.000000  0.500000  0.666667
2  2.000000  1.000000  0.800000
3  2.000000  0.333333 -0.222222
4  0.111111 -1.000000 -0.857143
```

- `diff()`とは異なるのは出力が差分ではなく変化率である点だけで、使い方は`diff()`と一緒。

```python
>>> df.pct_change(2)
          a         b         c
0       NaN       NaN       NaN
1       NaN       NaN       NaN
2  2.000000  2.000000  2.000000
3  8.000000  1.666667  0.400000
4  2.333333 -1.000000 -0.888889
>>> df.pct_change(-1)
          a         b         c
0  0.000000 -0.333333 -0.400000
1 -0.666667 -0.500000 -0.444444
2 -0.666667 -0.250000  0.285714
3 -0.100000       inf  6.000000
4       NaN       NaN       NaN
```

- 引数`periods`の設定方法も一緒。マイナスが利用できるところも同じ。

```python
>>> df.pct_change(axis=1)
    a         b         c
0 NaN  1.000000  0.500000
1 NaN  2.000000  0.666667
2 NaN  1.000000  0.500000
3 NaN -0.111111 -0.125000
4 NaN -1.000000       inf
>>> df.pct_change(axis=0)
          a         b         c
0       NaN       NaN       NaN
1  0.000000  0.500000  0.666667
2  2.000000  1.000000  0.800000
3  2.000000  0.333333 -0.222222
4  0.111111 -1.000000 -0.857143
```

- 引数`axis`の設定方法も一緒。

**思ったこと**: 

- Party Parrot、何かに使いたい（何
- データの差分を取る機能って、案外使うシチュエーションがなかったりするので、使わないと忘れそう。データ的に使えそうなら積極的に使ってみよう。時系列データなんかは、逆にこれ使うの前提になるんじゃない？

**リンク**

1. [Clut of the Party Parrot](https://cultofthepartyparrot.com/)
1. [pandasで行・列の差分・変化率を取得するdiff, pct_change](https://note.nkmk.me/python-pandas-diff-pct-change/)

### 13日目: 2020年10月14日（水）

**今日の進捗**: 

pandas.DataFrameにおける欠損値の除去方法について。

- DataFrameの欠損値を含む行を削除する場合は`dropna()`を利用する。

```python
>>> import pandas as pd
>>> import io
>>> s = '''a,b,c
... 1,,3
... 4,5,6
... 7,8,
... ,,
... ,14,15
... '''
>>> df = pd.read_csv(io.StringIO(s))
>>> df
     a     b     c
0  1.0   NaN   3.0
1  4.0   5.0   6.0
2  7.0   8.0   NaN
3  NaN   NaN   NaN
4  NaN  14.0  15.0
>>> df.dropna()
     a    b    c
1  4.0  5.0  6.0
```

- 引数なしで実行した場合は、欠損値を1つでも含む行すべてを削除する。

```python
>>> df.dropna(how='all')
     a     b     c
0  1.0   NaN   3.0
1  4.0   5.0   6.0
2  7.0   8.0   NaN
4  NaN  14.0  15.0
```

- 引数`how`にallを指定した場合は、項目列すべてが欠損している行を削除する。

```python
>>> df.dropna(how='any')
     a    b    c
1  4.0  5.0  6.0
```

- 引数`how`に`any`を指定した場合は、欠損値を1つ以上含む行すべてを削除する。引数なしの場合と同じ挙動。

```python
>>> df.dropna(subset=['b'])
     a     b     c
1  4.0   5.0   6.0
2  7.0   8.0   NaN
4  NaN  14.0  15.0
>>> df.dropna(subset=['a', 'b'])
     a    b    c
1  4.0  5.0  6.0
2  7.0  8.0  NaN
>>> df.dropna(subset=['a', 'b'], how='all')
     a     b     c
0  1.0   NaN   3.0
1  4.0   5.0   6.0
2  7.0   8.0   NaN
4  NaN  14.0  15.0
>>> 
```

- 特定の項目列を対象として欠損値の有無を判断した場合は、引数`subset`に項目名をリスト形式で指定する。この場合、指定された列の**いずれかに欠損値が含まれている**行を削除する。
- 引数`subset`は引数`how`と両立でき、`subset`で項目列を指定しつつ`how`でallを指定すると指定された列の**すべてに欠損値が含まれている**行を削除する。

----

p5.jsのシステム変数について。

- システム変数とは、ここでは「p5.jsが独自かつ自動的に値を設定・保持する変数」のことを指す。システム変数と同じ名前の変数をプログラマーが作成してはいけない。

```javascript
const W = 800;
const H = 600;

function setup(){
  createCanvas(W, H);
}

function draw(){
  background(255);
  
  const TEXT_SIZE = 30;
  textSize(TEXT_SIZE);
  fill(0);
  text('width: ' + width, 10, TEXT_SIZE);
  text('height: ' + height, 10, TEXT_SIZE * 2);
  text('mouseX: ' + mouseX, 10, TEXT_SIZE * 3);
  text('mouseY: ' + mouseY, 10, TEXT_SIZE * 4);
  text('frameCount: ' + frameCount, 10, TEXT_SIZE * 5);
  text('deltaTime: ' + deltaTime, 10, TEXT_SIZE * 6);
  text('focused: ' + focused, 10, TEXT_SIZE * 7);
  text('windowWidth: ' + windowWidth, 10, TEXT_SIZE * 8);
  text('windowHeight: ' + windowHeight, 10, TEXT_SIZE * 9);
  text('getURL(): ' + getURL(), 10, TEXT_SIZE * 10);
  text('movedX: ' + movedX, 10, TEXT_SIZE * 11);
  text('movedY: ' + movedY, 10, TEXT_SIZE * 12);
  text('mosueButton: ' + mouseButton, 10, TEXT_SIZE * 13);
  text('mouseIsPressed: ' + mouseIsPressed, 10, TEXT_SIZE * 14);
  text('touched: ' + touches, 10, TEXT_SIZE * 15);
  
    
}
```

- `width`：Canvasの幅。`createCanvas()`で指定した幅が格納され、デフォルトは100。
- `height`：Canvasの高さ。`createCanvas()`で指定した高さが格納され、デフォルトは100。
- `mouseX`：マウスカーソルの水平方向の座標。
- `mouseY`：マウスカーソルの垂直方向の座標。
- `frameCount`：プログラム開始以降、表示されたフレームの数が格納される。FPSが高いほど、早く増加する。
- `deltaTime`：n番目のフレームとn+1番目のフレームの間の時間差が、ミリ秒単位で格納されている。
- `forcusd`：p5.jsの動作しているウィンドウがアクティブかどうか。
- `windowWidth`：p5.jsが動作しているウィンドウ自体の幅。Canvasのサイズとは別。
- `windowHeight`：p5.jsが動作しているウィンドウ自体の高さ。Canvasのサイズとは別。
- `getURL`：p5.jsが動作しているURLを取得する。これは正確に言うとシステム変数ではなく関数。
- `movedX`：マウスカーソルが移動したとき、水平方向の移動量を出力する。移動していなければ0。
- `movedY`：マウスカーソルが移動したとき、垂直方向の移動量を出力する。移動していなければ0。
- `mouseButton`：マウスのボタンが押されたとき、LEFT・CENTER・RIGHTのいずれかを出力する。ちなみに、ボタンから指を離してもここの表示は変わらない。これは「最後に押されたボタン」を保持し続けるため。そのため、初期状態だと空っぽ。一度でもボタンが押されたら、その情報はそのまま保持される。
- `mouseIsPressed`：マウスのボタンが押されているか否かを出力する。押されていなければFalse、押し続けている間はずっとTrueになる。
- `touched`：スマートフォンやタブレットのように、マウスポインタでなくタッチ操作するようなデバイスはこの配列に格納された座標を利用する。

----

seaborn利用時の描画調整について。

- `heatmap()`における`annot`などの文字出力において、フォントのサイズを指定する方法は、`seaborn.set(font_scale=N)`として設定する。

```python
import seaborn as sns

sns.set(font_scale=3)
```

- デフォルト設定は1。`font_scale`は、**どのくらい拡大あるいは縮小するか**というスケールの設定なので小数の設定も可能。

- グラフの描画サイズ設定は、おなじみの`pyplot.figure(figsize=(X, Y))`で設定する。

```python
import matplotlib.pyplot as plt

plt.figure(figsize=(9, 6))
sns.heatmap(df_diff.corr(), annot=True)
```

- この設定方法は`heatmap()`以外にも使える。

----

**思ったこと**: 

- 個人的には、欠損値の除外より補完するほうがシチュエーションとして多いと思うが、手法として必ず必要なものなので忘れないようにまとめておく。
- システム変数は、難しいことを考えなくても値の取得が可能（一部は設定も可能）なので、動的に変化させたい場合などは積極的に利用したい。特に、単純に`mouseX``mouseY`とだけ書いておけば、マウスや最終タッチの位置を取得してくれる変数はとても便利。インタラクティブな描画には必須だと思う。

**リンク**

1. [pandasで欠損値NaNを除外（削除）・置換（穴埋め）・抽出](https://note.nkmk.me/python-pandas-nan-dropna-fillna/)
1. [P5.js 日本語リファレンス](https://qiita.com/bit0101/items/91818244dc26c767a0fe)
1. [3_1：p5.js 変数](https://himco.jp/2019/02/09/3_1%ef%bc%9a%e5%a4%89%e6%95%b0/)
1. [How to make seaborn.heatmap larger (normal size)?](https://stackoverflow.com/questions/41519991/how-to-make-seaborn-heatmap-larger-normal-size)
1. [Auto adjust font size in seaborn heatmap](https://stackoverflow.com/questions/33104322/auto-adjust-font-size-in-seaborn-heatmap) 
1. [p5js：スマホのブラウザ上でmouseX,mouseYが使えない問題と解決法](http://zawaworks.hatenablog.com/entry/2018/01/14/012327)

### 14日目: 2020年10月15日（木）

**今日の進捗**: 

DataFrameの列名にプレフィックス（接頭辞）あるいはサフィックス（接尾辞）を追加する方法について。

- 列名にプレフィックス（接尾辞）を追加する場合は、`prefix()`を利用する。
- 列名にサフィックス（接尾辞）を追加する場合は、`suffix()`を利用する。

```python
>>> import pandas as pd
>>> import io
>>> s = '''a,b,c
... 1,2,3
... 4,5,6
... 7,8,9
... '''
>>> df = pd.read_csv(io.StringIO(s))
>>> df
   a  b  c
0  1  2  3
1  4  5  6
2  7  8  9
>>> df.add_prefix('hoge')
   hogea  hogeb  hogec
0      1      2      3
1      4      5      6
2      7      8      9
>>> df.add_suffix('foo')
   afoo  bfoo  cfoo
0     1     2     3
1     4     5     6
2     7     8     9
>>> df.add_prefix('fuga_')
   fuga_a  fuga_b  fuga_c
0       1       2       3
1       4       5       6
2       7       8       9
>>> df.add_suffix('_bar')
   a_bar  b_bar  c_bar
0      1      2      3
1      4      5      6
2      7      8      9
```

- どちらも指定された文字列をすべての列名に付与する。

```python
>>> df['b'].add_prefix('piyo_')
piyo_0    2
piyo_1    5
piyo_2    8
Name: b, dtype: int64
>>> df['a'].add_suffix('_baz')
0_baz    1
1_baz    4
2_baz    7
Name: a, dtype: int64
```

- 任意の1列のみ、プレフィックスやサフィックスを追加しようとして上記のように記述するのは**間違い**。結果を見るとわかるが、列名ではなく行名（インデックス）に追加されてしまっている。これは、DataFrameのうち1列のみを選択してしまったため、DataFrameではなく**Seriesに対し処理を行ってしまった**から。

```python
>>> df.rename(columns={'b':'b_bbbb'})
   a  b_bbbb  c
0  1       2  3
1  4       5  6
2  7       8  9
>>> df.rename(columns={'a':'a_egg', 'b':'b_spam'})
   a_egg  b_spam  c
0      1       2  3
1      4       5  6
2      7       8  9
```

- 任意の列を変更するなら`rename()`を利用した方がいい。

```python
>>> df.columns
Index(['a', 'b', 'c'], dtype='object')
>>> df.columns = ['eggs', 'ham', 'spam']
>>> df
   eggs  ham  spam
0     1    2     3
1     4    5     6
2     7    8     9
```

- すべての列名を現状と全く異なる文字列にガラッと変えたい、とかなら`columns`に直接列名を設定した方が早い。

----

p5.jsを使ってDOM要素の追加を行う。

- 任意のDOM要素を追加する場合、`createElement()`を実行する。
- DOM要素を削除する場合、`remove()`を実行する。

```javascript
let hoge;

function setup(){
  createCanvas(400, 200);
}

function draw(){
  background(255);
  
  text(frameCount, 100, 100);
  
  if (frameCount === 200) {
    hoge = createElement('h2', 'hoge');
    hoge.id('hoge');
  }
  
  if (frameCount === 400){
    hoge.remove();
    frameCount = 0;
  }
  
}
```

- 上記のコードだと、フレームカウントに応じて要素を追加したり削除したりしている。

----

- p5.jsのコードは最初、`draw()`関数内で変数`hoge`を宣言していた。このロジックだと**要素の削除ができない**。追加はできるので、h2要素がただひたすら追加されてしまう。

```javascript
function draw(){
  let hoge; // コレ

  background(255);
  
  text(frameCount, 100, 100);
  
  if (frameCount === 200) {
    hoge = createElement('h2', 'hoge');
    hoge.id('hoge');
  }
  
  if (frameCount === 400){
    hoge.remove();
    frameCount = 0;
  }
  
}
```

- 原因は、`draw()`が繰り返し呼ばれるせい。`let`を使ってブロックスコープにしていた変数`hoge`は、`draw()`の実行が終了すると同時に**格納していた内容とともに揮発してしまう**。
- フレームカウントごとに要素を追加したり削除したりするため、フレームカウント200の時点では変数`hoge`に要素の情報が格納されていたとしても、その実行が終われば要素の情報を含んだ変数が揮発してしまう。次のフレームカウント201において`draw()`が実行された時点で、変数`hoge`が**新たに宣言される**ため内容が`undefined`になる。
- この挙動は以降も同様なので、フレームカウント400の時点では変数`hoge`が宣言されていても、とっくに**要素の情報が揮発してしまっている**。よって、`undefined`では`remove()`メソッドをもっていないのでエラーになり、要素の削除ができない。
- というわけで、この問題を解消するには変数を`draw()`の外で宣言するのが一番単純な解決方法になる。

**思ったこと**: 

- あるDataFrameの値を使って別なDataFrameを作成しもともとのDataFrameに結合する際は、サフィックスなんかを使って別名にしておかないと「名前が重複している」エラーになってしまうので、列名の変更は必須。
- `draw()`が繰り返し実行されるのはわかっていたが、変数などのオブジェクトが絡んできたときの挙動までちゃんと理解してなかった。とりあえず、なにはともあれ謎は溶けたのでよかった。

**リンク**

1. [pandas.DataFrameの行名・列名の変更](https://note.nkmk.me/python-pandas-dataframe-rename/)

### 15日目: 2020年10月16日（金）

**今日の進捗**: 

matplotlibでグラフ中に図形を描画する方法について。

- matplotlibを使って、グラフ中に任意の図形を描画できる。
- `import matplotlib.patches as patches`を実行して、`patches`から下記の処理を実行しているコードもネットにある。どっちも挙動は同様。これは、例えば`pyplot.Circle()`と書いて実行したとしても、実態として`patches.Circle()`を実行するため。

```python
fig = plt.figure(figsize=(5, 5))
ax = plt.axes()

c = plt.Circle(xy=(0.4, 0.4), radius=0.3)

ax.add_patch(c)

plt.show()
```

- `Circle()`は円を描画する。`xy`で、中心の座標を定義し、`radius`で半径を定義する。`radius`のデフォルトは5。

```python
fig = plt.figure(figsize=(5, 5))
ax = plt.axes()

c = plt.Rectangle(xy=(0.5, 0.5), width=0.4, height=0.6, fc='#772001')

ax.add_patch(c)

plt.show()
```

- `Rectangle()`では長方形を描画する。`fc`は塗りつぶしの色を指定する（「fill color」あたりかな）。`fc`は他の図形でも指定できる。

```python
fig = plt.figure(figsize=(5, 5))
ax = plt.axes()

c = plt.Polygon(xy=((0.8, 0.3), (0.9, 0.9), (0.1, 0.2)))

ax.add_patch(c)

plt.show()
```

- `Polygon`は多角形を描画する。上記のように、3つの引数だと三角形をびょうがする。

```python
c = plt.Polygon(xy=((0.8, 0.3), (0.9, 0.9), (0.4, 0.6), (0.1, 0.2)))
```

- 4つの頂点を指定すれば四角形を描画する。四角形を描画する際、`Rectangle()`と異なるのは、頂点を指定するため**長方形あるいは正方形ではない四角も描画できる**こと。

```python
import matplotlib.patches as mpatches

fig = plt.figure(figsize=(5, 5))
ax = plt.axes()

c = mpatches.Ellipse(xy=(0.5, 0.5), width=0.6, height=0.4, ec='r', fc='y')

ax.add_patch(c)

plt.show()
```

- `Ellipse()`は楕円を描画する。`Ellipse()`は`pyplot`からは呼び出せなかったため、`patches`のimportを実行している。

**思ったこと**: 

- 基本的な図形については`pyplot`だけあればいいので、そちらを利用する方が早いかもしれない。とはいえ、楕円を描画するためだけに`patches`のimportを実行するのもな・・・それなら描画するときは無差別に`patches`のimportを実行するか・・・忘れそうだし・・・という感じで若干悩ましい。

**リンク**

1. [matplotlib.patches](https://matplotlib.org/api/patches_api.html#matplotlib.patches.Circle)
1. [【Matplotlib】長方形、三角形、多角形、円の図形を描画 ](https://algorithm.joho.info/programming/python/matplotlib-rectangle/)
1. [plot a circle with pyplot](https://stackoverflow.com/questions/9215658/plot-a-circle-with-pyplot)

> Just to mention: `plt.Circle(..)` directs to `matplotlib.patches.Circle()`. So a solution without pyplot would be `circle = matplotlib.patches.Circle(..); axes.add_artist(circle)`. – ImportanceOfBeingErnest Jan 17 '18 at 19:55

ということらしい。

### x日目: 2020年10月y日（z）

**今日の進捗**: 

-

**思ったこと**: 

-

**リンク**

1. [hoge]()
