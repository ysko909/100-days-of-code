# 100 Days Of Code - 学習ログ

## 2021年1月分

### 92日目: 2021年1月2日（土）

**今日の進捗**:

JavaScriptのクロージャについて。

- ちょっとイマイチよく理解しきってないが、とりあえずjsでは関数が作成されるたびにクロージャが作成される。

> クロージャは、組み合わされた（囲まれた）関数と、その周囲の状態（レキシカル環境）への参照の組み合わせです。言い換えれば、クロージャは内側の関数から外側の関数スコープへのアクセスを提供します。JavaScript では、関数が作成されるたびにクロージャが作成されます。

```javascript
function hoge (x){
  return function(y){
    return x + y;
  };
}

const add3 = hoge(3);
const add7 = hoge(7);

console.log(add3(10));
console.log(add7(10));
```

- この場合、`add3`と`add7`はそれぞれクロージャである。それぞれ**同じ定義の関数**を保有しているが、**異なる環境**を保持している。ここでいう環境とは`x`のことで、`add3`では`x`は3であり、`add7`では`x`は7である。ただし、関数の定義は`x+y`であるので`add3`と`add7`は同じ定義であると言える。

```console
13
17
```

- 同じ定義の関数を保有しており同じ引数を指定されたとしても、**保有する環境が異なるため**実行結果が異なる。

```javascript
const createCounter = function(){
  let cnt = 0;

  const displayCounter = function(){
    cnt += 1;
    console.log(cnt);
  }

  return displayCounter;
};

const counter = createCounter();

[...Array(10).keys()].forEach(i => {
  console.log('i=' + i)
  counter();
});

const counter2 = createCounter();

console.log('counter2');
counter2();
```

- 今度は上記のような関数を考える。関数内のスコープに存在するローカル変数`cnt`に対し、インクリメントして結果を返す関数を宣言したがこの実行結果はどのようになるか？

```console
i=0
1
i=1
2
i=2
3
i=3
4
i=4
5
i=5
6
i=6
7
i=7
8
i=8
9
i=9
10
counter2
1
```

- **ローカル変数でありながら複数回実行されるとカウントが増加している**ことがわかる。
- 本来、ローカル変数はその関数が実行し終われば内容が揮発してしまうため、ループ処理の回数に関わらず「1」が表示されるように思える。が、実際に動作させてみるとローカル変数（ここでは`cnt`）の内容は保持されインクリメントされていることがわかる。つまり、**ローカル変数でありながらグローバル変数のような挙動をしている**ことになる。
- クロージャを実装するメリットはまさにそこで、グローバル変数を利用しなくても状態を保持しながら処理が可能になる。
- 上記では、インクリメントする関数の定義は保持しているものの、変数`counter`は無名関数のインスタンスへの参照であり、関数`displayCounter`のインスタンスを含んでいる。関数`displayCounter`はレキシカルスコープへの参照を保持していて、変数`cnt`に対してアクセス可能。
- そんなわけで、変数`counter`はクロージャであり、変数`cnt`はクロージャ内に保持されているため参照し続けることが可能ということになる。

```javascript
class Count {
  constructor(n=0){
    this.cnt = n;
  }

  increment(){
    this.cnt += 1;
    return this.cnt;
  }

  decrement(){
    this.cnt -= 1;
    return this.cnt;

  }
}

const counter = new Count();

[...Array(10).keys()].forEach(i => {
  console.log('i=' + i);
  console.log(counter.increment());
});
```

- カウントのような動作なら、同様の挙動はクラスでも再現できる。

```console
i=0
1
i=1
2
i=2
3
i=3
4
i=4
5
i=5
6
i=6
7
i=7
8
i=8
9
i=9
10
```

- クロージャの挙動と比較すると、クラスでの実装はインスタンスで保持している変数について処理を行っているため、インクリメントすれば変数の値が増加するのは比較的理解しやすい。


**思ったこと**: 

- 正直、カウンターのような挙動ならクロージャよりクラスで定義した方が個人的には比較的理解しやすい。ただ、クラスはプロパティをプライベートにできないので、疑似的にせよプライベートな変数を実装したいシチュエーションではクロージャを利用するのはアリだと思う。
- 関数ファクトリーとして利用する場合は有用なように思えるが、上記で挙げた例だと関数に渡す引数を増やせばいいんじゃない？わざわざクロージャを使う？っていう気もするので、クラスを利用したくないし引数も増やしたくないシチュエーションでクロージャを利用することになると思うが・・・そんなシチュエーションがどれだけあるかな。
- ただ、グローバル変数をなるべく書きたくないってのは実際あるし、jsは仕様上プライベート変数を実装できないので、それらを実現するためにクロージャを使うのはアリだと思う。
- returnにfunctionが含まれていたらクロージャを疑ってみてもいいかもしれない。

**リンク** 

1. [クロージャ](https://developer.mozilla.org/ja/docs/Web/JavaScript/Closures)
1. [クラス](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes)
1. [関数を理解すればクロージャは難しくない！](https://analogic.jp/closure/)
1. [ちょっと高度にJavaScript／クロージャの基礎](https://dev.classmethod.jp/articles/javascript-closure-basic/)

### 93日目: 2021年1月3日（日）

**今日の進捗**: 

TypeScriptのチュートリアル。

- TypeScriptのオフィシャルにある[TypeScript Tooling in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)を少し改変しつつ、TypeScriptをちょっとだけ触ってみる。
- なお、環境は`npx create-react-app my-app --template typescript`で構築している。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

function greeter(person) {
    return 'Hello, ' + person;
}

function greetWithName(user = 'John Doe') {

    return greeter(user);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- チュートリアルにあるコードを拡張してTSX形式で書いた。実際は上記のコードは`yarn start`するとエラーを吐く。

```console
TypeScript error in /workspace/my-app/src/index.tsx(4,18):
Parameter 'person' implicitly has an 'any' type.  TS7006

    2 | import ReactDOM from 'react-dom';
    3 | 
  > 4 | function greeter(person) {
```

- この場合、`person`の型を明示的に指定する必要がある。

```tsx
function greeter(person: string) {
    return 'Hello, ' + person;
}
```

- 型の指定方法は`変数: 型`で指定できる。上記では`person`は文字列だよ、と指定していることになる。
- 上記の内容で変更したら`yarn start`すると正常に動作するようになる。
- このように、TypeScriptでは変数に型を指定することが求められる。

```tsx
function App() {
    return (
        <>
            <h2>{greetWithName([0, 1, 2])}</h2>
        </>
    );
}
```

- 逆に文字列ですよと指定されているにもかかわらず配列などを指定した場合は、想定している型が異なるためエラーになる。

```console
TypeScript error in /workspace/my-app/src/index.tsx(16,33):
Type 'number' is not assignable to type 'string'.  TS2322

    14 |     return (
    15 |         <>
  > 16 |             <h2>{greetWithName([0, 1, 2])}</h2>
```

- 文字列を想定しているのに数値（の配列）なんてアサインできねーよ、とエラーになった。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return 'Hello, ' + person.firstName + ' ' + person.lastName;
}

function greetWithName(user = { firstName: 'Jane', lastName: 'Doe' }) {

    return greeter(user);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- `interface`を利用すると、オブジェクトのプロパティに対しそれぞれの型が指定できる。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

class Student {
    fullName: string;
    constructor(
        public firstName: string,
        public middleInitial: string,
        public lastName: string
    ) {
        this.fullName = firstName + ' ' + middleInitial + ' ' + lastName;
    }
}

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return 'Hello, ' + person.firstName + ' ' + person.lastName;
}

function greetWithName(user = { firstName: 'Jane', lastName: 'Doe' }) {

    let student = new Student('John', 'M.', 'Doe');

    return greeter(student);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- クラスを実装してみる。
- クラスも基本的には`interface`と同様で、プロパティに対し型を設定する。
- コンストラクタの引数に`public`が付与されているが、これは**アクセス修飾子**。それと同時に、コンストラクタの引数にアクセス修飾子を付与することで、**メンバを自動的にクラス内に定義し、コンストラクタの引数によって初期化されるまでを省略することが可能**になっている。

```tsx
class Foo {
    constructor(public x:number) {
    }
}
```

- 上記のようにコンストラクタの引数にアクセス修飾子を付与した場合を考える。この場合、メンバの宣言や初期化は記述しなくても動作する。

```tsx
class Foo {
    public x: number;
    constructor(x:number) {
        this.x = x;
    }
}
```

- アクセス修飾子を付与しない場合、メンバの宣言とコンストラクタの引数による初期化を記述する必要がある。これらについては前述のとおり、コンストラクタの宣言時に引数にアクセス修飾子を付与することで省略が可能。

**思ったこと**: 

- クラスにはアクセサを記述できるがそれは次回。

**リンク** 

1. [TypeScript Tooling in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)
1. [コンストラクタを定義する](https://typescript-jp.gitbook.io/deep-dive/future-javascript/classes#konsutorakutawosuru)
1. [コンストラクタの引数を使ってプロパティを宣言](https://future-architect.github.io/typescript-guide/class.html#id4)

### 0日目: 2021年1月x日（x）

**今日の進捗**: 

- 

**思ったこと**: 

- 

**リンク** 

1. [hoge]()
