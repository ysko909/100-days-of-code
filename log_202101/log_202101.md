# 100 Days Of Code - 学習ログ

## 2021年1月分

### 92日目: 2021年1月2日（土）

**今日の進捗**:

JavaScriptのクロージャについて。

- ちょっとイマイチよく理解しきってないが、とりあえずjsでは関数が作成されるたびにクロージャが作成される。

> クロージャは、組み合わされた（囲まれた）関数と、その周囲の状態（レキシカル環境）への参照の組み合わせです。言い換えれば、クロージャは内側の関数から外側の関数スコープへのアクセスを提供します。JavaScript では、関数が作成されるたびにクロージャが作成されます。

```javascript
function hoge (x){
  return function(y){
    return x + y;
  };
}

const add3 = hoge(3);
const add7 = hoge(7);

console.log(add3(10));
console.log(add7(10));
```

- この場合、`add3`と`add7`はそれぞれクロージャである。それぞれ**同じ定義の関数**を保有しているが、**異なる環境**を保持している。ここでいう環境とは`x`のことで、`add3`では`x`は3であり、`add7`では`x`は7である。ただし、関数の定義は`x+y`であるので`add3`と`add7`は同じ定義であると言える。

```console
13
17
```

- 同じ定義の関数を保有しており同じ引数を指定されたとしても、**保有する環境が異なるため**実行結果が異なる。

```javascript
const createCounter = function(){
  let cnt = 0;

  const displayCounter = function(){
    cnt += 1;
    console.log(cnt);
  }

  return displayCounter;
};

const counter = createCounter();

[...Array(10).keys()].forEach(i => {
  console.log('i=' + i)
  counter();
});

const counter2 = createCounter();

console.log('counter2');
counter2();
```

- 今度は上記のような関数を考える。関数内のスコープに存在するローカル変数`cnt`に対し、インクリメントして結果を返す関数を宣言したがこの実行結果はどのようになるか？

```console
i=0
1
i=1
2
i=2
3
i=3
4
i=4
5
i=5
6
i=6
7
i=7
8
i=8
9
i=9
10
counter2
1
```

- **ローカル変数でありながら複数回実行されるとカウントが増加している**ことがわかる。
- 本来、ローカル変数はその関数が実行し終われば内容が揮発してしまうため、ループ処理の回数に関わらず「1」が表示されるように思える。が、実際に動作させてみるとローカル変数（ここでは`cnt`）の内容は保持されインクリメントされていることがわかる。つまり、**ローカル変数でありながらグローバル変数のような挙動をしている**ことになる。
- クロージャを実装するメリットはまさにそこで、グローバル変数を利用しなくても状態を保持しながら処理が可能になる。
- 上記では、インクリメントする関数の定義は保持しているものの、変数`counter`は無名関数のインスタンスへの参照であり、関数`displayCounter`のインスタンスを含んでいる。関数`displayCounter`はレキシカルスコープへの参照を保持していて、変数`cnt`に対してアクセス可能。
- そんなわけで、変数`counter`はクロージャであり、変数`cnt`はクロージャ内に保持されているため参照し続けることが可能ということになる。

```javascript
class Count {
  constructor(n=0){
    this.cnt = n;
  }

  increment(){
    this.cnt += 1;
    return this.cnt;
  }

  decrement(){
    this.cnt -= 1;
    return this.cnt;

  }
}

const counter = new Count();

[...Array(10).keys()].forEach(i => {
  console.log('i=' + i);
  console.log(counter.increment());
});
```

- カウントのような動作なら、同様の挙動はクラスでも再現できる。

```console
i=0
1
i=1
2
i=2
3
i=3
4
i=4
5
i=5
6
i=6
7
i=7
8
i=8
9
i=9
10
```

- クロージャの挙動と比較すると、クラスでの実装はインスタンスで保持している変数について処理を行っているため、インクリメントすれば変数の値が増加するのは比較的理解しやすい。


**思ったこと**: 

- 正直、カウンターのような挙動ならクロージャよりクラスで定義した方が個人的には比較的理解しやすい。ただ、クラスはプロパティをプライベートにできないので、疑似的にせよプライベートな変数を実装したいシチュエーションではクロージャを利用するのはアリだと思う。
- 関数ファクトリーとして利用する場合は有用なように思えるが、上記で挙げた例だと関数に渡す引数を増やせばいいんじゃない？わざわざクロージャを使う？っていう気もするので、クラスを利用したくないし引数も増やしたくないシチュエーションでクロージャを利用することになると思うが・・・そんなシチュエーションがどれだけあるかな。
- ただ、グローバル変数をなるべく書きたくないってのは実際あるし、jsは仕様上プライベート変数を実装できないので、それらを実現するためにクロージャを使うのはアリだと思う。
- returnにfunctionが含まれていたらクロージャを疑ってみてもいいかもしれない。

**リンク** 

1. [クロージャ](https://developer.mozilla.org/ja/docs/Web/JavaScript/Closures)
1. [クラス](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes)
1. [関数を理解すればクロージャは難しくない！](https://analogic.jp/closure/)
1. [ちょっと高度にJavaScript／クロージャの基礎](https://dev.classmethod.jp/articles/javascript-closure-basic/)

### 93日目: 2021年1月3日（日）

**今日の進捗**: 

TypeScriptのチュートリアル。

- TypeScriptのオフィシャルにある[TypeScript Tooling in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)を少し改変しつつ、TypeScriptをちょっとだけ触ってみる。
- なお、環境は`npx create-react-app my-app --template typescript`で構築している。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

function greeter(person) {
    return 'Hello, ' + person;
}

function greetWithName(user = 'John Doe') {

    return greeter(user);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- チュートリアルにあるコードを拡張してTSX形式で書いた。実際は上記のコードは`yarn start`するとエラーを吐く。

```console
TypeScript error in /workspace/my-app/src/index.tsx(4,18):
Parameter 'person' implicitly has an 'any' type.  TS7006

    2 | import ReactDOM from 'react-dom';
    3 | 
  > 4 | function greeter(person) {
```

- この場合、`person`の型を明示的に指定する必要がある。

```tsx
function greeter(person: string) {
    return 'Hello, ' + person;
}
```

- 型の指定方法は`変数: 型`で指定できる。上記では`person`は文字列だよ、と指定していることになる。
- 上記の内容で変更したら`yarn start`すると正常に動作するようになる。
- このように、TypeScriptでは変数に型を指定することが求められる。

```tsx
function App() {
    return (
        <>
            <h2>{greetWithName([0, 1, 2])}</h2>
        </>
    );
}
```

- 逆に文字列ですよと指定されているにもかかわらず配列などを指定した場合は、想定している型が異なるためエラーになる。

```console
TypeScript error in /workspace/my-app/src/index.tsx(16,33):
Type 'number' is not assignable to type 'string'.  TS2322

    14 |     return (
    15 |         <>
  > 16 |             <h2>{greetWithName([0, 1, 2])}</h2>
```

- 文字列を想定しているのに数値（の配列）なんてアサインできねーよ、とエラーになった。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return 'Hello, ' + person.firstName + ' ' + person.lastName;
}

function greetWithName(user = { firstName: 'Jane', lastName: 'Doe' }) {

    return greeter(user);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- `interface`を利用すると、オブジェクトのプロパティに対しそれぞれの型が指定できる。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

class Student {
    fullName: string;
    constructor(
        public firstName: string,
        public middleInitial: string,
        public lastName: string
    ) {
        this.fullName = firstName + ' ' + middleInitial + ' ' + lastName;
    }
}

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return 'Hello, ' + person.firstName + ' ' + person.lastName;
}

function greetWithName(user = { firstName: 'Jane', lastName: 'Doe' }) {

    let student = new Student('John', 'M.', 'Doe');

    return greeter(student);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- クラスを実装してみる。
- クラスも基本的には`interface`と同様で、プロパティに対し型を設定する。
- コンストラクタの引数に`public`が付与されているが、これは**アクセス修飾子**。それと同時に、コンストラクタの引数にアクセス修飾子を付与することで、**メンバを自動的にクラス内に定義し、コンストラクタの引数によって初期化されるまでを省略することが可能**になっている。

```tsx
class Foo {
    constructor(public x:number) {
    }
}
```

- 上記のようにコンストラクタの引数にアクセス修飾子を付与した場合を考える。この場合、メンバの宣言や初期化は記述しなくても動作する。

```tsx
class Foo {
    x: number;
    constructor(x:number) {
        this.x = x;
    }
}
```

- アクセス修飾子を付与しない場合、メンバの宣言とコンストラクタの引数による初期化を記述する必要がある。これらについては前述のとおり、コンストラクタの宣言時に引数にアクセス修飾子を付与することで省略が可能。
- アクセス修飾子を省略した場合は`public`扱いとなる。なので上記は`public x: number;`と記述しているのと同じ。

**思ったこと**: 

- クラスにはアクセサを記述できるがそれは次回。

**リンク** 

1. [TypeScript Tooling in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)
1. [コンストラクタを定義する](https://typescript-jp.gitbook.io/deep-dive/future-javascript/classes#konsutorakutawosuru)
1. [コンストラクタの引数を使ってプロパティを宣言](https://future-architect.github.io/typescript-guide/class.html#id4)
1. [クラス宣言](https://docs.solab.jp/typescript/class/declaration/)

### 94日目: 2021年1月4日（月）

**今日の進捗**: 

TypeScriptのアクセサについて。

- TypeScriptは、オブジェクトのメンバに対するgetter/setterを提供している。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

class Student {
    private _fullName: string;
    constructor(
        public firstName: string,
        public middleInitial: string,
        public lastName: string
    ) {
        this._fullName = firstName + ' ' + middleInitial + ' ' + lastName;
    }

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        this._fullName = newName;
    }
}

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return 'Hello, ' + person.firstName + ' ' + person.lastName;
}

function greetWithName(user = { firstName: 'Jane', lastName: 'Doe' }) {

    let student = new Student('John', 'M.', 'Doe');

    console.log(student.fullName);
    student.fullName = 'hoge fuga piyo';
    console.log(student.fullName);
    console.log(student);

    return greeter(student);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- `get fullName()`と記述するとgetter。
- `set fullName()`と記述するとsetter。値の設定時に何らかの処理を入れたい（パスワードを要求するとか）場合、setterに記述する。

```console
John M. Doe index.tsx:36
hoge fuga piyo index.tsx:38
{...}
_fullName: "hoge fuga piyo"
firstName: "John"
lastName: "Doe"
middleInitial: "M."
<prototype>: Object { … }
```

- setterによってメンバ`_fullName`は書き換わっているが、その他のメンバは元のまま。
- ちなみに他のメンバは個別に宣言していないが、コンストラクタの引数にアクセス修飾子を付与したため、メンバの宣言や初期値設定を省略している（前日の内容を参照）。

**思ったこと**: 

- `get`や`set`とだけ記述すればいいのでわかりやすい。

**リンク** 

1. [クラス](http://js.studio-kingdom.com/typescript/handbook/classes#accessors)


### 95日目: 2021年1月5日（火）

**今日の進捗**: 

SVGをPNG化するwebアプリの実装。

- いつだったか実装をあきらめていたやつが解決した。`Promise`を使って非同期処理を行うと上手くいった。

```jsx
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';

const splitSvgSource = (html) => {
    // SVGだけを抽出する関数

    let startReg = /<svg.*?\/svg>/sg;

    let result = html.match(startReg);

    if (result) {
        return result;
    } else {
        return;
    }

}

function SvgToPng() {
    // HTMLファイルの読み込みを行うコンポーネント
    // 選択されたHTMLはSVGのみ抽出し、フックに格納する。

    const [svg, setSvg] = useState([]);

    useEffect(() => {
        const f = document.getElementById('file');

        if (f === null) {
            return;
        }

        f.addEventListener('change', (e) => {

            let reader = new FileReader();
            reader.readAsText(e.target.files[0]);
            reader.onload = (() => {
                let splitedSVGSource = splitSvgSource(reader.result);
                if (splitedSVGSource) {
                    setSvg([...splitedSVGSource]);
                } else {
                    setSvg([]);
                }
            });
        })

    });

    return (
        <div>
            <form id="fileUpload">
                <input id="file" type="file" name="uploadedFile" />
            </form>

            <CountSVG key={'count'} value={svg} />

            <RenderSVG key={'render'} value={svg} />

        </div>
    );
}

function CountSVG(props) {
    // アナウンス文を表示するコンポーネント
    // HTMLがロードされていないか、SVGの含まれないHTMLがロードされた場合は、
    // SVGの含まれるHTMLのロードを要求する文面にする。

    if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {
        return (
            <div>
                <p>SVGは{props.value.length}枚です。</p>
            </div>
        );

    } else {
        return (
            <div>
                <p>SVGを含んだHTMLを選択してください。</p>
            </div>
        );
    }
}

function loadImage(src) {
    // SVGをCanvasへ描画した結果をPNGで返す関数

    const imageMagnification = 1.34;

    const reg = /(?<=<svg.+viewBox=")\d{1,}\s\d{1,}\s[0-9.]{1,}\s[0-9.]{1,}/;

    let width, height;
    let result = src.match(reg);
    [, , width, height] = result[0].split(' ');

    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        canvas.width = width * imageMagnification;
        canvas.height = height * imageMagnification;

        const ctx = canvas.getContext('2d');
        const img = new Image();

        let encoded = 'data:image/svg+xml;charset=utf-8;base64,' + btoa(unescape(encodeURIComponent(src)));

        img.src = encoded;

        img.crossOrigin = 'Anonymous';

        img.onload = () => {
            ctx.drawImage(img, 0, 0, img.width, img.height);

            let url = canvas.toDataURL();
            resolve(url);

        };
        img.onerror = (e) => reject(e);


    });
}

function RenderSVG(props) {
    // SVGとPNGをそれぞれ描画するコンポーネント

    useEffect(() => {
        if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {

            let result = [];

            const elemSvgs = document.getElementById('svgs');
            const elemPngs = document.getElementById('pngs');

            props.value.forEach((svgText, idx) => {

                loadImage(svgText).then(res => {
                    result.push(res);

                    // SVGの追加
                    elemSvgs.insertAdjacentHTML('beforeend', '<img key=img_' + idx + ' alt="" src=' +
                        ('data:image/svg+xml;charset=utf-8;base64,' + btoa(unescape(encodeURIComponent(svgText)))) + '></img>');

                    // PNGの追加
                    elemPngs.insertAdjacentHTML('beforeend', '<img key=img_' + idx + ' alt="" src=' + res + '></img>');
                }).catch(e => {
                    console.log('error: ' + e);
                });

            });

            elemSvgs.insertAdjacentHTML('beforebegin', '<h3>SVGs</h3>');
            elemPngs.insertAdjacentHTML('beforebegin', '<h3>PNGs</h3>');

        }

    });

    return (
        <>
            <div id="pngs">

            </div>

            <div id="svgs">

            </div>
        </>

    );

}

ReactDOM.render(
    <SvgToPng />,
    document.getElementById('root'),
);

```

- 今回は`Promise`を使ったが、async/awaitを利用した方がより可読性が向上すると思われる。
- 関数の戻り値が配列だったりするので、TypeScriptで実装した方が最終的にはいいかもしれない。

**思ったこと**: 

- TypeScript、勉強しなきゃ・・・。

**リンク** 

1. 特になし。

### 96日目: 2021年1月6日（水）

**今日の進捗**: 

昨日のSVGをPNG化するプログラムに機能追加した。

- PNG化した際にダウンロードリンクを追加出力する。

```jsx
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';

const splitSvgSource = (html) => {
    // SVGだけを抽出する関数

    let startReg = /<svg.*?\/svg>/sg;

    let result = html.match(startReg);

    if (result) {
        return result;
    } else {
        return;
    }

}

function SvgToPng() {
    // HTMLファイルの読み込みを行うコンポーネント
    // 選択されたHTMLはSVGのみ抽出し、フックに格納する。

    const [svg, setSvg] = useState([]);

    useEffect(() => {
        const f = document.getElementById('file');

        if (f === null) {
            return;
        }

        f.addEventListener('change', (e) => {

            let reader = new FileReader();
            reader.readAsText(e.target.files[0]);
            reader.onload = (() => {

                let splitedSVGSource = splitSvgSource(reader.result);
                if (splitedSVGSource) {
                    setSvg([...splitedSVGSource]);
                } else {
                    setSvg([]);
                }
            });

            const fileUploaderElem = document.getElementById('fileUpload');
            fileUploaderElem.remove();
        })

    });

    return (
        <>
            <form id="fileUpload">
                <input id="file" type="file" name="uploadedFile" />
            </form>

            <CountSVG key={'count'} value={svg} />

            <RenderSVG key={'render'} value={svg} />

        </>
    );
}

function CountSVG(props) {
    // アナウンス文を表示するコンポーネント
    // HTMLがロードされていないか、SVGの含まれないHTMLがロードされた場合は、
    // SVGの含まれるHTMLのロードを要求する文面にする。

    let notice = 'SVGを含んだHTMLを選択してください。';

    if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {
        notice = 'SVGは' + props.value.length + '枚です。';
    }

    return (
        <>
            <p>{notice}</p>
        </>
    );

}

function loadImage(src) {
    // SVGをCanvasへ描画した結果をPNGで返す関数

    const imageMagnification = 1.34;

    const reg = /(?<=<svg.+viewBox=")\d{1,}\s\d{1,}\s[0-9.]{1,}\s[0-9.]{1,}/;

    let width, height;
    let result = src.match(reg);
    [, , width, height] = result[0].split(' ');

    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        canvas.width = width * imageMagnification;
        canvas.height = height * imageMagnification;

        const ctx = canvas.getContext('2d');
        const img = new Image();

        let encoded = 'data:image/svg+xml;charset=utf-8;base64,' + btoa(unescape(encodeURIComponent(src)));

        img.src = encoded;

        img.crossOrigin = 'Anonymous';

        img.onload = () => {
            ctx.drawImage(img, 0, 0, img.width, img.height);

            let url = canvas.toDataURL();
            resolve(url);

        };

        img.onerror = (e) => reject(e);

    });
}

function RenderSVG(props) {
    // SVGとPNGをそれぞれ描画するコンポーネント

    useEffect(() => {

        const elemSvgs = document.getElementById('svgs');
        const elemPngs = document.getElementById('pngs');

        if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {

            let result = [];

            props.value.forEach((svgText, idx) => {

                loadImage(svgText).then(res => {
                    result.push(res);

                    // SVGの追加
                    elemSvgs.insertAdjacentHTML('beforeend', '<img key=img_' + idx + ' alt="" src=' +
                        ('data:image/svg+xml;charset=utf-8;base64,' + btoa(unescape(encodeURIComponent(svgText)))) + '></img>');

                    // PNGの追加
                    elemPngs.insertAdjacentHTML('beforeend', '<img key=img_' + idx + ' alt="" src=' + res + '></img>');
                    // ダウンロードリンクを追加
                    elemPngs.insertAdjacentHTML('beforeend', '<a key=url_' + idx + ' href=' + res + ' download="image.png">download</a>');
                }).catch(e => {
                    console.log('error: ' + e);
                });

            });

            elemSvgs.insertAdjacentHTML('afterbegin', '<h3>SVGs</h3>');
            elemPngs.insertAdjacentHTML('afterbegin', '<h3>PNGs</h3>');

        } else {
            while (elemPngs.firstChild) {
                elemPngs.removeChild(elemPngs.firstChild);
            }
            while (elemSvgs.firstChild) {
                elemSvgs.removeChild(elemSvgs.firstChild);
            }

        }

    });

    return (
        <>
            <div id="pngs">

            </div>

            <div id="svgs">

            </div>
        </>

    );

}

ReactDOM.render(
    <SvgToPng />,
    document.getElementById('root'),
);

```

- PNG化した際にimgタグに利用しているURLを、ダウンロードリンクとしてaタグで表示する。これにより、右クリックメニューからコピーする場合と個別に画像ファイルだけダウンロードする場合で、使い分けができる。まぁ、大抵は右クリックメニューからコピーする方が話が早いだろうが。
- 上記の機能追加とともに、ところどころのコードを修正した。`CountSVG`コンポーネントの部分で、`return`を一本化して変数出力するようなコードのみに修正し、状態が変わったら変数の内容だけ変更するようなコードとした。
- 一度ファイルを読み込んだら、ファイルのローダーを削除するよう修正した。これは、ファイルを読み込んだ後に別のファイルを読み込もうとすると、もともと表示されている内容が残ったまま新しい内容を描画しようとしたり、「PNGs」「SVGs」などの文言が複数出現したり、重複して表示したりとバグった挙動をしていたため。本来は、一度表示されている内容を削除するなどして初期化してから、新しく読み込まれたファイルについて処理すればいいのだが、その場合の再レンダリング方法がちょっと調べただけだと出てこなかった。そのため、ちょっと乱暴だが対処療法としてファイルローダー機能を削除することで、2度目以降のファイル読み込みを実行させないようにした。

**思ったこと**: 

- ファイル読み込みを複数回行っても、正常に行えるような実装はどうすればいいんだろう。とりあえず今は、対症療法でどうにかしているが・・・。

**リンク** 

1. [Node.removeChild](https://developer.mozilla.org/ja/docs/Web/API/Node/removeChild)
1. [ChildNode.remove](https://developer.mozilla.org/ja/docs/Web/API/ChildNode/remove)

### 97日目: 2021年1月7日（木）

**今日の進捗**: 

p5.jsで作ったCanvasについて、画面サイズが変更された場合でも追随するような実装。

- `windowWidth`と`windowHeight`を使ってウィンドウサイズを取得し、そのサイズでCanvasを生成する。
- ウィンドウサイズが変更されると、`windowResized()`という関数が実行される。リファレンスは[ここ](https://p5js.org/reference/#/p5/resizeCanvas)。

```javascript
let halfWidth, halfHeight;

setup=()=>{
  createCanvas(windowWidth, windowHeight);
}

draw=()=>{
  background(0);

  halfWidth = windowWidth / 2;
  halfHeight = windowHeight / 2;

  fill(255);
  rect(halfWidth, halfHeight, 100, 100);
  
}

windowResized=()=>{
  resizeCanvas(windowWidth, windowHeight);
}
```

- `draw()`内で画面サイズを逐次取得し、その半分の値を使ってオブジェクトを描画する。ウィンドウサイズが変更されても、都度Canvasごとレンダリングされオブジェクトも指定の位置に存在し続ける。

**思ったこと**: 

- 画面サイズいっぱいに出力することはあっても、スマートフォンなんかだと顕著だがそもそも「ウィンドウサイズを変更する」という前提がないデバイスもあるので、あくまでPC用ということになる。

**リンク** 

1. [resizeCanvas](https://p5js.org/reference/#/p5/resizeCanvas)
2. [windowResized](https://p5js.org/reference/#/p5/windowResized)
3. [【Canvas/p5.js】解決。canvas要素を可変(window幅やwindowの50%,中央寄せ)などに動的にする方法](https://kenjimorita.jp/canvas_windowresize_window_center/)

### 98日目: 2021年1月8日（金）

**今日の進捗**:

p5.jsでphotoshopの「雲模様」みないなテクスチャを作る。

- photoshopには、「雲模様」という雲とか湯気っぽいモヤを生成できるフィルターがある。テクスチャのでき具合から察するに、パーリンノイズからパターンを生成しているような気がしたので「p5.jsでも似たようなのできるんじゃね？」と思って作ってみた。

```javascript
let seed = 0;
let cellSize = 5;

setup=()=>{
  createCanvas(400, 400);
  
  colorMode(HSB, 100, 100, 100, 100);
  strokeWeight(cellSize * 10);
}

draw=()=>{
  background(0, 0, 0, 30);
  
    for (let w=0; w<=width; w+=cellSize){ 
      for (let h=0; h<=height; h+=cellSize){
      let n = noise(w * 0.015 + seed, h * 0.01 + seed, seed);
      let brightness = round(n * 45);
      
      stroke(95, 100, brightness, 100);
      if (brightness % 3 === 0){
        point(w, h);  
      }
      
    };
  };
  
  seed += 0.01;
}
```

- カラーモードをHSBにしているのは、brightnessを調節したかったため。単純にグレースケールで雲模様を生成するなら、RGBのままでいい。
- パーリンノイズを生成する部分のリテラルは、「黒地に赤いモヤがかかる」ようなテクスチャを生成したかったためで、赤分を多くするにはここのリテラルを調節する必要がある。
- `seed`に加算する値を変化させると、雲模様の変化する速度が変わる。

**思ったこと**: 

- 案外簡単にできたが、やっぱりちょっと処理が重め。

**リンク** 

1. [point](https://p5js.org/reference/#/p5/point)
1. [パーリンノイズでマーブル模様](http://30min-processing.hatenablog.com/entry/2016/07/24/000000)

### 99日目: 2021年1月9日（土）

**今日の進捗**: 

SVGをPNG化するJavaScriptについて、`insertAdjacentHTML`を使わずReactの関数コンポーネントでレンダーするよう修正してみた。

- `insertAdjacentHTML`を使わない理由は、SVGが含まれたHTMLを読み込んだ後にSVGのないHTMLを読み込んだときの処理が面倒だったため。一度`insertAdjacentHTML`で追加したDOM要素を削除するくらいなら、stateとして連動させればいいと思ったのだ。

```javascript
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';

const splitSvgSource = (html) => {
    // SVGだけを抽出する関数

    let startReg = /<svg.*?\/svg>/sg;

    let result = html.match(startReg);

    return new Promise((resolve, reject) => {
        if (result) {
            resolve(result);
        } else {
            resolve([]);
        }
    });

}

function SvgToPng() {
    // HTMLファイルの読み込みを行うコンポーネント
    // 選択されたHTMLはSVGのみ抽出し、フックに格納する。

    const [svg, setSvg] = useState([]);

    useEffect(() => {
        const f = document.getElementById('file');

        if (f === null) {
            return;
        }

        f.addEventListener('change', (e) => {

            let reader = new FileReader();
            reader.readAsText(e.target.files[0]);
            reader.onload = (async () => {

                let splitedSVGSource = await splitSvgSource(reader.result);

                if (splitedSVGSource) {
                    setSvg([...splitedSVGSource]);
                } else {
                    setSvg([]);
                }

            });

        })

    }, [svg]);

    return (
        <>
            <form id="fileUpload">
                <input id="file" type="file" name="uploadedFile" />
            </form>

            <CountSVG value={svg} />

            <RenderImage value={svg} />

        </>
    );
}

function CountSVG(props) {
    // アナウンス文を表示するコンポーネント
    // HTMLがロードされていないか、SVGの含まれないHTMLがロードされた場合は、
    // SVGの含まれるHTMLのロードを要求する文面にする。

    let notice;

    if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {
        notice = 'SVGは' + props.value.length + '枚です。';
    } else {
        notice = 'SVGを含んだHTMLを選択してください。';
    }

    return (
        <>
            <p>{notice}</p>
        </>
    );

}

function loadImage(src) {
    // SVGをCanvasへ描画した結果をPNGで返す関数

    const imageMagnification = 1.34;

    const reg = /(?<=<svg.+viewBox=")\d{1,}\s\d{1,}\s[0-9.]{1,}\s[0-9.]{1,}/;

    let width, height;
    let result = src.match(reg);
    [, , width, height] = result[0].split(' ');

    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        canvas.width = width * imageMagnification;
        canvas.height = height * imageMagnification;

        const ctx = canvas.getContext('2d');
        const img = new Image();

        let encoded = 'data:image/svg+xml;charset=utf-8;base64,' + btoa(unescape(encodeURIComponent(src)));

        img.src = encoded;

        img.crossOrigin = 'Anonymous';

        img.onload = () => {
            ctx.drawImage(img, 0, 0, img.width, img.height);

            let url = canvas.toDataURL();
            resolve(url);

            canvas.remove();

        };

        img.onerror = (e) => reject(e);

    });
}

const RenderPngAndDownloadLink = (props) => {

    let pngIndex = props.id + 1
    let fileName = 'image_' + pngIndex + '.png';

    return (
        <>
            <h4>{pngIndex}.</h4>
            <img alt="" src={props.png}></img>
            <a href={props.png} download={fileName}>download</a>
        </>
    );
}

function RenderImage(props) {
    const [pngs, setPngs] = useState([]);
    // SVGとPNGをそれぞれ描画するコンポーネント

    useEffect(() => {

        if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {

            Promise.all(props.value.map(svgText => loadImage(svgText))
            ).then(pngs => {
                let pngsWithImageTag = pngs.map((png, idx) => {
                    const RenderPngIndex = 'png_index_' + idx;
                    return (<RenderPngAndDownloadLink key={RenderPngIndex} id={idx} png={png} />);
                });

                setPngs([...pngsWithImageTag]);
            });

        } else {

            setPngs([]);
        }

        return () => console.log('clean up');

    }, [props.value]);

    return (
        <>
            <div id="pngs">
                {pngs}
            </div>

            <div id="svgs">

            </div>
        </>

    );

}

ReactDOM.render(
    <SvgToPng />,
    document.getElementById('root'),
);


```

- PNG化したSVGはダウンロードリンクとともに表示するため、見た目には前回と変わっていない。
- stateを利用し、stateの内容をそのままレンダリングするようなロジックにしたため、プログラムの見通しは良くなったかと思う。記述量も減っている。
- 反面、`useEffect()`などで第2引数を指定しないと、レンダリングがループするようなこともあった。

**思ったこと**: 

- まあまあ難産だった。特に、レンダリングがループするところとか苦労した。`useEffect()`の第2引数にオブジェクトを指定することで、レンダリングがループする現象は回避した。
- `map()`は返す値の順番は保証しても、コールバック関数の実行の順序は保証しないそうだ。

**リンク** 

1. [ステートフックの利用法](https://ja.reactjs.org/docs/hooks-state.html)
1. [フック API リファレンス](https://ja.reactjs.org/docs/hooks-reference.html)
1. [React Hooks useState の setStateの反映タイミング](https://teratail.com/questions/204921)
1. [Promise.all()](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)
1. [関数型Reactコンポーネントでレンダリングと副作用Hookが実行されるタイミング](https://www.hypertextcandy.com/when-hook-is-called)
1. [JavaScriptでPromiseの配列を直列に実行する](https://www.koheiando.com/tech/node-js/35)
1. [Array.prototype.map()](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

### 0日目: 2021年1月x日（x）

**今日の進捗**: 

- 

**思ったこと**: 

- 

**リンク** 

1. [hoge]()
