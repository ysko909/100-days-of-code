# 100 Days Of Code - 学習ログ

## 2021年1月分

### 92日目: 2021年1月2日（土）

**今日の進捗**:

JavaScriptのクロージャについて。

- ちょっとイマイチよく理解しきってないが、とりあえずjsでは関数が作成されるたびにクロージャが作成される。

> クロージャは、組み合わされた（囲まれた）関数と、その周囲の状態（レキシカル環境）への参照の組み合わせです。言い換えれば、クロージャは内側の関数から外側の関数スコープへのアクセスを提供します。JavaScript では、関数が作成されるたびにクロージャが作成されます。

```javascript
function hoge (x){
  return function(y){
    return x + y;
  };
}

const add3 = hoge(3);
const add7 = hoge(7);

console.log(add3(10));
console.log(add7(10));
```

- この場合、`add3`と`add7`はそれぞれクロージャである。それぞれ**同じ定義の関数**を保有しているが、**異なる環境**を保持している。ここでいう環境とは`x`のことで、`add3`では`x`は3であり、`add7`では`x`は7である。ただし、関数の定義は`x+y`であるので`add3`と`add7`は同じ定義であると言える。

```console
13
17
```

- 同じ定義の関数を保有しており同じ引数を指定されたとしても、**保有する環境が異なるため**実行結果が異なる。

```javascript
const createCounter = function(){
  let cnt = 0;

  const displayCounter = function(){
    cnt += 1;
    console.log(cnt);
  }

  return displayCounter;
};

const counter = createCounter();

[...Array(10).keys()].forEach(i => {
  console.log('i=' + i)
  counter();
});

const counter2 = createCounter();

console.log('counter2');
counter2();
```

- 今度は上記のような関数を考える。関数内のスコープに存在するローカル変数`cnt`に対し、インクリメントして結果を返す関数を宣言したがこの実行結果はどのようになるか？

```console
i=0
1
i=1
2
i=2
3
i=3
4
i=4
5
i=5
6
i=6
7
i=7
8
i=8
9
i=9
10
counter2
1
```

- **ローカル変数でありながら複数回実行されるとカウントが増加している**ことがわかる。
- 本来、ローカル変数はその関数が実行し終われば内容が揮発してしまうため、ループ処理の回数に関わらず「1」が表示されるように思える。が、実際に動作させてみるとローカル変数（ここでは`cnt`）の内容は保持されインクリメントされていることがわかる。つまり、**ローカル変数でありながらグローバル変数のような挙動をしている**ことになる。
- クロージャを実装するメリットはまさにそこで、グローバル変数を利用しなくても状態を保持しながら処理が可能になる。
- 上記では、インクリメントする関数の定義は保持しているものの、変数`counter`は無名関数のインスタンスへの参照であり、関数`displayCounter`のインスタンスを含んでいる。関数`displayCounter`はレキシカルスコープへの参照を保持していて、変数`cnt`に対してアクセス可能。
- そんなわけで、変数`counter`はクロージャであり、変数`cnt`はクロージャ内に保持されているため参照し続けることが可能ということになる。

```javascript
class Count {
  constructor(n=0){
    this.cnt = n;
  }

  increment(){
    this.cnt += 1;
    return this.cnt;
  }

  decrement(){
    this.cnt -= 1;
    return this.cnt;

  }
}

const counter = new Count();

[...Array(10).keys()].forEach(i => {
  console.log('i=' + i);
  console.log(counter.increment());
});
```

- カウントのような動作なら、同様の挙動はクラスでも再現できる。

```console
i=0
1
i=1
2
i=2
3
i=3
4
i=4
5
i=5
6
i=6
7
i=7
8
i=8
9
i=9
10
```

- クロージャの挙動と比較すると、クラスでの実装はインスタンスで保持している変数について処理を行っているため、インクリメントすれば変数の値が増加するのは比較的理解しやすい。


**思ったこと**: 

- 正直、カウンターのような挙動ならクロージャよりクラスで定義した方が個人的には比較的理解しやすい。ただ、クラスはプロパティをプライベートにできないので、疑似的にせよプライベートな変数を実装したいシチュエーションではクロージャを利用するのはアリだと思う。
- 関数ファクトリーとして利用する場合は有用なように思えるが、上記で挙げた例だと関数に渡す引数を増やせばいいんじゃない？わざわざクロージャを使う？っていう気もするので、クラスを利用したくないし引数も増やしたくないシチュエーションでクロージャを利用することになると思うが・・・そんなシチュエーションがどれだけあるかな。
- ただ、グローバル変数をなるべく書きたくないってのは実際あるし、jsは仕様上プライベート変数を実装できないので、それらを実現するためにクロージャを使うのはアリだと思う。
- returnにfunctionが含まれていたらクロージャを疑ってみてもいいかもしれない。

**リンク** 

1. [クロージャ](https://developer.mozilla.org/ja/docs/Web/JavaScript/Closures)
1. [クラス](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes)
1. [関数を理解すればクロージャは難しくない！](https://analogic.jp/closure/)
1. [ちょっと高度にJavaScript／クロージャの基礎](https://dev.classmethod.jp/articles/javascript-closure-basic/)

### 0日目: 2021年1月x日（x）

**今日の進捗**: 

- 

**思ったこと**: 

- 

**リンク** 

1. [hoge]()
