# 100 Days Of Code - 学習ログ

## 2021年1月分

### 92日目: 2021年1月2日（土）

**今日の進捗**:

JavaScriptのクロージャについて。

- ちょっとイマイチよく理解しきってないが、とりあえずjsでは関数が作成されるたびにクロージャが作成される。

> クロージャは、組み合わされた（囲まれた）関数と、その周囲の状態（レキシカル環境）への参照の組み合わせです。言い換えれば、クロージャは内側の関数から外側の関数スコープへのアクセスを提供します。JavaScript では、関数が作成されるたびにクロージャが作成されます。

```javascript
function hoge (x){
  return function(y){
    return x + y;
  };
}

const add3 = hoge(3);
const add7 = hoge(7);

console.log(add3(10));
console.log(add7(10));
```

- この場合、`add3`と`add7`はそれぞれクロージャである。それぞれ**同じ定義の関数**を保有しているが、**異なる環境**を保持している。ここでいう環境とは`x`のことで、`add3`では`x`は3であり、`add7`では`x`は7である。ただし、関数の定義は`x+y`であるので`add3`と`add7`は同じ定義であると言える。

```console
13
17
```

- 同じ定義の関数を保有しており同じ引数を指定されたとしても、**保有する環境が異なるため**実行結果が異なる。

```javascript
const createCounter = function(){
  let cnt = 0;

  const displayCounter = function(){
    cnt += 1;
    console.log(cnt);
  }

  return displayCounter;
};

const counter = createCounter();

[...Array(10).keys()].forEach(i => {
  console.log('i=' + i)
  counter();
});

const counter2 = createCounter();

console.log('counter2');
counter2();
```

- 今度は上記のような関数を考える。関数内のスコープに存在するローカル変数`cnt`に対し、インクリメントして結果を返す関数を宣言したがこの実行結果はどのようになるか？

```console
i=0
1
i=1
2
i=2
3
i=3
4
i=4
5
i=5
6
i=6
7
i=7
8
i=8
9
i=9
10
counter2
1
```

- **ローカル変数でありながら複数回実行されるとカウントが増加している**ことがわかる。
- 本来、ローカル変数はその関数が実行し終われば内容が揮発してしまうため、ループ処理の回数に関わらず「1」が表示されるように思える。が、実際に動作させてみるとローカル変数（ここでは`cnt`）の内容は保持されインクリメントされていることがわかる。つまり、**ローカル変数でありながらグローバル変数のような挙動をしている**ことになる。
- クロージャを実装するメリットはまさにそこで、グローバル変数を利用しなくても状態を保持しながら処理が可能になる。
- 上記では、インクリメントする関数の定義は保持しているものの、変数`counter`は無名関数のインスタンスへの参照であり、関数`displayCounter`のインスタンスを含んでいる。関数`displayCounter`はレキシカルスコープへの参照を保持していて、変数`cnt`に対してアクセス可能。
- そんなわけで、変数`counter`はクロージャであり、変数`cnt`はクロージャ内に保持されているため参照し続けることが可能ということになる。

```javascript
class Count {
  constructor(n=0){
    this.cnt = n;
  }

  increment(){
    this.cnt += 1;
    return this.cnt;
  }

  decrement(){
    this.cnt -= 1;
    return this.cnt;

  }
}

const counter = new Count();

[...Array(10).keys()].forEach(i => {
  console.log('i=' + i);
  console.log(counter.increment());
});
```

- カウントのような動作なら、同様の挙動はクラスでも再現できる。

```console
i=0
1
i=1
2
i=2
3
i=3
4
i=4
5
i=5
6
i=6
7
i=7
8
i=8
9
i=9
10
```

- クロージャの挙動と比較すると、クラスでの実装はインスタンスで保持している変数について処理を行っているため、インクリメントすれば変数の値が増加するのは比較的理解しやすい。


**思ったこと**: 

- 正直、カウンターのような挙動ならクロージャよりクラスで定義した方が個人的には比較的理解しやすい。ただ、クラスはプロパティをプライベートにできないので、疑似的にせよプライベートな変数を実装したいシチュエーションではクロージャを利用するのはアリだと思う。
- 関数ファクトリーとして利用する場合は有用なように思えるが、上記で挙げた例だと関数に渡す引数を増やせばいいんじゃない？わざわざクロージャを使う？っていう気もするので、クラスを利用したくないし引数も増やしたくないシチュエーションでクロージャを利用することになると思うが・・・そんなシチュエーションがどれだけあるかな。
- ただ、グローバル変数をなるべく書きたくないってのは実際あるし、jsは仕様上プライベート変数を実装できないので、それらを実現するためにクロージャを使うのはアリだと思う。
- returnにfunctionが含まれていたらクロージャを疑ってみてもいいかもしれない。

**リンク** 

1. [クロージャ](https://developer.mozilla.org/ja/docs/Web/JavaScript/Closures)
1. [クラス](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Classes)
1. [関数を理解すればクロージャは難しくない！](https://analogic.jp/closure/)
1. [ちょっと高度にJavaScript／クロージャの基礎](https://dev.classmethod.jp/articles/javascript-closure-basic/)

### 93日目: 2021年1月3日（日）

**今日の進捗**: 

TypeScriptのチュートリアル。

- TypeScriptのオフィシャルにある[TypeScript Tooling in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)を少し改変しつつ、TypeScriptをちょっとだけ触ってみる。
- なお、環境は`npx create-react-app my-app --template typescript`で構築している。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

function greeter(person) {
    return 'Hello, ' + person;
}

function greetWithName(user = 'John Doe') {

    return greeter(user);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- チュートリアルにあるコードを拡張してTSX形式で書いた。実際は上記のコードは`yarn start`するとエラーを吐く。

```console
TypeScript error in /workspace/my-app/src/index.tsx(4,18):
Parameter 'person' implicitly has an 'any' type.  TS7006

    2 | import ReactDOM from 'react-dom';
    3 | 
  > 4 | function greeter(person) {
```

- この場合、`person`の型を明示的に指定する必要がある。

```tsx
function greeter(person: string) {
    return 'Hello, ' + person;
}
```

- 型の指定方法は`変数: 型`で指定できる。上記では`person`は文字列だよ、と指定していることになる。
- 上記の内容で変更したら`yarn start`すると正常に動作するようになる。
- このように、TypeScriptでは変数に型を指定することが求められる。

```tsx
function App() {
    return (
        <>
            <h2>{greetWithName([0, 1, 2])}</h2>
        </>
    );
}
```

- 逆に文字列ですよと指定されているにもかかわらず配列などを指定した場合は、想定している型が異なるためエラーになる。

```console
TypeScript error in /workspace/my-app/src/index.tsx(16,33):
Type 'number' is not assignable to type 'string'.  TS2322

    14 |     return (
    15 |         <>
  > 16 |             <h2>{greetWithName([0, 1, 2])}</h2>
```

- 文字列を想定しているのに数値（の配列）なんてアサインできねーよ、とエラーになった。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return 'Hello, ' + person.firstName + ' ' + person.lastName;
}

function greetWithName(user = { firstName: 'Jane', lastName: 'Doe' }) {

    return greeter(user);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- `interface`を利用すると、オブジェクトのプロパティに対しそれぞれの型が指定できる。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

class Student {
    fullName: string;
    constructor(
        public firstName: string,
        public middleInitial: string,
        public lastName: string
    ) {
        this.fullName = firstName + ' ' + middleInitial + ' ' + lastName;
    }
}

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return 'Hello, ' + person.firstName + ' ' + person.lastName;
}

function greetWithName(user = { firstName: 'Jane', lastName: 'Doe' }) {

    let student = new Student('John', 'M.', 'Doe');

    return greeter(student);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- クラスを実装してみる。
- クラスも基本的には`interface`と同様で、プロパティに対し型を設定する。
- コンストラクタの引数に`public`が付与されているが、これは**アクセス修飾子**。それと同時に、コンストラクタの引数にアクセス修飾子を付与することで、**メンバを自動的にクラス内に定義し、コンストラクタの引数によって初期化されるまでを省略することが可能**になっている。

```tsx
class Foo {
    constructor(public x:number) {
    }
}
```

- 上記のようにコンストラクタの引数にアクセス修飾子を付与した場合を考える。この場合、メンバの宣言や初期化は記述しなくても動作する。

```tsx
class Foo {
    x: number;
    constructor(x:number) {
        this.x = x;
    }
}
```

- アクセス修飾子を付与しない場合、メンバの宣言とコンストラクタの引数による初期化を記述する必要がある。これらについては前述のとおり、コンストラクタの宣言時に引数にアクセス修飾子を付与することで省略が可能。
- アクセス修飾子を省略した場合は`public`扱いとなる。なので上記は`public x: number;`と記述しているのと同じ。

**思ったこと**: 

- クラスにはアクセサを記述できるがそれは次回。

**リンク** 

1. [TypeScript Tooling in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)
1. [コンストラクタを定義する](https://typescript-jp.gitbook.io/deep-dive/future-javascript/classes#konsutorakutawosuru)
1. [コンストラクタの引数を使ってプロパティを宣言](https://future-architect.github.io/typescript-guide/class.html#id4)
1. [クラス宣言](https://docs.solab.jp/typescript/class/declaration/)

### 94日目: 2021年1月4日（月）

**今日の進捗**: 

TypeScriptのアクセサについて。

- TypeScriptは、オブジェクトのメンバに対するgetter/setterを提供している。

```tsx
import React from 'react';
import ReactDOM from 'react-dom';

class Student {
    private _fullName: string;
    constructor(
        public firstName: string,
        public middleInitial: string,
        public lastName: string
    ) {
        this._fullName = firstName + ' ' + middleInitial + ' ' + lastName;
    }

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        this._fullName = newName;
    }
}

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person: Person) {
    return 'Hello, ' + person.firstName + ' ' + person.lastName;
}

function greetWithName(user = { firstName: 'Jane', lastName: 'Doe' }) {

    let student = new Student('John', 'M.', 'Doe');

    console.log(student.fullName);
    student.fullName = 'hoge fuga piyo';
    console.log(student.fullName);
    console.log(student);

    return greeter(student);
}

function App() {
    return (
        <>
            <h2>{greetWithName()}</h2>
        </>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root'),
);

```

- `get fullName()`と記述するとgetter。
- `set fullName()`と記述するとsetter。値の設定時に何らかの処理を入れたい（パスワードを要求するとか）場合、setterに記述する。

```console
John M. Doe index.tsx:36
hoge fuga piyo index.tsx:38
{...}
_fullName: "hoge fuga piyo"
firstName: "John"
lastName: "Doe"
middleInitial: "M."
<prototype>: Object { … }
```

- setterによってメンバ`_fullName`は書き換わっているが、その他のメンバは元のまま。
- ちなみに他のメンバは個別に宣言していないが、コンストラクタの引数にアクセス修飾子を付与したため、メンバの宣言や初期値設定を省略している（前日の内容を参照）。

**思ったこと**: 

- `get`や`set`とだけ記述すればいいのでわかりやすい。

**リンク** 

1. [クラス](http://js.studio-kingdom.com/typescript/handbook/classes#accessors)


### 95日目: 2021年1月5日（火）

**今日の進捗**: 

SVGをPNG化するwebアプリの実装。

- いつだったか実装をあきらめていたやつが解決した。`Promise`を使って非同期処理を行うと上手くいった。

```jsx
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';

const splitSvgSource = (html) => {
    // SVGだけを抽出する関数

    let startReg = /<svg.*?\/svg>/sg;

    let result = html.match(startReg);

    if (result) {
        return result;
    } else {
        return;
    }

}

function SvgToPng() {
    // HTMLファイルの読み込みを行うコンポーネント
    // 選択されたHTMLはSVGのみ抽出し、フックに格納する。

    const [svg, setSvg] = useState([]);

    useEffect(() => {
        const f = document.getElementById('file');

        if (f === null) {
            return;
        }

        f.addEventListener('change', (e) => {

            let reader = new FileReader();
            reader.readAsText(e.target.files[0]);
            reader.onload = (() => {
                let splitedSVGSource = splitSvgSource(reader.result);
                if (splitedSVGSource) {
                    setSvg([...splitedSVGSource]);
                } else {
                    setSvg([]);
                }
            });
        })

    });

    return (
        <div>
            <form id="fileUpload">
                <input id="file" type="file" name="uploadedFile" />
            </form>

            <CountSVG key={'count'} value={svg} />

            <RenderSVG key={'render'} value={svg} />

        </div>
    );
}

function CountSVG(props) {
    // アナウンス文を表示するコンポーネント
    // HTMLがロードされていないか、SVGの含まれないHTMLがロードされた場合は、
    // SVGの含まれるHTMLのロードを要求する文面にする。

    if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {
        return (
            <div>
                <p>SVGは{props.value.length}枚です。</p>
            </div>
        );

    } else {
        return (
            <div>
                <p>SVGを含んだHTMLを選択してください。</p>
            </div>
        );
    }
}

function loadImage(src) {
    // SVGをCanvasへ描画した結果をPNGで返す関数

    const imageMagnification = 1.34;

    const reg = /(?<=<svg.+viewBox=")\d{1,}\s\d{1,}\s[0-9.]{1,}\s[0-9.]{1,}/;

    let width, height;
    let result = src.match(reg);
    [, , width, height] = result[0].split(' ');

    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        canvas.width = width * imageMagnification;
        canvas.height = height * imageMagnification;

        const ctx = canvas.getContext('2d');
        const img = new Image();

        let encoded = 'data:image/svg+xml;charset=utf-8;base64,' + btoa(unescape(encodeURIComponent(src)));

        img.src = encoded;

        img.crossOrigin = 'Anonymous';

        img.onload = () => {
            ctx.drawImage(img, 0, 0, img.width, img.height);

            let url = canvas.toDataURL();
            resolve(url);

        };
        img.onerror = (e) => reject(e);


    });
}

function RenderSVG(props) {
    // SVGとPNGをそれぞれ描画するコンポーネント

    useEffect(() => {
        if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {

            let result = [];

            const elemSvgs = document.getElementById('svgs');
            const elemPngs = document.getElementById('pngs');

            props.value.forEach((svgText, idx) => {

                loadImage(svgText).then(res => {
                    result.push(res);

                    // SVGの追加
                    elemSvgs.insertAdjacentHTML('beforeend', '<img key=img_' + idx + ' alt="" src=' +
                        ('data:image/svg+xml;charset=utf-8;base64,' + btoa(unescape(encodeURIComponent(svgText)))) + '></img>');

                    // PNGの追加
                    elemPngs.insertAdjacentHTML('beforeend', '<img key=img_' + idx + ' alt="" src=' + res + '></img>');
                }).catch(e => {
                    console.log('error: ' + e);
                });

            });

            elemSvgs.insertAdjacentHTML('beforebegin', '<h3>SVGs</h3>');
            elemPngs.insertAdjacentHTML('beforebegin', '<h3>PNGs</h3>');

        }

    });

    return (
        <>
            <div id="pngs">

            </div>

            <div id="svgs">

            </div>
        </>

    );

}

ReactDOM.render(
    <SvgToPng />,
    document.getElementById('root'),
);

```

- 今回は`Promise`を使ったが、async/awaitを利用した方がより可読性が向上すると思われる。
- 関数の戻り値が配列だったりするので、TypeScriptで実装した方が最終的にはいいかもしれない。

**思ったこと**: 

- TypeScript、勉強しなきゃ・・・。

**リンク** 

1. 特になし。

### 96日目: 2021年1月6日（水）

**今日の進捗**: 

昨日のSVGをPNG化するプログラムに機能追加した。

- PNG化した際にダウンロードリンクを追加出力する。

```jsx
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';

const splitSvgSource = (html) => {
    // SVGだけを抽出する関数

    let startReg = /<svg.*?\/svg>/sg;

    let result = html.match(startReg);

    if (result) {
        return result;
    } else {
        return;
    }

}

function SvgToPng() {
    // HTMLファイルの読み込みを行うコンポーネント
    // 選択されたHTMLはSVGのみ抽出し、フックに格納する。

    const [svg, setSvg] = useState([]);

    useEffect(() => {
        const f = document.getElementById('file');

        if (f === null) {
            return;
        }

        f.addEventListener('change', (e) => {

            let reader = new FileReader();
            reader.readAsText(e.target.files[0]);
            reader.onload = (() => {

                let splitedSVGSource = splitSvgSource(reader.result);
                if (splitedSVGSource) {
                    setSvg([...splitedSVGSource]);
                } else {
                    setSvg([]);
                }
            });

            const fileUploaderElem = document.getElementById('fileUpload');
            fileUploaderElem.remove();
        })

    });

    return (
        <>
            <form id="fileUpload">
                <input id="file" type="file" name="uploadedFile" />
            </form>

            <CountSVG key={'count'} value={svg} />

            <RenderSVG key={'render'} value={svg} />

        </>
    );
}

function CountSVG(props) {
    // アナウンス文を表示するコンポーネント
    // HTMLがロードされていないか、SVGの含まれないHTMLがロードされた場合は、
    // SVGの含まれるHTMLのロードを要求する文面にする。

    let notice = 'SVGを含んだHTMLを選択してください。';

    if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {
        notice = 'SVGは' + props.value.length + '枚です。';
    }

    return (
        <>
            <p>{notice}</p>
        </>
    );

}

function loadImage(src) {
    // SVGをCanvasへ描画した結果をPNGで返す関数

    const imageMagnification = 1.34;

    const reg = /(?<=<svg.+viewBox=")\d{1,}\s\d{1,}\s[0-9.]{1,}\s[0-9.]{1,}/;

    let width, height;
    let result = src.match(reg);
    [, , width, height] = result[0].split(' ');

    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        canvas.width = width * imageMagnification;
        canvas.height = height * imageMagnification;

        const ctx = canvas.getContext('2d');
        const img = new Image();

        let encoded = 'data:image/svg+xml;charset=utf-8;base64,' + btoa(unescape(encodeURIComponent(src)));

        img.src = encoded;

        img.crossOrigin = 'Anonymous';

        img.onload = () => {
            ctx.drawImage(img, 0, 0, img.width, img.height);

            let url = canvas.toDataURL();
            resolve(url);

        };

        img.onerror = (e) => reject(e);

    });
}

function RenderSVG(props) {
    // SVGとPNGをそれぞれ描画するコンポーネント

    useEffect(() => {

        const elemSvgs = document.getElementById('svgs');
        const elemPngs = document.getElementById('pngs');

        if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {

            let result = [];

            props.value.forEach((svgText, idx) => {

                loadImage(svgText).then(res => {
                    result.push(res);

                    // SVGの追加
                    elemSvgs.insertAdjacentHTML('beforeend', '<img key=img_' + idx + ' alt="" src=' +
                        ('data:image/svg+xml;charset=utf-8;base64,' + btoa(unescape(encodeURIComponent(svgText)))) + '></img>');

                    // PNGの追加
                    elemPngs.insertAdjacentHTML('beforeend', '<img key=img_' + idx + ' alt="" src=' + res + '></img>');
                    // ダウンロードリンクを追加
                    elemPngs.insertAdjacentHTML('beforeend', '<a key=url_' + idx + ' href=' + res + ' download="image.png">download</a>');
                }).catch(e => {
                    console.log('error: ' + e);
                });

            });

            elemSvgs.insertAdjacentHTML('afterbegin', '<h3>SVGs</h3>');
            elemPngs.insertAdjacentHTML('afterbegin', '<h3>PNGs</h3>');

        } else {
            while (elemPngs.firstChild) {
                elemPngs.removeChild(elemPngs.firstChild);
            }
            while (elemSvgs.firstChild) {
                elemSvgs.removeChild(elemSvgs.firstChild);
            }

        }

    });

    return (
        <>
            <div id="pngs">

            </div>

            <div id="svgs">

            </div>
        </>

    );

}

ReactDOM.render(
    <SvgToPng />,
    document.getElementById('root'),
);

```

- PNG化した際にimgタグに利用しているURLを、ダウンロードリンクとしてaタグで表示する。これにより、右クリックメニューからコピーする場合と個別に画像ファイルだけダウンロードする場合で、使い分けができる。まぁ、大抵は右クリックメニューからコピーする方が話が早いだろうが。
- 上記の機能追加とともに、ところどころのコードを修正した。`CountSVG`コンポーネントの部分で、`return`を一本化して変数出力するようなコードのみに修正し、状態が変わったら変数の内容だけ変更するようなコードとした。
- 一度ファイルを読み込んだら、ファイルのローダーを削除するよう修正した。これは、ファイルを読み込んだ後に別のファイルを読み込もうとすると、もともと表示されている内容が残ったまま新しい内容を描画しようとしたり、「PNGs」「SVGs」などの文言が複数出現したり、重複して表示したりとバグった挙動をしていたため。本来は、一度表示されている内容を削除するなどして初期化してから、新しく読み込まれたファイルについて処理すればいいのだが、その場合の再レンダリング方法がちょっと調べただけだと出てこなかった。そのため、ちょっと乱暴だが対処療法としてファイルローダー機能を削除することで、2度目以降のファイル読み込みを実行させないようにした。

**思ったこと**: 

- ファイル読み込みを複数回行っても、正常に行えるような実装はどうすればいいんだろう。とりあえず今は、対症療法でどうにかしているが・・・。

**リンク** 

1. [Node.removeChild](https://developer.mozilla.org/ja/docs/Web/API/Node/removeChild)
1. [ChildNode.remove](https://developer.mozilla.org/ja/docs/Web/API/ChildNode/remove)

### 97日目: 2021年1月7日（木）

**今日の進捗**: 

p5.jsで作ったCanvasについて、画面サイズが変更された場合でも追随するような実装。

- `windowWidth`と`windowHeight`を使ってウィンドウサイズを取得し、そのサイズでCanvasを生成する。
- ウィンドウサイズが変更されると、`windowResized()`という関数が実行される。リファレンスは[ここ](https://p5js.org/reference/#/p5/resizeCanvas)。

```javascript
let halfWidth, halfHeight;

setup=()=>{
  createCanvas(windowWidth, windowHeight);
}

draw=()=>{
  background(0);

  halfWidth = windowWidth / 2;
  halfHeight = windowHeight / 2;

  fill(255);
  rect(halfWidth, halfHeight, 100, 100);
  
}

windowResized=()=>{
  resizeCanvas(windowWidth, windowHeight);
}
```

- `draw()`内で画面サイズを逐次取得し、その半分の値を使ってオブジェクトを描画する。ウィンドウサイズが変更されても、都度Canvasごとレンダリングされオブジェクトも指定の位置に存在し続ける。

**思ったこと**: 

- 画面サイズいっぱいに出力することはあっても、スマートフォンなんかだと顕著だがそもそも「ウィンドウサイズを変更する」という前提がないデバイスもあるので、あくまでPC用ということになる。

**リンク** 

1. [resizeCanvas](https://p5js.org/reference/#/p5/resizeCanvas)
2. [windowResized](https://p5js.org/reference/#/p5/windowResized)
3. [【Canvas/p5.js】解決。canvas要素を可変(window幅やwindowの50%,中央寄せ)などに動的にする方法](https://kenjimorita.jp/canvas_windowresize_window_center/)

### 98日目: 2021年1月8日（金）

**今日の進捗**:

p5.jsでphotoshopの「雲模様」みないなテクスチャを作る。

- photoshopには、「雲模様」という雲とか湯気っぽいモヤを生成できるフィルターがある。テクスチャのでき具合から察するに、パーリンノイズからパターンを生成しているような気がしたので「p5.jsでも似たようなのできるんじゃね？」と思って作ってみた。

```javascript
let seed = 0;
let cellSize = 5;

setup=()=>{
  createCanvas(400, 400);
  
  colorMode(HSB, 100, 100, 100, 100);
  strokeWeight(cellSize * 10);
}

draw=()=>{
  background(0, 0, 0, 30);
  
    for (let w=0; w<=width; w+=cellSize){ 
      for (let h=0; h<=height; h+=cellSize){
      let n = noise(w * 0.015 + seed, h * 0.01 + seed, seed);
      let brightness = round(n * 45);
      
      stroke(95, 100, brightness, 100);
      if (brightness % 3 === 0){
        point(w, h);  
      }
      
    };
  };
  
  seed += 0.01;
}
```

- カラーモードをHSBにしているのは、brightnessを調節したかったため。単純にグレースケールで雲模様を生成するなら、RGBのままでいい。
- パーリンノイズを生成する部分のリテラルは、「黒地に赤いモヤがかかる」ようなテクスチャを生成したかったためで、赤分を多くするにはここのリテラルを調節する必要がある。
- `seed`に加算する値を変化させると、雲模様の変化する速度が変わる。

**思ったこと**: 

- 案外簡単にできたが、やっぱりちょっと処理が重め。

**リンク** 

1. [point](https://p5js.org/reference/#/p5/point)
1. [パーリンノイズでマーブル模様](http://30min-processing.hatenablog.com/entry/2016/07/24/000000)

### 99日目: 2021年1月9日（土）

**今日の進捗**: 

SVGをPNG化するJavaScriptについて、`insertAdjacentHTML`を使わずReactの関数コンポーネントでレンダーするよう修正してみた。

- `insertAdjacentHTML`を使わない理由は、SVGが含まれたHTMLを読み込んだ後にSVGのないHTMLを読み込んだときの処理が面倒だったため。一度`insertAdjacentHTML`で追加したDOM要素を削除するくらいなら、stateとして連動させればいいと思ったのだ。

```javascript
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';

const splitSvgSource = (html) => {
    // SVGだけを抽出する関数

    let startReg = /<svg.*?\/svg>/sg;

    let result = html.match(startReg);

    return new Promise((resolve, reject) => {
        if (result) {
            resolve(result);
        } else {
            resolve([]);
        }
    });

}

function SvgToPng() {
    // HTMLファイルの読み込みを行うコンポーネント
    // 選択されたHTMLはSVGのみ抽出し、フックに格納する。

    const [svg, setSvg] = useState([]);

    useEffect(() => {
        const f = document.getElementById('file');

        if (f === null) {
            return;
        }

        f.addEventListener('change', (e) => {

            let reader = new FileReader();
            reader.readAsText(e.target.files[0]);
            reader.onload = (async () => {

                let splitedSVGSource = await splitSvgSource(reader.result);

                if (splitedSVGSource) {
                    setSvg([...splitedSVGSource]);
                } else {
                    setSvg([]);
                }

            });

        })

    }, [svg]);

    return (
        <>
            <form id="fileUpload">
                <input id="file" type="file" name="uploadedFile" />
            </form>

            <CountSVG value={svg} />

            <RenderImage value={svg} />

        </>
    );
}

function CountSVG(props) {
    // アナウンス文を表示するコンポーネント
    // HTMLがロードされていないか、SVGの含まれないHTMLがロードされた場合は、
    // SVGの含まれるHTMLのロードを要求する文面にする。

    let notice;

    if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {
        notice = 'SVGは' + props.value.length + '枚です。';
    } else {
        notice = 'SVGを含んだHTMLを選択してください。';
    }

    return (
        <>
            <p>{notice}</p>
        </>
    );

}

function loadImage(src) {
    // SVGをCanvasへ描画した結果をPNGで返す関数

    const imageMagnification = 1.34;

    const reg = /(?<=<svg.+viewBox=")\d{1,}\s\d{1,}\s[0-9.]{1,}\s[0-9.]{1,}/;

    let width, height;
    let result = src.match(reg);
    [, , width, height] = result[0].split(' ');

    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        canvas.width = width * imageMagnification;
        canvas.height = height * imageMagnification;

        const ctx = canvas.getContext('2d');
        const img = new Image();

        let encoded = 'data:image/svg+xml;charset=utf-8;base64,' + btoa(unescape(encodeURIComponent(src)));

        img.src = encoded;

        img.crossOrigin = 'Anonymous';

        img.onload = () => {
            ctx.drawImage(img, 0, 0, img.width, img.height);

            let url = canvas.toDataURL();
            resolve(url);

            canvas.remove();

        };

        img.onerror = (e) => reject(e);

    });
}

const RenderPngAndDownloadLink = (props) => {

    let pngIndex = props.id + 1
    let fileName = 'image_' + pngIndex + '.png';

    return (
        <>
            <h4>{pngIndex}.</h4>
            <img alt="" src={props.png}></img>
            <a href={props.png} download={fileName}>download</a>
        </>
    );
}

function RenderImage(props) {
    const [pngs, setPngs] = useState([]);
    // SVGとPNGをそれぞれ描画するコンポーネント

    useEffect(() => {

        if (Array.isArray(props.value) && Object.keys(props.value).length > 0) {

            Promise.all(props.value.map(svgText => loadImage(svgText))
            ).then(pngs => {
                let pngsWithImageTag = pngs.map((png, idx) => {
                    const RenderPngIndex = 'png_index_' + idx;
                    return (<RenderPngAndDownloadLink key={RenderPngIndex} id={idx} png={png} />);
                });

                setPngs([...pngsWithImageTag]);
            });

        } else {

            setPngs([]);
        }

        return () => console.log('clean up');

    }, [props.value]);

    return (
        <>
            <div id="pngs">
                {pngs}
            </div>

            <div id="svgs">

            </div>
        </>

    );

}

ReactDOM.render(
    <SvgToPng />,
    document.getElementById('root'),
);


```

- PNG化したSVGはダウンロードリンクとともに表示するため、見た目には前回と変わっていない。
- stateを利用し、stateの内容をそのままレンダリングするようなロジックにしたため、プログラムの見通しは良くなったかと思う。記述量も減っている。
- 反面、`useEffect()`などで第2引数を指定しないと、レンダリングがループするようなこともあった。

**思ったこと**: 

- まあまあ難産だった。特に、レンダリングがループするところとか苦労した。`useEffect()`の第2引数にオブジェクトを指定することで、レンダリングがループする現象は回避した。
- `map()`は返す値の順番は保証しても、コールバック関数の実行の順序は保証しないそうだ。

**リンク** 

1. [ステートフックの利用法](https://ja.reactjs.org/docs/hooks-state.html)
1. [フック API リファレンス](https://ja.reactjs.org/docs/hooks-reference.html)
1. [React Hooks useState の setStateの反映タイミング](https://teratail.com/questions/204921)
1. [Promise.all()](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)
1. [関数型Reactコンポーネントでレンダリングと副作用Hookが実行されるタイミング](https://www.hypertextcandy.com/when-hook-is-called)
1. [JavaScriptでPromiseの配列を直列に実行する](https://www.koheiando.com/tech/node-js/35)
1. [Array.prototype.map()](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

### 100日目: 2021年1月10日（日）

**今日の進捗**: 

vscodeでの正規表現指定について。

- vscodeで検索や置換を行う際に利用できる、正規表現について記述する。

|表記方法|意味|例|備考|
|---|---|---|---|
|`.`|任意の文字1文字|`^.$`|スペースを含める。|
|`*`|直前の文字の0回以上の繰り返し|`.*`|0文字以上なので空文字でもヒットする。|
|`+`|直前の文字の1回以上の繰り返し|`hoge+`|`hoge`や`hogeeee`などがヒットする。|
|`^`|行頭|`^hoge.+`||
|`$`|行末|`hoge$`||
|`[]`|角カッコで囲われた中の1文字|`[0-9]`、`[ABC]`、`[a-zA-Z]`|ハイフンを使用すると「XXXからXXXまで」の指定が可能。|
|`{}`|直前の文字が出現する回数|`hoge{3}`|`hogeee`にヒットする。|
|`()`|マッチした文字列を`$1,$2,$3...`で指定可能|'ho(ge{3})`|`$1`と記述すると`geee`に置き換わる。|

- `{}`の繰り返し数は、`{1}`の場合だと`{}`の指定がない場合と同一。
- `()`に関しては検索より置換で威力を発揮する。マッチした一部はそのまま流用し、それ以外の部分を置き換える場合などだ。

```javascript
let s = 'hogeeeeee';

console.log(s.match(/ge{3}/g));

let t = 'fugabcdef';
let reg = /g[a-z]{3}([a-z]{3})/g;

console.log(t.match(reg));
console.log(t.replace(reg, 'foo$1'));
```

- ちなみに、JavaScriptでも同様の挙動で動作する。

```console
(1)["geee"]
(1)["gabcdef"]
fufoodef
```

- 上記のように、「もともと存在する文字列を活かしつつ置換したい」場合に利用できる。

```
`ho(ge)fu(ga)pi(yo)`
```

- 上記のような検索条件を設定した場合、丸カッコで囲った部分が左から`$1,$2,$3`に該当する。

```
`foo$1bar$2baz$3`
```

- 置換条件を上記のように設定した場合、置換結果は`foogebargabazyo`となる。

----

メモ。

Pythonでベン図を書くには[matplotlib-venn](https://github.com/konstantint/matplotlib-venn)が必要。matplotlibでは描画できない。

**思ったこと**: 

- 100日目！

**リンク** 

1. [Visual Studio Codeを用いた簡単な正規表現検索](https://qiita.com/kgsi/items/a88662c6e43fa5311288)
1. [matplotlib-venn](https://github.com/konstantint/matplotlib-venn)
1. [String.prototype.match](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/match)
1. [String.prototype.replace](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String/replace)

### 101日目: 2021年1月11日（月）

**今日の進捗**: 

Pythonの「集合」について。

- 「集合」とは、リストやタプルといったコレクション型のうちの1つ。ミュータブルで値の追加や削除が可能。
- イミュータブルな集合である`frozenset`というオブジェクトもある。

```python
>>> h = {'hoge', 'fuga', 'piyo'}
>>> h
{'fuga', 'hoge', 'piyo'}
>>> type(h)
<class 'set'>
```

- 上記のように、`set`は波かっこ`{}`で囲って宣言する。

```python
>>> {'foo', 'bar', 'baz'}
{'bar', 'foo', 'baz'}
>>> {'foo', 'foo', 'foo'}
{'foo'}
>>> {'foo', 'bar', 'baz', 'foo', 'foo'}
{'bar', 'foo', 'baz'}
```

- 数学の集合のように、ある集合の要素は必ずそれぞれユニークであり、同一の値を複数保持することはできない。
- リストやタプルとは異なり、順番の概念を持たない。

```python
>>> set_hoge = set([1, 2, 3, 4, 3, 2, 1, 1, 2])
>>> set_hoge
{1, 2, 3, 4}
```

- 集合を波かっこで作成する以外に、コンストラクタ`set()`の引数にリストやタプルなどのイミュータブルなオブジェクトを指定することでも集合を作成できる。この場合、重複している要素は自動的に除外され、ユニークな値のみ残る。
- ちなみに、上記の例だとなんとなく昇順にソートされているように見えるが、これはたまたまそうなっただけ。集合は順番を保持しない。

```python
>>> set_fuga = set()
>>> set_fuga
set()
>>> type(set_fuga)
<class 'set'>
```

- コンストラクタの引数を省略した場合、空集合が作成される。

```python
>>> set_piyo = {i * 2 for i in range(5)}
>>> set_piyo
{0, 2, 4, 6, 8}
```

- リストと同様に、集合にも内包表記が存在する。記述方法はリスト内包表記の角カッコ`[]`を波かっこ`{}`に変更するだけ。

```python
>>> set_hoge
{1, 2, 3, 4}
>>> len(set_hoge)
4
>>> set_fuga
set()
>>> len(set_fuga)
0
>>> set_piyo
{0, 2, 4, 6, 8}
>>> len(set_piyo)
5
```

- 要素数を見たい場合は`len()`で参照可能。空集合は0。

```python
>>> list_hoge = list(set_hoge)
>>> list_hoge
[1, 2, 3, 4]
>>> type(list_hoge)
<class 'list'>
>>> tuple_piyo = tuple(set_piyo)
>>> tuple_piyo
(0, 2, 4, 6, 8)
>>> type(tuple_piyo)
<class 'tuple'>
```

- 集合はリストやタプルに変換できる。

```python
>>> hoge = {'foo', 'bar', 'baz'}
>>> hoge.add(1)
>>> hoge
{'baz', 'bar', 'foo', 1}
>>> hoge.add(9, 8, 7)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: add() takes exactly one argument (3 given)
>>> hoge.add({9, 8, 7})
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'set'
>>> hoge.add([9, 8, 7])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
```

- `add()`を使って要素の追加が可能。ただし、引数は1つしか指定できない（引数自体は2つまで指定可能だが、要素として指定できる引数は1つまで）。

**思ったこと**: 

- ユニークな要素を操作したいシチュエーションで使えそう。

**リンク** 

1. [setオブジェクト](https://docs.python.org/ja/3/c-api/set.html)
1. [Python, set型で集合演算（和集合、積集合や部分集合の判定など）](https://note.nkmk.me/python-set/)
1. [4. Pythonのデータ型（コレクション編）](https://pycamp.pycon.jp/textbook/4_collections.html)

### 102日目: 2021年1月12日（火）

**今日の進捗**:

Pythonの集合の続き。

```python
>>> hoge = {1, 2, 3, 4, 5}
>>> hoge.discard(1)
>>> hoge
{2, 3, 4, 5}
>>> hoge.discard(9)
>>> hoge
{2, 3, 4, 5}
```

- 集合の要素を削除するにはいくつか方法がある。`discard()`は、引数で指定された要素を削除する。集合内に存在しない値が引数に指定された場合、特にエラーなどは出力せず終了する。
- 指定できる引数は1つのみ。

```python
>>> hoge.remove(2)
>>> hoge
{3, 4, 5}
>>> hoge.remove(9)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 9
```

- `remove()`も`discard()`と同様に、引数に指定された要素を削除する。`discard()`と異なるのは、集合内に存在しない値が引数に指定された場合、エラーとするところ。
- こちらも指定できる引数は1つまで。

```python
>>> hoge.pop()
3
>>> hoge
{4, 5}
>>> hoge.pop()
4
>>> hoge
{5}
>>> hoge.pop()
5
>>> hoge
set()
>>> hoge.pop()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'pop from an empty set'
```

- `pop()`は、厳密には削除ではなく集合から任意の値を取り出す。取り出された値は、集合から消える。引数は指定できない。
- 空集合から取り出そうとするとエラーになる。

```python
>>> hoge = {3, 1, 2, 0}
>>> hoge.pop()
0
>>> hoge.pop()
1
>>> hoge.pop()
2
>>> hoge.pop()
3
>>> hoge.pop()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'pop from an empty set'
>>> hoge = {'z', 'A', 'a', 'Z', '0'}
>>> hoge.pop()
'0'
>>> hoge.pop()
'A'
>>> hoge.pop()
'z'
>>> hoge.pop()
'a'
>>> hoge.pop()
'Z'
>>> hoge.pop()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'pop from an empty set'
```

- こうして見ると、取り出す順番があるようなないような・・・。もともと集合には順番の概念がないので、あくまで「任意の要素を取り出す」ものだと思っておいたほうがいい。

```python
>>> hoge = {3, 2, 1}
>>> hoge.clear()
>>> hoge
set()
>>> 
```

- `clear()`は要素全てを削除し、空集合にする。

----

集合なので、和集合や積集合も取れる。

```python
>>> hoge = {1, 2, 3, 4, 5}
>>> fuga = {4, 5, 6, 7, 8}
>>> hoge | fuga
{1, 2, 3, 4, 5, 6, 7, 8}
>>> hoge.union(fuga)
{1, 2, 3, 4, 5, 6, 7, 8}
>>> fuga.union(hoge)
{1, 2, 3, 4, 5, 6, 7, 8}
```

- `|`で接続するか`union()`で和集合を取得できる。

```python
>>> hoge & fuga
{4, 5}
>>> hoge.intersection(fuga)
{4, 5}
>>> fuga.intersection(hoge)
{4, 5}
>>> 
```

- `&`で接続するか`intersection()`で積集合を取得できる。

```python
>>> hoge = {1, 2, 3, 4, 5}
>>> fuga = {4, 5, 6, 7, 8}
>>> hoge - fuga
{1, 2, 3}
>>> hoge.difference(fuga)
{1, 2, 3}
>>> fuga - hoge
{8, 6, 7}
>>> fuga.difference(hoge)
{8, 6, 7}
```

- `-`で集合から集合を引く、あるいは`difference()`を使って差集合を取得できる。

```python
>>> hoge ^ fuga
{1, 2, 3, 6, 7, 8}
>>> hoge.symmetric_difference(fuga)
{1, 2, 3, 6, 7, 8}
>>> fuga.symmetric_difference(hoge)
{1, 2, 3, 6, 7, 8}
```

- `^`か`symmetric_defference()`で対象差集合が取得できる。対象差集合とはXORに相当し、どちらか一方にのみ含まれる要素を取得する。

```python
>>> hoge = {0, 1, 2, 3, 4, 5}
>>> fuga = {0, 1, 2}
>>> hoge <= fuga
False
>>> fuga <= hoge
True
>>> hoge.issubset(fuga)
False
>>> fuga.issubset(hoge)
True
>>> hoge < fuga
False
>>> fuga < hoge
True
```

- 部分集合か判定するメソッドが存在する。`<=`または`issubset()`を実行するとTrueまたはFalseが返ってくる。

```python
>>> hoge >= fuga
True
>>> fuga >= hoge
False
>>> hoge.issuperset(fuga)
True
>>> fuga.issuperset(hoge)
False
>>> hoge > hoge
False
>>> hoge > fuga
True
```

- 上位集合か判定するメソッドが存在する。`>=`または`issuperset()`を実行するとTrueまたはFalseが返ってくる。

```python
>>> hoge = {1, 2, 3}
>>> fuga = {4, 5, 6}
>>> piyo = {1, 4}
>>> hoge.isdisjoint(fuga)
True
>>> hoge.isdisjoint(piyo)
False
>>> fuga.isdisjoint(piyo)
False
>>> fuga.isdisjoint(hoge)
True
```

- `isdisjoint()`を使って、集合が互いに素かどうか判定可能。

**思ったこと**: 

- `add()`もそうだが、集合に関しては複数の要素の操作を想定してないんだろうか。

**リンク** 

1. [setオブジェクト](https://docs.python.org/ja/3/c-api/set.html)
1. [Python, set型で集合演算（和集合、積集合や部分集合の判定など）](https://note.nkmk.me/python-set/)

### 103日目: 2021年1月13日（水）

**今日の進捗**:

集合に複数の要素を足したいときについて。

- 集合に要素を追加する`add()`は、1つの引数しか指定できない。
- そこで複数の要素を一度に追加するためには和集合を用いることにする。

```python
>>> hoge = {1, 2}
>>> hoge |= set([3, 4])
>>> hoge
{1, 2, 3, 4}
```

- ぱっと見だと、何やってるかイマイチわからない。が、理屈が分かれば腹落ちする。

```python
>>> a = 1
>>> a += 2
>>> a
3
```

- つまり上記の和集合版である。本来は`hoge = hoge | set([3, 4])`を記述するところ、省略して書いている。
- これを使えば複数の要素を追加することが可能になる。

**思ったこと**: 

- 簡にして要を得るとはこのことか。

**リンク** 

1. [Python: setにlistやtupleを追加する](https://ohke.hateblo.jp/entry/2018/06/23/230000)

### 104日目: 2021年1月14日（木）

**今日の進捗**:

Pythonのデコレータについて。

- Pythonのコードで、たまに`@hoge`のようにアットマークがついたコードを見ることがある。これはデコレータといって、関数を引数にとって新しい関数を返す機能のこと。
- なんかどっかで聞いたような・・・と思ったらJSのクロージャだった。実際、記述はともかく機能としては近い。

[Pythonのデコレータを理解するための12Step](https://qiita.com/_rdtr/items/d3bc1a8d4b7eb375c368)の記事がとても参考になったので、これを元に記述していく。

**思ったこと**: 

- 

**リンク** 

1. []()

### x日目: 2021年1月x日（x）

**今日の進捗**:

- 

**思ったこと**: 

- 

**リンク** 

1. []()
